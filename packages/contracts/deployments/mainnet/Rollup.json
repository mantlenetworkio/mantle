{
  "address": "0x242a33ca49C564caFC9C83C700b79f1074c42A0D",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AssertionAlreadyResolved",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AssertionOutOfRange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ChallengePeriodPending",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ChallengedStaker",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DifferentParent",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EmptyAssertion",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "staker1Challenge",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "staker2Challenge",
          "type": "address"
        }
      ],
      "name": "InDifferentChallenge",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InboxReadLimitExceeded",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientStake",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidParent",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MinimumAssertionPeriodNotPassed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoStaker",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoUnresolvedAssertion",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAllStaked",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInChallenge",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotStaked",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ParentAssertionUnstaked",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PreviousStateHash",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RedundantInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "StakedOnUnconfirmedAssertion",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "StakerStakedOnTarget",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "StakersPresent",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnproposedAssertion",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WrongOrder",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "assertionID",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "challengeAddr",
          "type": "address"
        }
      ],
      "name": "AssertionChallenged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "assertionID",
          "type": "uint256"
        }
      ],
      "name": "AssertionConfirmed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "assertionID",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "asserterAddr",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "vmHash",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inboxSize",
          "type": "uint256"
        }
      ],
      "name": "AssertionCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "assertionID",
          "type": "uint256"
        }
      ],
      "name": "AssertionRejected",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "stakerAddr",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "assertionID",
          "type": "uint256"
        }
      ],
      "name": "StakerStaked",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "toAddAddresses",
          "type": "address[]"
        }
      ],
      "name": "addToOperatorWhitelist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "toAddAddresses",
          "type": "address[]"
        }
      ],
      "name": "addToStakerWhitelist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assertionID",
          "type": "uint256"
        }
      ],
      "name": "advanceStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "assertions",
      "outputs": [
        {
          "internalType": "contract AssertionMap",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "baseStakeAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[2]",
          "name": "players",
          "type": "address[2]"
        },
        {
          "internalType": "uint256[2]",
          "name": "assertionIDs",
          "type": "uint256[2]"
        }
      ],
      "name": "challengeAssertion",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "challengeCtx",
      "outputs": [
        {
          "internalType": "bool",
          "name": "completed",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "challengeAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "defenderAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "challengerAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "defenderAssertionID",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "challengerAssertionID",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "loser",
          "type": "address"
        }
      ],
      "name": "completeChallenge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "confirmFirstUnresolvedAssertion",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "confirmedInboxSize",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "vmHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "inboxSize",
          "type": "uint256"
        }
      ],
      "name": "createAssertion",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "vmHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "inboxSize",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "_batch",
          "type": "bytes32[]"
        },
        {
          "internalType": "uint256",
          "name": "_shouldStartAtElement",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_signature",
          "type": "bytes"
        }
      ],
      "name": "createAssertionWithStateBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentRequiredStake",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_verifier",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_stakeToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_libAddressManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_assertionMap",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_minimumAssertionPeriod",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_baseStakeAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "_initialVMhash",
          "type": "bytes32"
        },
        {
          "internalType": "address[]",
          "name": "stakerWhitelists",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "operatorWhitelists",
          "type": "address[]"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "isStaked",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastConfirmedAssertionID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastCreatedAssertionID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastResolvedAssertionID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "libAddressManager",
      "outputs": [
        {
          "internalType": "contract Lib_AddressManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minimumAssertionPeriod",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "numStakers",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "operatorWhitelist",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operatorslist",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "registers",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rejectFirstUnresolvedAssertion",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "batchIndex",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "batchRoot",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "batchSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prevTotalElements",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_BVMCodec.ChainBatchHeader",
          "name": "_batchHeader",
          "type": "tuple"
        }
      ],
      "name": "rejectLatestCreatedAssertionWithBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "toRemoveAddresses",
          "type": "address[]"
        }
      ],
      "name": "removeFromOperatorWhitelist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "toRemoveAddresses",
          "type": "address[]"
        }
      ],
      "name": "removeFromStakerWhitelist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "removeOldZombies",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "stakerAddress",
          "type": "address"
        }
      ],
      "name": "removeStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_shouldRollBack",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_shouldStartAtElement",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_signature",
          "type": "bytes"
        }
      ],
      "name": "rollbackL2Chain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "stakeAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "stake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stakeToken",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "stakerWhitelist",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "stakers",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isStaked",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "amountStaked",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "assertionID",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "currentChallenge",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "stakerslist",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "stakeAmount",
          "type": "uint256"
        }
      ],
      "name": "unstake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "verifier",
      "outputs": [
        {
          "internalType": "contract IVerifierEntry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "withdrawableFunds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "zombies",
      "outputs": [
        {
          "internalType": "address",
          "name": "stakerAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "lastAssertionID",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x889d02b77ab2c21f5e8db8336d273a37fab77744057e9c63d0e35145ebec1b2a",
  "receipt": {
    "to": null,
    "from": "0x2A2954F3989a83Cc43DD58B0f038D5F276f21333",
    "contractAddress": "0x242a33ca49C564caFC9C83C700b79f1074c42A0D",
    "transactionIndex": 0,
    "gasUsed": "5258208",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000800000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000",
    "blockHash": "0xfd524e6a053b50888eee52fa8edc7c199d80eec0960e93f6977328edb4971c08",
    "transactionHash": "0x889d02b77ab2c21f5e8db8336d273a37fab77744057e9c63d0e35145ebec1b2a",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 17578242,
        "transactionHash": "0x889d02b77ab2c21f5e8db8336d273a37fab77744057e9c63d0e35145ebec1b2a",
        "address": "0x242a33ca49C564caFC9C83C700b79f1074c42A0D",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 0,
        "blockHash": "0xfd524e6a053b50888eee52fa8edc7c199d80eec0960e93f6977328edb4971c08"
      }
    ],
    "blockNumber": 17578242,
    "cumulativeGasUsed": "5258208",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "322573d8b501a415312ae007ebdbca9f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AssertionAlreadyResolved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AssertionOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChallengePeriodPending\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChallengedStaker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DifferentParent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyAssertion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker1Challenge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker2Challenge\",\"type\":\"address\"}],\"name\":\"InDifferentChallenge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InboxReadLimitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientStake\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinimumAssertionPeriodNotPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoStaker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoUnresolvedAssertion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllStaked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInChallenge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStaked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParentAssertionUnstaked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PreviousStateHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedundantInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakedOnUnconfirmedAssertion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakerStakedOnTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakersPresent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnproposedAssertion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assertionID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeAddr\",\"type\":\"address\"}],\"name\":\"AssertionChallenged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assertionID\",\"type\":\"uint256\"}],\"name\":\"AssertionConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assertionID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asserterAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"vmHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inboxSize\",\"type\":\"uint256\"}],\"name\":\"AssertionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assertionID\",\"type\":\"uint256\"}],\"name\":\"AssertionRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakerAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assertionID\",\"type\":\"uint256\"}],\"name\":\"StakerStaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toAddAddresses\",\"type\":\"address[]\"}],\"name\":\"addToOperatorWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toAddAddresses\",\"type\":\"address[]\"}],\"name\":\"addToStakerWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assertionID\",\"type\":\"uint256\"}],\"name\":\"advanceStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assertions\",\"outputs\":[{\"internalType\":\"contract AssertionMap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"players\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"assertionIDs\",\"type\":\"uint256[2]\"}],\"name\":\"challengeAssertion\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeCtx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"challengeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defenderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"challengerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"defenderAssertionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengerAssertionID\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"completeChallenge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmFirstUnresolvedAssertion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmedInboxSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"vmHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inboxSize\",\"type\":\"uint256\"}],\"name\":\"createAssertion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"vmHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inboxSize\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_batch\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_shouldStartAtElement\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"createAssertionWithStateBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRequiredStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assertionMap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumAssertionPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_baseStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_initialVMhash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"stakerWhitelists\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"operatorWhitelists\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastConfirmedAssertionID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCreatedAssertionID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastResolvedAssertionID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAssertionPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operatorWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorslist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rejectFirstUnresolvedAssertion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_BVMCodec.ChainBatchHeader\",\"name\":\"_batchHeader\",\"type\":\"tuple\"}],\"name\":\"rejectLatestCreatedAssertionWithBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toRemoveAddresses\",\"type\":\"address[]\"}],\"name\":\"removeFromOperatorWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toRemoveAddresses\",\"type\":\"address[]\"}],\"name\":\"removeFromStakerWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeOldZombies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"}],\"name\":\"removeStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shouldRollBack\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shouldStartAtElement\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"rollbackL2Chain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assertionID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currentChallenge\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakerslist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract IVerifierEntry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawableFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"zombies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastAssertionID\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AssertionAlreadyResolved()\":[{\"details\":\"Thrown when the assertion is already resolved\"}],\"AssertionOutOfRange()\":[{\"details\":\"Thrown when a staker tries to advance stake to invalid assertionId.\"}],\"ChallengePeriodPending()\":[{\"details\":\"Thrown when the challenge period has not passed\"}],\"ChallengedStaker()\":[{\"details\":\"Thrown when the staker is currently in Challenge\"}],\"DifferentParent()\":[{\"details\":\"Thrown when the challenger and defender didn't attest to sibling assertions\"}],\"EmptyAssertion()\":[{\"details\":\"Thrown when a sender tries to create assertion without any tx.\"}],\"InDifferentChallenge(address,address)\":[{\"details\":\"Thrown when the two stakers are in different challenge\",\"params\":{\"staker1Challenge\":\"challenge address of staker 1\",\"staker2Challenge\":\"challenge address of staker 2\"}}],\"InboxReadLimitExceeded()\":[{\"details\":\"Thrown when the requested assertion read past the end of current Inbox.\"}],\"InsufficientStake()\":[{\"details\":\"Thrown when the function is called with Insufficient Stake\"}],\"InvalidParent()\":[{\"details\":\"Thrown when the assertion's parent is not the last confirmed assertion\"}],\"MinimumAssertionPeriodNotPassed()\":[{\"details\":\"Thrown when a sender tries to create assertion before the minimum assertion time period\"}],\"NoStaker()\":[{\"details\":\"Thrown when there are zero stakers\"}],\"NoUnresolvedAssertion()\":[{\"details\":\"Thrown when there is no unresolved assertion\"}],\"NotAllStaked()\":[{\"details\":\"Thrown when all the stakers are not staked\"}],\"NotInChallenge()\":[{\"details\":\"Thrown when the staker is not in a challenge\"}],\"NotStaked()\":[{\"details\":\"Thrown when address that have not staked any token calls a only-staked function\"}],\"ParentAssertionUnstaked()\":[{\"details\":\"Thrown when a staker tries to advance stake to non-child assertion\"}],\"PreviousStateHash()\":[{\"details\":\"Thrown when parent's statehash is not equal to the start state(or previous state)/\"}],\"RedundantInitialized()\":[{\"details\":\"Thrown when slot is not blank in initialize step\"}],\"StakedOnUnconfirmedAssertion()\":[{\"details\":\"Thrown when the caller is staked on unconfirmed assertion.\"}],\"StakerStakedOnTarget()\":[{\"details\":\"Thrown staker's assertion is descendant of firstUnresolved assertion\"}],\"StakersPresent()\":[{\"details\":\"Thrown when there are staker's present on the assertion\"}],\"TransferFailed()\":[{\"details\":\"Thrown when transfer fails\"}],\"UnproposedAssertion()\":[{\"details\":\"Thrown when the challenger tries to challenge an unproposed assertion\"}],\"WrongOrder()\":[{\"details\":\"Thrown when the challenge assertion Id is not ordered or in range.\"}],\"ZeroAddress()\":[{\"details\":\"Thrown when function is called with a zero address argument\"}]},\"kind\":\"dev\",\"methods\":{\"advanceStake(uint256)\":{\"params\":{\"assertionID\":\"ID of assertion to advance stake to. Currently this must be a child of the current assertion. TODO: generalize to arbitrary descendants.\"}},\"challengeAssertion(address[2],uint256[2])\":{\"params\":{\"assertionIDs\":\"Assertion IDs of the players engaged in the challenge. The first ID should be the earlier-created and is the one being challenged.\",\"players\":\"Defender (first) and challenger (second) addresses. Must be staked on DAs on different branches.\"},\"returns\":{\"_0\":\"Newly created challenge contract address.\"}},\"completeChallenge(address,address)\":{\"params\":{\"loser\":\"Address of losing staker.\",\"winner\":\"Address of winning staker.\"}},\"confirmedInboxSize()\":{\"returns\":{\"_0\":\"confirmedInboxSize size of inbox confirmed\"}},\"createAssertion(bytes32,uint256)\":{\"params\":{\"inboxSize\":\"Size of inbox corresponding to assertion (number of transactions).\",\"vmHash\":\"New VM hash.\"}},\"createAssertionWithStateBatch(bytes32,uint256,bytes32[],uint256,bytes)\":{\"params\":{\"_batch\":\"Batch of state roots.\",\"_shouldStartAtElement\":\"Index of the element at which this batch should start.\",\"_signature\":\"tss group signature of state batches.\",\"inboxSize\":\"Size of inbox corresponding to assertion (number of transactions).\",\"vmHash\":\"New VM hash.\"}},\"currentRequiredStake()\":{\"returns\":{\"_0\":\"The current required stake amount.\"}},\"isStaked(address)\":{\"params\":{\"addr\":\"User address.\"},\"returns\":{\"_0\":\"True if address is staked, else False.\"}},\"removeStake(address)\":{\"params\":{\"stakerAddress\":\"Address of staker for which to unstake.\"}},\"resolve(string)\":{\"params\":{\"_name\":\"Name to resolve an address for.\"},\"returns\":{\"_0\":\"Address associated with the given name.\"}},\"rollbackL2Chain(uint256,uint256,bytes)\":{\"params\":{\"_shouldRollBack\":\"roll back to should start.\",\"_shouldStartAtElement\":\"Index of the element at which this batch should start\",\"_signature\":\"signature of rollback message\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"unstake(uint256)\":{\"params\":{\"stakeAmount\":\"Token amount to withdraw. Must be <= sender's current stake minus the current required stake.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addToOperatorWhitelist(address[])\":{\"notice\":\"Add to whitelist\"},\"addToStakerWhitelist(address[])\":{\"notice\":\"Add to staker whitelist\"},\"advanceStake(uint256)\":{\"notice\":\"Advances msg.sender's existing sake to assertionID.\"},\"challengeAssertion(address[2],uint256[2])\":{\"notice\":\"Initiates a dispute between a defender and challenger on an unconfirmed DA.\"},\"completeChallenge(address,address)\":{\"notice\":\"Completes ongoing challenge. Callback, called by a challenge contract.\"},\"confirmFirstUnresolvedAssertion()\":{\"notice\":\"Confirms first unresolved assertion. Assertion is confirmed if and only if: (1) there is at least one staker, and (2) challenge period has passed, and (3) predecessor has been confirmed, and (4) all stakers are staked on the assertion.\"},\"createAssertion(bytes32,uint256)\":{\"notice\":\"Creates a new DA representing the rollup state after executing a block of transactions (sequenced in SequencerInbox). Block is represented by all transactions in range [prevInboxSize, inboxSize]. The latest staked DA of the sender is considered to be the predecessor. Moves sender stake onto the new DA. The new DA stores the hash of the parameters: vmHash\"},\"createAssertionWithStateBatch(bytes32,uint256,bytes32[],uint256,bytes)\":{\"notice\":\"create assertion with scc state batch\"},\"rejectFirstUnresolvedAssertion()\":{\"notice\":\"Rejects first unresolved assertion. Assertion is rejected if and only if: (1) all of the following are true: (a) challenge period has passed, and (b) at least one staker exists, and (c) no staker remains staked on the assertion (all have been destroyed). OR (2) predecessor has been rejected\"},\"removeFromOperatorWhitelist(address[])\":{\"notice\":\"Remove from whitelist\"},\"removeFromStakerWhitelist(address[])\":{\"notice\":\"Remove from whitelist\"},\"removeStake(address)\":{\"notice\":\"Removes stakerAddress from the set of stakers and withdraws the full stake amount to stakerAddress. This can be called by anyone since it is currently necessary to keep the chain progressing.\"},\"resolve(string)\":{\"notice\":\"Resolves the address associated with a given name.\"},\"rollbackL2Chain(uint256,uint256,bytes)\":{\"notice\":\"Emit event to notify sequencers to roll back.\"},\"stake(uint256,address)\":{\"notice\":\"Deposits stake on staker's current assertion (or the last confirmed assertion if not currently staked).currently use MNT to stake; stakeAmount Token amount to deposit. Must be > than defined threshold if this is a new stake.\"},\"unstake(uint256)\":{\"notice\":\"Withdraws stakeAmount from staker's stake by if assertion it is staked on is confirmed.\"},\"withdraw()\":{\"notice\":\"Withdraws all of msg.sender's withdrawable funds.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/L1/fraud-proof/Rollup.sol\":\"Rollup\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0203dcadc5737d9ef2c211d6fa15d18ebc3b30dfa51903b64870b01a062b0b4e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x611aa3f23e59cfdd1863c536776407b3e33d695152a266fa7cfb34440a29a8a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"contracts/L1/fraud-proof/AssertionMap.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Modifications Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./libraries/Errors.sol\\\";\\n\\n// Exists only to reduce size of Rollup contract (maybe revert since Rollup fits under optimized compilation).\\ncontract AssertionMap is Initializable {\\n    error ChildInboxSizeMismatch();\\n\\n    error SiblingStateHashExists();\\n\\n    struct Assertion {\\n        bytes32 stateHash; // Hash of execution state associated with assertion (see `RollupLib.stateHash`)\\n        uint256 inboxSize; // Inbox size this assertion advanced to\\n        uint256 parent; // Parent assertion ID\\n        uint256 deadline; // Confirmation deadline (L1 block timestamp)\\n        uint256 proposalTime; // L1 block number at which assertion was proposed\\n        // Staking state\\n        uint256 numStakers; // total number of stakers that have ever staked on this assertion. increasing only.\\n        // Child state\\n        uint256 childInboxSize; // child assertion inbox state\\n    }\\n\\n    struct AssertionState {\\n        mapping(address => bool) stakers; // all stakers that have ever staked on this assertion.\\n        mapping(bytes32 => bool) childStateHashes; // child assertion vm hashes\\n    }\\n\\n    mapping(uint256 => Assertion) public assertions;\\n    mapping(uint256 => AssertionState) private assertionStates; // mapping from assertionID to assertion state\\n    address public rollupAddress;\\n\\n    modifier rollupOnly() {\\n        if (msg.sender != rollupAddress) {\\n            revert NotRollup(msg.sender, rollupAddress);\\n        }\\n        _;\\n    }\\n\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    function initialize() public initializer {}\\n\\n    function setRollupAddress(address _rollupAddress) public {\\n        require(\\n            address(rollupAddress) == address(0),\\n            \\\"rollupAddress already initialized.\\\"\\n        );\\n        require(_rollupAddress != address(0), \\\"ZERO_ADDRESS\\\");\\n        rollupAddress = _rollupAddress;\\n    }\\n\\n    function getStateHash(uint256 assertionID) external view returns (bytes32) {\\n        return assertions[assertionID].stateHash;\\n    }\\n\\n    function getInboxSize(uint256 assertionID) external view returns (uint256) {\\n        return assertions[assertionID].inboxSize;\\n    }\\n\\n    function getParentID(uint256 assertionID) external view returns (uint256) {\\n        return assertions[assertionID].parent;\\n    }\\n\\n    function getDeadline(uint256 assertionID) external view returns (uint256) {\\n        return assertions[assertionID].deadline;\\n    }\\n\\n    function getProposalTime(uint256 assertionID) external view returns (uint256) {\\n        return assertions[assertionID].proposalTime;\\n    }\\n\\n    function getNumStakers(uint256 assertionID) external view returns (uint256) {\\n        return assertions[assertionID].numStakers;\\n    }\\n\\n    function isStaker(uint256 assertionID, address stakerAddress) external view returns (bool) {\\n        return assertionStates[assertionID].stakers[stakerAddress];\\n    }\\n\\n    function createAssertion(\\n        uint256 assertionID,\\n        bytes32 stateHash,\\n        uint256 inboxSize,\\n        uint256 parentID,\\n        uint256 deadline\\n    ) external rollupOnly {\\n        Assertion storage parentAssertion = assertions[parentID];\\n        AssertionState storage parentAssertionState = assertionStates[parentID];\\n        // Child assertions must have same inbox size\\n        uint256 parentChildInboxSize = parentAssertion.childInboxSize;\\n        if (parentChildInboxSize == 0) {\\n            parentAssertion.childInboxSize = inboxSize;\\n        } else {\\n            if (inboxSize != parentChildInboxSize) {\\n                revert(\\\"ChildInboxSizeMismatch\\\");\\n            }\\n        }\\n        if (parentAssertionState.childStateHashes[stateHash]) {\\n            revert(\\\"SiblingStateHashExists\\\");\\n        }\\n\\n        parentAssertionState.childStateHashes[stateHash] = true;\\n\\n        assertions[assertionID] = Assertion(\\n            stateHash,\\n            inboxSize,\\n            parentID,\\n            deadline,\\n            block.number, // proposal time\\n            0, // numStakers\\n            0 // childInboxSize\\n        );\\n    }\\n\\n    function stakeOnAssertion(uint256 assertionID, address stakerAddress) external rollupOnly {\\n        Assertion storage assertion = assertions[assertionID];\\n        assertionStates[assertionID].stakers[stakerAddress] = true;\\n        assertion.numStakers++;\\n    }\\n\\n    function deleteAssertion(uint256 assertionID) external rollupOnly {\\n        delete assertions[assertionID];\\n    }\\n\\n    function deleteAssertionForBatch(uint256 assertionID) external rollupOnly {\\n        bytes32 stateHash = assertions[assertionID].stateHash;\\n        uint256 parentID = assertions[assertionID].parent;\\n        delete assertions[assertionID];\\n        assertions[parentID].childInboxSize = 0;\\n        assertionStates[parentID].childStateHashes[stateHash] = false;\\n    }\\n}\\n\",\"keccak256\":\"0x41f3df4852c1706d878483cd898d3e2bbcb935880766231624cc101fe59e661c\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/IRollup.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Modifications Copyright 2022, Specular contributors\\n *\\n * This file was changed in accordance to Apache License, Version 2.0.\\n *\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AssertionMap.sol\\\";\\nimport {Lib_BVMCodec} from \\\"../../libraries/codec/Lib_BVMCodec.sol\\\";\\n\\ninterface IRollup {\\n    event AssertionCreated(\\n        uint256 assertionID, address asserterAddr, bytes32 vmHash, uint256 inboxSize\\n    );\\n\\n    event AssertionChallenged(uint256 assertionID, address challengeAddr);\\n\\n    event AssertionConfirmed(uint256 assertionID);\\n\\n    event AssertionRejected(uint256 assertionID);\\n\\n    event StakerStaked(address stakerAddr, uint256 assertionID);\\n\\n    /// @dev Thrown when address that have not staked any token calls a only-staked function\\n    error NotStaked();\\n\\n    /// @dev Thrown when the function is called with Insufficient Stake\\n    error InsufficientStake();\\n\\n    /// @dev Thrown when the caller is staked on unconfirmed assertion.\\n    error StakedOnUnconfirmedAssertion();\\n\\n    /// @dev Thrown when transfer fails\\n    error TransferFailed();\\n\\n    /// @dev Thrown when a staker tries to advance stake to invalid assertionId.\\n    error AssertionOutOfRange();\\n\\n    /// @dev Thrown when a staker tries to advance stake to non-child assertion\\n    error ParentAssertionUnstaked();\\n\\n    /// @dev Thrown when a sender tries to create assertion before the minimum assertion time period\\n    error MinimumAssertionPeriodNotPassed();\\n\\n    /// @dev Thrown when parent's statehash is not equal to the start state(or previous state)/\\n    error PreviousStateHash();\\n\\n    /// @dev Thrown when a sender tries to create assertion without any tx.\\n    error EmptyAssertion();\\n\\n    /// @dev Thrown when the requested assertion read past the end of current Inbox.\\n    error InboxReadLimitExceeded();\\n\\n    /// @dev Thrown when the challenge assertion Id is not ordered or in range.\\n    error WrongOrder();\\n\\n    /// @dev Thrown when the challenger tries to challenge an unproposed assertion\\n    error UnproposedAssertion();\\n\\n    /// @dev Thrown when the assertion is already resolved\\n    error AssertionAlreadyResolved();\\n\\n    /// @dev Thrown when there is no unresolved assertion\\n    error NoUnresolvedAssertion();\\n\\n    /// @dev Thrown when the challenge period has not passed\\n    error ChallengePeriodPending();\\n\\n    /// @dev Thrown when the challenger and defender didn't attest to sibling assertions\\n    error DifferentParent();\\n\\n    /// @dev Thrown when the assertion's parent is not the last confirmed assertion\\n    error InvalidParent();\\n\\n    /// @dev Thrown when the staker is not in a challenge\\n    error NotInChallenge();\\n\\n    /// @dev Thrown when the two stakers are in different challenge\\n    /// @param staker1Challenge challenge address of staker 1\\n    /// @param staker2Challenge challenge address of staker 2\\n    error InDifferentChallenge(address staker1Challenge, address staker2Challenge);\\n\\n    /// @dev Thrown when the staker is currently in Challenge\\n    error ChallengedStaker();\\n\\n    /// @dev Thrown when all the stakers are not staked\\n    error NotAllStaked();\\n\\n    /// @dev Thrown staker's assertion is descendant of firstUnresolved assertion\\n    error StakerStakedOnTarget();\\n\\n    /// @dev Thrown when there are staker's present on the assertion\\n    error StakersPresent();\\n\\n    /// @dev Thrown when there are zero stakers\\n    error NoStaker();\\n\\n    /// @dev Thrown when slot is not blank in initialize step\\n    error RedundantInitialized();\\n\\n    /// @dev Thrown when function is called with a zero address argument\\n    error ZeroAddress();\\n\\n    function assertions() external view returns (AssertionMap);\\n\\n    /**\\n     * @param addr User address.\\n     * @return True if address is staked, else False.\\n     */\\n    function isStaked(address addr) external view returns (bool);\\n\\n    /**\\n     * @return The current required stake amount.\\n     */\\n    function currentRequiredStake() external view returns (uint256);\\n\\n    /**\\n     * @return confirmedInboxSize size of inbox confirmed\\n     */\\n    function confirmedInboxSize() external view returns (uint256);\\n\\n    /**\\n     * @notice Deposits stake on staker's current assertion (or the last confirmed assertion if not currently staked).\\n     * @notice currently use MNT to stake; stakeAmount Token amount to deposit. Must be > than defined threshold if this is a new stake.\\n     */\\n     function stake(uint256 stakeAmount, address operator) external;\\n\\n    /**\\n     * @notice Withdraws stakeAmount from staker's stake by if assertion it is staked on is confirmed.\\n     * @param stakeAmount Token amount to withdraw. Must be <= sender's current stake minus the current required stake.\\n     */\\n    function unstake(uint256 stakeAmount) external;\\n\\n    /**\\n     * @notice Removes stakerAddress from the set of stakers and withdraws the full stake amount to stakerAddress.\\n     * This can be called by anyone since it is currently necessary to keep the chain progressing.\\n     * @param stakerAddress Address of staker for which to unstake.\\n     */\\n    function removeStake(address stakerAddress) external;\\n\\n    /**\\n     * @notice Advances msg.sender's existing sake to assertionID.\\n     * @param assertionID ID of assertion to advance stake to. Currently this must be a child of the current assertion.\\n     * TODO: generalize to arbitrary descendants.\\n     */\\n    function advanceStake(uint256 assertionID) external;\\n\\n    /**\\n     * @notice Withdraws all of msg.sender's withdrawable funds.\\n     */\\n    function withdraw() external;\\n\\n    /**\\n     * @notice Creates a new DA representing the rollup state after executing a block of transactions (sequenced in SequencerInbox).\\n     * Block is represented by all transactions in range [prevInboxSize, inboxSize]. The latest staked DA of the sender\\n     * is considered to be the predecessor. Moves sender stake onto the new DA.\\n     *\\n     * The new DA stores the hash of the parameters: vmHash\\n     *\\n     * @param vmHash New VM hash.\\n     * @param inboxSize Size of inbox corresponding to assertion (number of transactions).\\n     */\\n    function createAssertion(\\n        bytes32 vmHash,\\n        uint256 inboxSize\\n    ) external;\\n\\n    /**\\n     *\\n     * @notice create assertion with scc state batch\\n     *\\n     * @param vmHash New VM hash.\\n     * @param inboxSize Size of inbox corresponding to assertion (number of transactions).\\n     * @param _batch Batch of state roots.\\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\\n     * @param _signature tss group signature of state batches.\\n     */\\n    function createAssertionWithStateBatch(\\n        bytes32 vmHash,\\n        uint256 inboxSize,\\n        bytes32[] calldata _batch,\\n        uint256 _shouldStartAtElement,\\n        bytes calldata _signature\\n    ) external;\\n\\n\\n    /**\\n     * @notice Initiates a dispute between a defender and challenger on an unconfirmed DA.\\n     * @param players Defender (first) and challenger (second) addresses. Must be staked on DAs on different branches.\\n     * @param assertionIDs Assertion IDs of the players engaged in the challenge. The first ID should be the earlier-created and is the one being challenged.\\n     * @return Newly created challenge contract address.\\n     */\\n    function challengeAssertion(address[2] calldata players, uint256[2] calldata assertionIDs)\\n        external\\n        returns (address);\\n\\n    /**\\n     * @notice Confirms first unresolved assertion. Assertion is confirmed if and only if:\\n     * (1) there is at least one staker, and\\n     * (2) challenge period has passed, and\\n     * (3) predecessor has been confirmed, and\\n     * (4) all stakers are staked on the assertion.\\n     */\\n    function confirmFirstUnresolvedAssertion() external;\\n\\n    /**\\n     * @notice Rejects first unresolved assertion. Assertion is rejected if and only if:\\n     * (1) all of the following are true:\\n     * (a) challenge period has passed, and\\n     * (b) at least one staker exists, and\\n     * (c) no staker remains staked on the assertion (all have been destroyed).\\n     * OR\\n     * (2) predecessor has been rejected\\n     */\\n    function rejectFirstUnresolvedAssertion() external;\\n\\n    //* @param stakerAddress Address of a staker staked on a different branch to the first unresolved assertion.\\n    //* If the first unresolved assertion's parent is confirmed, this parameter is used to establish that a staker exists\\n    //* on a different branch of the assertion chain. This parameter is ignored when the parent of the first unresolved\\n    //* assertion is not the last confirmed assertion.\\n    function rejectLatestCreatedAssertionWithBatch(Lib_BVMCodec.ChainBatchHeader memory _batchHeader) external;\\n\\n    /**\\n     * @notice Completes ongoing challenge. Callback, called by a challenge contract.\\n     * @param winner Address of winning staker.\\n     * @param loser Address of losing staker.\\n     */\\n    function completeChallenge(address winner, address loser) external;\\n\\n    /**\\n     * Emit event to notify sequencers to roll back.\\n     * @param _shouldRollBack roll back to should start.\\n     * @param _shouldStartAtElement Index of the element at which this batch should start\\n     * @param _signature signature of rollback message\\n     */\\n    function rollbackL2Chain(uint256 _shouldRollBack, uint256 _shouldStartAtElement, bytes memory _signature) external;\\n}\\n\",\"keccak256\":\"0xfc50abc602c7256d5ca170cbcb7a1d2199cc9cd24c0b9e34749c98a9f3e8a36e\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/Rollup.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Modifications Copyright 2022, Specular contributors\\n *\\n * This file was changed in accordance to Apache License, Version 2.0.\\n *\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./challenge/Challenge.sol\\\";\\nimport \\\"./challenge/ChallengeLib.sol\\\";\\nimport \\\"./AssertionMap.sol\\\";\\nimport \\\"./IRollup.sol\\\";\\nimport \\\"./RollupLib.sol\\\";\\nimport \\\"./WhiteList.sol\\\";\\nimport \\\"./verifier/IVerifier.sol\\\";\\nimport {Lib_AddressResolver} from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\nimport {Lib_AddressManager} from \\\"../../libraries/resolver/Lib_AddressManager.sol\\\";\\nimport {Lib_BVMCodec} from \\\"../../libraries/codec/Lib_BVMCodec.sol\\\";\\n\\n\\nabstract contract RollupBase is IRollup, Initializable {\\n    // Config parameters\\n    uint256 public minimumAssertionPeriod; // number of L1 blocks\\n    uint256 public baseStakeAmount; // number of stake tokens\\n\\n    IERC20 public stakeToken;\\n    AssertionMap public override assertions;\\n    IVerifierEntry public verifier;\\n\\n    // slot place hold\\n    uint256[50] rollupBaseGap;\\n\\n    struct Staker {\\n        bool isStaked;\\n        uint256 amountStaked;\\n        uint256 assertionID; // latest staked assertion ID\\n        address operator; // operator\\n        address currentChallenge; // address(0) if none\\n    }\\n\\n    struct Zombie {\\n        address stakerAddress;\\n        uint256 lastAssertionID;\\n    }\\n\\n    struct ChallengeCtx {\\n        bool completed;\\n        address challengeAddress;\\n        address defenderAddress;\\n        address challengerAddress;\\n        uint256 defenderAssertionID;\\n        uint256 challengerAssertionID;\\n    }\\n}\\n\\ncontract Rollup is Lib_AddressResolver, RollupBase, Whitelist {\\n    modifier stakedOnly() {\\n        if (!isStaked(msg.sender)) {\\n            revert(\\\"NotStaked\\\");\\n        }\\n        _;\\n    }\\n\\n    modifier operatorOnly() {\\n        if (registers[msg.sender] == address(0)) {\\n            revert(\\\"NotOperator\\\");\\n        }\\n        _;\\n    }\\n\\n    // Assertion state\\n    uint256 public lastResolvedAssertionID;\\n    uint256 public lastConfirmedAssertionID;\\n    uint256 public lastCreatedAssertionID;\\n\\n    // Staking state\\n    uint256 public numStakers; // current total number of stakers\\n    mapping(address => Staker) public stakers; // mapping from staker addresses to corresponding stakers\\n    mapping(address => address) public registers; // register info for operator => staker\\n    mapping(address => uint256) public withdrawableFunds; // mapping from addresses to withdrawable funds (won in challenge)\\n    Zombie[] public zombies; // stores stakers that lost a challenge\\n    ChallengeCtx public challengeCtx;  // stores challenge context\\n    constructor() Lib_AddressResolver(address(0)) {\\n        _disableInitializers();\\n    }\\n\\n    function initialize(\\n        address _owner,\\n        address _verifier,\\n        address _stakeToken,\\n        address _libAddressManager,\\n        address _assertionMap,\\n        uint256 _minimumAssertionPeriod,\\n        uint256 _baseStakeAmount,\\n        bytes32 _initialVMhash,\\n        address[] calldata stakerWhitelists,\\n        address[] calldata operatorWhitelists\\n    ) public initializer {\\n        if (_owner == address(0) || _verifier == address(0)) {\\n            revert(\\\"ZeroAddress\\\");\\n        }\\n        owner = _owner;\\n        stakeToken = IERC20(_stakeToken);\\n        verifier = IVerifierEntry(_verifier);\\n\\n        if (address(libAddressManager) != address(0)) {\\n            revert(\\\"RedundantInitialized\\\");\\n        }\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n\\n        if (address(assertions) != address(0)) {\\n            revert(\\\"RedundantInitialized\\\");\\n        }\\n        assertions = AssertionMap(_assertionMap);\\n\\n        minimumAssertionPeriod = _minimumAssertionPeriod;\\n        baseStakeAmount = _baseStakeAmount;\\n\\n        assertions.setRollupAddress(address(this));\\n        lastResolvedAssertionID = 0;\\n        lastConfirmedAssertionID = 0;\\n        lastCreatedAssertionID = 0;\\n\\n        assertions.createAssertion(\\n            lastResolvedAssertionID, // assertionID\\n            _initialVMhash,\\n            0, // inboxSize (genesis)\\n            0, // parentID\\n            block.number // deadline (unchallengeable)\\n        );\\n\\n        addToStakerWhitelist(stakerWhitelists);\\n        addToOperatorWhitelist(operatorWhitelists);\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function isStaked(address addr) public view override returns (bool) {\\n        return stakers[addr].isStaked;\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function currentRequiredStake() public view override returns (uint256) {\\n        return baseStakeAmount;\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function confirmedInboxSize() public view override returns (uint256) {\\n        return assertions.getInboxSize(lastConfirmedAssertionID);\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function stake(uint256 stakeAmount, address operator) external override\\n        stakerWhitelistOnly(msg.sender)\\n        operatorWhitelistOnly(operator)\\n    {\\n        // send erc20 token to staking contract, need user approve first\\n        require(\\n            IERC20(stakeToken).transferFrom(msg.sender, address(this), stakeAmount),\\n            \\\"transfer erc20 token failed\\\"\\n        );\\n\\n        if (isStaked(msg.sender)) {\\n            require(\\n            stakers[msg.sender].operator == operator,\\n                \\\"staker => operator mapping not unique\\\"\\n            );\\n            stakers[msg.sender].amountStaked += stakeAmount;\\n        } else {\\n            require(registers[operator] == address(0), \\\"operator is occupied\\\");\\n\\n            if (stakeAmount < baseStakeAmount) {\\n                revert(\\\"InsufficientStake\\\");\\n            }\\n\\n            stakers[msg.sender] = Staker(true, stakeAmount, 0, operator, address(0));\\n            registers[operator] = msg.sender;\\n            numStakers++;\\n            stakeOnAssertion(msg.sender, lastConfirmedAssertionID);\\n        }\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function unstake(uint256 stakeAmount) external override {\\n        requireStaked(msg.sender);\\n        // Require that staker is staked on a confirmed assertion.\\n        Staker storage staker = stakers[msg.sender];\\n        if (staker.assertionID > lastConfirmedAssertionID) {\\n            revert(\\\"StakedOnUnconfirmedAssertion\\\");\\n        }\\n        if (stakeAmount > staker.amountStaked - currentRequiredStake()) {\\n            revert(\\\"InsufficientStake\\\");\\n        }\\n        staker.amountStaked -= stakeAmount;\\n        // send erc20 token to user\\n        require(\\n            IERC20(stakeToken).transfer(msg.sender, stakeAmount),\\n            \\\"transfer erc20 token failed\\\"\\n        );\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function removeStake(address stakerAddress) onlyOwner external override {\\n        requireStaked(stakerAddress);\\n        // Require that staker is staked on a confirmed assertion.\\n        Staker storage staker = stakers[stakerAddress];\\n        if (staker.assertionID > lastConfirmedAssertionID) {\\n            revert(\\\"StakedOnUnconfirmedAssertion\\\");\\n        }\\n        uint256 amountToSent = staker.amountStaked;\\n        deleteStaker(stakerAddress);\\n        // send erc20 token to user\\n        require(\\n            IERC20(stakeToken).transfer(stakerAddress, amountToSent),\\n            \\\"transfer erc20 token failed\\\"\\n        );\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function advanceStake(uint256 assertionID) external override operatorOnly {\\n        address stakerAddr = registers[msg.sender];\\n        Staker storage staker = stakers[stakerAddr];\\n        if (assertionID <= staker.assertionID || assertionID > lastCreatedAssertionID) {\\n            revert(\\\"AssertionOutOfRange\\\");\\n        }\\n        // TODO: allow arbitrary descendant of current staked assertionID, not just child.\\n        if (staker.assertionID != assertions.getParentID(assertionID)) {\\n            revert(\\\"ParentAssertionUnstaked\\\");\\n        }\\n        stakeOnAssertion(stakerAddr, assertionID);\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function withdraw() external override operatorOnly {\\n        uint256 withdrawableFund = withdrawableFunds[msg.sender];\\n        withdrawableFunds[msg.sender] = 0;\\n        require(\\n            IERC20(stakeToken).transfer(msg.sender, withdrawableFund),\\n            \\\"transfer erc20 token failed\\\"\\n        );\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function createAssertion(\\n        bytes32 vmHash,\\n        uint256 inboxSize\\n    ) public override operatorOnly {\\n        address stakerAddr = registers[msg.sender];\\n        require(stakers[stakerAddr].currentChallenge == address(0),\\\"can not create assertion when staker in challenge\\\");\\n        uint256 parentID = stakers[stakerAddr].assertionID;\\n        // Require that enough time has passed since the last assertion.\\n        if (block.number - assertions.getProposalTime(parentID) < minimumAssertionPeriod) {\\n            revert(\\\"MinimumAssertionPeriodNotPassed\\\");\\n        }\\n        // Require that the assertion at least includes one transaction\\n        if (inboxSize <= assertions.getInboxSize(parentID)) {\\n            revert(\\\"EmptyAssertion\\\");\\n        }\\n\\n        // Initialize assertion.\\n        lastCreatedAssertionID++;\\n        emit AssertionCreated(lastCreatedAssertionID, msg.sender, vmHash, inboxSize);\\n        assertions.createAssertion(\\n            lastCreatedAssertionID, vmHash, inboxSize, parentID, newAssertionDeadline()\\n        );\\n\\n        // Update stake.\\n        stakeOnAssertion(stakerAddr, lastCreatedAssertionID);\\n        // confirmed this assertion instantly\\n        lastResolvedAssertionID++;\\n        lastConfirmedAssertionID = lastResolvedAssertionID;\\n        emit AssertionConfirmed(lastResolvedAssertionID);\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function createAssertionWithStateBatch(\\n        bytes32 vmHash,\\n        uint256 inboxSize,\\n        bytes32[] calldata _batch,\\n        uint256 _shouldStartAtElement,\\n        bytes calldata _signature\\n        ) external override operatorOnly {\\n        // permissions only allow rollup proposer to submit assertion, only allow RollupContract to append new batch\\n        require(msg.sender == resolve(\\\"BVM_Rolluper\\\"), \\\"msg.sender is not rollup proposer, can't append batch\\\");\\n        // create assertion\\n        createAssertion(vmHash, inboxSize);\\n        // append state batch\\n        address scc = resolve(\\\"StateCommitmentChain\\\");\\n        (bool success, ) = scc.call(\\n            abi.encodeWithSignature(\\\"appendStateBatch(bytes32[],uint256,bytes)\\\", _batch, _shouldStartAtElement, _signature)\\n        );\\n        require(success, \\\"scc append state batch failed, revert all\\\");\\n    }\\n\\n    function challengeAssertion(address[2] calldata players, uint256[2] calldata assertionIDs)\\n        external\\n        override\\n        operatorOnly\\n        returns (address)\\n    {\\n        uint256 defenderAssertionID = assertionIDs[0];\\n        uint256 challengerAssertionID = assertionIDs[1];\\n        // Require IDs ordered and in-range.\\n        if (defenderAssertionID >= challengerAssertionID) {\\n            revert(\\\"WrongOrder\\\");\\n        }\\n        if (challengerAssertionID > lastCreatedAssertionID) {\\n            revert(\\\"UnproposedAssertion\\\");\\n        }\\n        if (lastConfirmedAssertionID >= defenderAssertionID) {\\n            revert(\\\"AssertionAlreadyResolved\\\");\\n        }\\n        // Require that players have attested to sibling assertions.\\n        uint256 parentID = assertions.getParentID(defenderAssertionID);\\n        if (parentID != assertions.getParentID(challengerAssertionID)) {\\n            revert(\\\"DifferentParent\\\");\\n        }\\n        // Require that neither player is currently engaged in a challenge.\\n        address defender = players[0];\\n        address challenger = players[1];\\n        require(defender != challenger, \\\"defender and challenge must not equal\\\");\\n        address defenderStaker = registers[defender];\\n        address challengerStaker = registers[challenger];\\n        requireUnchallengedStaker(defenderStaker);\\n        requireUnchallengedStaker(challengerStaker);\\n\\n        // TODO: Calculate upper limit for allowed node proposal time.\\n\\n        // Initialize challenge.\\n        Challenge challenge = new Challenge();\\n        address challengeAddr = address(challenge);\\n        stakers[challengerStaker].currentChallenge = challengeAddr;\\n        stakers[defenderStaker].currentChallenge = challengeAddr;\\n\\n        challengeCtx = ChallengeCtx(false,challengeAddr,defender,challenger,defenderAssertionID,challengerAssertionID);\\n        emit AssertionChallenged(defenderAssertionID, challengeAddr);\\n        uint256 inboxSize = assertions.getInboxSize(parentID);\\n        bytes32 parentStateHash = assertions.getStateHash(parentID);\\n        bytes32 defenderStateHash = assertions.getStateHash(defenderAssertionID);\\n        challenge.initialize(\\n            defender,\\n            challenger,\\n            verifier,\\n            address(this),\\n            inboxSize,\\n            parentStateHash,\\n            defenderStateHash\\n        );\\n        return challengeAddr;\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function confirmFirstUnresolvedAssertion() public override operatorOnly {\\n        if (lastResolvedAssertionID >= lastCreatedAssertionID) {\\n            revert(\\\"NoUnresolvedAssertion\\\");\\n        }\\n\\n        // (1) there is at least one staker, and\\n        if (numStakers <= 0) revert(\\\"NoStaker\\\");\\n\\n        uint256 lastUnresolvedID = lastResolvedAssertionID + 1;\\n\\n        // (2) challenge period has passed\\n        if (block.timestamp < assertions.getDeadline(lastUnresolvedID)) {\\n            revert(\\\"ChallengePeriodPending\\\");\\n        }\\n\\n        // (3) predecessor has been confirmed\\n        if (assertions.getParentID(lastUnresolvedID) != lastConfirmedAssertionID) {\\n            revert(\\\"InvalidParent\\\");\\n        }\\n\\n        // Remove old zombies\\n        // removeOldZombies();\\n\\n        // (4) all stakers are staked on the block.\\n        // if (assertions.getNumStakers(lastUnresolvedID) != numStakers) {\\n        //    revert(\\\"NotAllStaked\\\");\\n        // }\\n\\n        // there is no slashing mechanism currently,\\n        // we can not handle offline staker if we sum up zombies and numStakers,\\n        // in which case a offline validator can block confirmation progress.\\n        // if (assertions.getNumStakers(lastUnresolvedID) != countStakedZombies(lastUnresolvedID) + numStakers) {\\n        //    revert NotAllStaked();\\n        // }\\n\\n        // Confirm assertion.\\n        // assertions.deleteAssertion(lastConfirmedAssertionID);\\n        lastResolvedAssertionID++;\\n        lastConfirmedAssertionID = lastResolvedAssertionID;\\n        emit AssertionConfirmed(lastResolvedAssertionID);\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function rejectFirstUnresolvedAssertion() external override operatorOnly {\\n        if (lastResolvedAssertionID >= lastCreatedAssertionID) {\\n            revert(\\\"NoUnresolvedAssertion\\\");\\n        }\\n\\n        uint256 firstUnresolvedAssertionID = lastResolvedAssertionID + 1;\\n\\n        // First case - parent of first unresolved is last confirmed (`if` condition below). e.g.\\n        // [1] <- [3]           | valid chain ([1] is last confirmed, [3] is stakerAddress's unresolved assertion)\\n        //  ^---- [2]           | invalid chain ([2] is firstUnresolved)\\n        // Second case (trivial) - parent of first unresolved is not last confirmed. i.e.:\\n        //   parent is previous rejected, e.g.\\n        //   [1] <- [4]           | valid chain ([1] is last confirmed, [4] is stakerAddress's unresolved assertion)\\n        //   [2] <- [3]           | invalid chain ([3] is firstUnresolved)\\n        //   OR\\n        //   parent is previous confirmed, e.g.\\n        //   [1] <- [2] <- [4]    | valid chain ([2] is last confirmed, [4] is stakerAddress's unresolved assertion)\\n        //    ^---- [3]           | invalid chain ([3] is firstUnresolved)\\n        if (assertions.getParentID(firstUnresolvedAssertionID) == lastConfirmedAssertionID) {\\n            // 1a. challenge period has passed.\\n            if (block.timestamp < assertions.getDeadline(firstUnresolvedAssertionID)) {\\n                revert(\\\"ChallengePeriodPending\\\");\\n            }\\n            // 1b. at least one staker exists (on a sibling)\\n            // - stakerAddress is indeed a staker\\n            // requireStaked(stakerAddress);\\n            // - staker's assertion can't be a ancestor of firstUnresolved (because staker's assertion is also unresolved)\\n            // if (stakers[stakerAddress].assertionID < firstUnresolvedAssertionID) {\\n            //    revert(\\\"AssertionAlreadyResolved\\\");\\n            // }\\n            // - staker's assertion can't be a descendant of firstUnresolved (because staker has never staked on firstUnresolved)\\n            // if (assertions.isStaker(firstUnresolvedAssertionID, stakerAddress)) {\\n            //    revert(\\\"StakerStakedOnTarget\\\");\\n            // }\\n            // If a staker is staked on an assertion that is neither an ancestor nor a descendant of firstUnresolved, it must be a sibling, QED\\n\\n            // 1c. no staker is staked on this assertion\\n            // removeOldZombies();\\n            if (assertions.getNumStakers(firstUnresolvedAssertionID) != countStakedZombies(firstUnresolvedAssertionID))\\n            {\\n                revert(\\\"StakersPresent\\\");\\n            }\\n        }\\n\\n        // Reject assertion.\\n        lastResolvedAssertionID++;\\n        emit AssertionRejected(lastResolvedAssertionID);\\n        assertions.deleteAssertion(lastResolvedAssertionID);\\n    }\\n\\n/// @inheritdoc IRollup\\n    function rejectLatestCreatedAssertionWithBatch(Lib_BVMCodec.ChainBatchHeader memory _batchHeader) external override onlyOwner {\\n        address scc = resolve(\\\"StateCommitmentChain\\\");\\n\\n        // batch shift\\n        (, bytes memory data) = scc.call(\\n            abi.encodeWithSignature(\\\"getTotalBatches()\\\")\\n        );\\n        uint256 totalBatches = uint256(bytes32(data));\\n        require(totalBatches-_batchHeader.batchIndex == 1, \\\"delete batch with gap is not allowed\\\");\\n\\n        // Delete state batch\\n        (bool success, ) = scc.call(\\n            abi.encodeWithSignature(\\\"deleteStateBatch((uint256,bytes32,uint256,uint256,bytes,bytes))\\\", _batchHeader)\\n        );\\n        require(success, \\\"scc delete state batch failed, revert all\\\");\\n\\n        // Reject assertion.\\n        require(lastCreatedAssertionID >= lastResolvedAssertionID, \\\"delete assertion before last resolved in error\\\");\\n        emit AssertionRejected(lastCreatedAssertionID);\\n        assertions.deleteAssertionForBatch(lastCreatedAssertionID);\\n        lastCreatedAssertionID--;\\n        lastResolvedAssertionID--;\\n        lastConfirmedAssertionID--;\\n\\n        // Revert status\\n        for (uint i = 0; i < stakerslist.length; i++) {\\n            if (stakers[stakerslist[i]].assertionID > lastCreatedAssertionID) {\\n                stakers[stakerslist[i]].assertionID = lastCreatedAssertionID;\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function completeChallenge(address winner, address loser) external override operatorOnly {\\n        address winnerStaker = registers[winner];\\n        address loserStaker = registers[loser];\\n        requireStaked(loserStaker);\\n\\n        address challenge = getChallenge(winnerStaker, loserStaker);\\n        if (msg.sender != challenge) {\\n            revert(\\\"NotChallenge\\\");\\n        }\\n        uint256 amountWon;\\n        uint256 loserStake = stakers[loserStaker].amountStaked;\\n        // uint256 winnerStake = stakers[winnerStaker].amountStaked;\\n        if (loserStake > baseStakeAmount) {\\n            // If loser has a higher stake than the base stake amount, refund the difference.\\n            // Loser gets deleted anyways, so maybe unnecessary to set amountStaked.\\n            // stakers[loser].amountStaked = winnerStake;\\n            withdrawableFunds[loserStaker] += (loserStake - baseStakeAmount);\\n            amountWon = baseStakeAmount;\\n        } else {\\n            amountWon = loserStake;\\n        }\\n        // Reward the winner with winner amount\\n        stakers[winnerStaker].amountStaked += amountWon; // why +stake instead of +withdrawable?\\n        stakers[winnerStaker].currentChallenge = address(0);\\n        // Turning loser into zombie renders the loser's remaining stake inaccessible.\\n        uint256 assertionID = stakers[loserStaker].assertionID;\\n        deleteStaker(loserStaker);\\n        // Track as zombie so we can account for it during assertion resolution.\\n        zombies.push(Zombie(loserStaker, assertionID));\\n        challengeCtx.completed = true;\\n    }\\n\\n    /// @inheritdoc IRollup\\n    function rollbackL2Chain(uint256 _shouldRollBack, uint256 _shouldStartAtElement, bytes memory _signature) external override onlyOwner {\\n        address scc = resolve(\\\"StateCommitmentChain\\\");\\n\\n        // batch shift\\n        (bool success, ) = scc.call(\\n            abi.encodeWithSignature(\\\"rollBackL2Chain(uint256,uint256,bytes)\\\", _shouldRollBack, _shouldStartAtElement, _signature)\\n        );\\n        require(success, \\\"call rollBackL2Chain failed\\\");\\n    }\\n\\n    /**\\n     * @notice Updates staker and assertion metadata.\\n     * @param stakerAddress Address of existing staker.\\n     * @param assertionID ID of existing assertion to stake on.\\n     */\\n    function stakeOnAssertion(address stakerAddress, uint256 assertionID) private {\\n        stakers[stakerAddress].assertionID = assertionID;\\n        assertions.stakeOnAssertion(assertionID, stakerAddress);\\n        emit StakerStaked(stakerAddress, assertionID);\\n    }\\n\\n    /**\\n     * @notice Deletes the staker from global state. Does not touch assertion staker state.\\n     * @param stakerAddress Address of the staker to delete\\n     */\\n    function deleteStaker(address stakerAddress) private {\\n        numStakers--;\\n        address operator = stakers[stakerAddress].operator;\\n        delete stakers[stakerAddress];\\n        delete registers[operator];\\n    }\\n\\n    /**\\n     * @notice Checks to see whether the two stakers are in the same challenge\\n     * @param staker1Address Address of the first staker\\n     * @param staker2Address Address of the second staker\\n     * @return Address of the challenge that the two stakers are in\\n     */\\n    function getChallenge(address staker1Address, address staker2Address) private view returns (address) {\\n        Staker storage staker1 = stakers[staker1Address];\\n        Staker storage staker2 = stakers[staker2Address];\\n        address challenge = staker1.currentChallenge;\\n        if (challenge == address(0)) {\\n            revert(\\\"NotInChallenge\\\");\\n        }\\n        if (challenge != staker2.currentChallenge) {\\n            revert(\\\"InDifferentChallenge\\\");\\n        }\\n        return challenge;\\n    }\\n\\n    function newAssertionDeadline() private returns (uint256) {\\n        // TODO: account for prev assertion, gas\\n        // return block.number + confirmationPeriod;\\n        address scc = resolve(\\\"StateCommitmentChain\\\");\\n        (bool success, bytes memory data) = scc.call(\\n            abi.encodeWithSignature(\\\"FRAUD_PROOF_WINDOW()\\\")\\n        );\\n        require(success,\\\"call FRAUD_PROOF_WINDOW() failed\\\");\\n        uint256 confirmationWindow = uint256(bytes32(data));\\n        return block.timestamp + confirmationWindow;\\n    }\\n\\n    // *****************\\n    // zombie processing\\n    // *****************\\n\\n    function removeOldZombies() external operatorOnly {\\n        delete zombies;\\n    }\\n    /**\\n     * @notice Removes any zombies whose latest stake is earlier than the first unresolved assertion.\\n     * @dev Uses pop() instead of delete to prevent gaps, although order is not preserved\\n     */\\n    // function removeOldZombies() private {\\n    // }\\n\\n    /**\\n     * @notice Counts the number of zombies staked on an assertion.\\n     * @dev O(n), where n is # of zombies (but is expected to be small).\\n     * This function could be uncallable if there are too many zombies. However,\\n     * removeOldZombies() can be used to remove any zombies that exist so that this\\n     * will then be callable.\\n     * @param assertionID The assertion on which to count staked zombies\\n     * @return The number of zombies staked on the assertion\\n     */\\n    function countStakedZombies(uint256 assertionID) private view returns (uint256) {\\n        uint256 numStakedZombies = 0;\\n        for (uint256 i = 0; i < zombies.length; i++) {\\n            if (assertions.isStaker(assertionID, zombies[i].stakerAddress)) {\\n                numStakedZombies++;\\n            }\\n        }\\n        return numStakedZombies;\\n    }\\n\\n    // ************\\n    // requirements\\n    // ************\\n\\n    function requireStaked(address stakerAddress) private view {\\n        if (!isStaked(stakerAddress)) {\\n            revert(\\\"NotStaked\\\");\\n        }\\n    }\\n\\n    function requireUnchallengedStaker(address stakerAddress) private view {\\n        requireStaked(stakerAddress);\\n        if (stakers[stakerAddress].currentChallenge != address(0)) {\\n            revert(\\\"ChallengedStaker\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1fd9faf19c35de808c474e07bf55ea8d827cd12606e9b8a4c5c6b447483e46cb\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/RollupLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Modifications Copyright 2022, Specular contributors\\n *\\n * This file was changed in accordance to Apache License, Version 2.0.\\n *\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./challenge/ChallengeLib.sol\\\";\\n\\n// TODO: move into ChallengeLib.\\nlibrary RollupLib {\\n    struct ExecutionState {\\n        bytes32 vmHash;\\n    }\\n\\n    /**\\n     * @notice Computes the hash of `execState`.\\n     */\\n    function stateHash(ExecutionState memory execState) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(execState.vmHash));\\n    }\\n}\\n\",\"keccak256\":\"0xcb44afd1dcd516b69ff60a723e800da57b7b7662df3d9e2005d458782e479987\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/WhiteList.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\nabstract contract Whitelist {\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier stakerWhitelistOnly(address _checkAddress) {\\n        require(stakerslist[stakerWhitelist[_checkAddress]] == _checkAddress, \\\"NOT_IN_STAKER_WHITELIST\\\");\\n        _;\\n    }\\n\\n    modifier operatorWhitelistOnly(address _checkAddress) {\\n        require(operatorslist[operatorWhitelist[_checkAddress]] == _checkAddress, \\\"NOT_IN_OPERATOR_WHITELIST\\\");\\n        _;\\n    }\\n\\n    address public owner;\\n    mapping(address => uint256) public stakerWhitelist;\\n    address[] public stakerslist;\\n    mapping(address => uint256) public operatorWhitelist;\\n    address[] public operatorslist;\\n\\n    // slot place hold\\n    uint256[50] whitelistGap;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @notice Add to staker whitelist\\n     */\\n    function addToStakerWhitelist(address[] calldata toAddAddresses) public onlyOwner {\\n        uint256 lens = stakerslist.length;\\n        for (uint i = 0; i < toAddAddresses.length; i++) {\\n            stakerWhitelist[toAddAddresses[i]] = lens+i;\\n            stakerslist.push(toAddAddresses[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove from whitelist\\n     */\\n    function removeFromStakerWhitelist(address[] calldata toRemoveAddresses) public onlyOwner {\\n        for (uint i = 0; i < toRemoveAddresses.length; i++) {\\n            uint256 index = stakerWhitelist[toRemoveAddresses[i]];\\n            stakerWhitelist[stakerslist[stakerslist.length-1]] = index;\\n            stakerslist[index] = stakerslist[stakerslist.length-1];\\n            stakerslist.pop();\\n            delete stakerWhitelist[toRemoveAddresses[i]];\\n        }\\n    }\\n\\n    /**\\n * @notice Add to whitelist\\n     */\\n    function addToOperatorWhitelist(address[] calldata toAddAddresses) public onlyOwner {\\n        uint256 lens = operatorslist.length;\\n        for (uint i = 0; i < toAddAddresses.length; i++) {\\n            operatorWhitelist[toAddAddresses[i]] = lens+i;\\n            operatorslist.push(toAddAddresses[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove from whitelist\\n     */\\n    function removeFromOperatorWhitelist(address[] calldata toRemoveAddresses) public onlyOwner {\\n        for (uint i = 0; i < toRemoveAddresses.length; i++) {\\n            uint256 index = operatorWhitelist[toRemoveAddresses[i]];\\n            operatorWhitelist[operatorslist[operatorslist.length-1]] = index;\\n            operatorslist[index] = operatorslist[operatorslist.length-1];\\n            operatorslist.pop();\\n            delete operatorWhitelist[toRemoveAddresses[i]];\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x403cbbd26a8adb09f4e60f9e9c5786e78b72cf470bfecd0b96014bd66e595cd9\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/challenge/Challenge.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Modifications Copyright 2022, Specular contributors\\n *\\n * This file was changed in accordance to Apache License, Version 2.0.\\n *\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IChallenge.sol\\\";\\nimport \\\"./ChallengeLib.sol\\\";\\nimport \\\"../IRollup.sol\\\";\\n\\ncontract Challenge is IChallenge {\\n    struct BisectedStore {\\n        bytes32 startState;\\n        bytes32 midState;\\n        bytes32 endState;\\n        uint256 blockNum;\\n        uint256 blockTime;\\n        uint256 challengedSegmentStart;\\n        uint256 challengedSegmentLength;\\n    }\\n\\n    enum Turn {\\n        NoChallenge,\\n        Challenger,\\n        Defender\\n    }\\n\\n    // Error codes\\n\\n    // Can only initialize once\\n    string private constant CHAL_INIT_STATE = \\\"CHAL_INIT_STATE\\\";\\n    // deadline expired\\n    string private constant BIS_DEADLINE = \\\"BIS_DEADLINE\\\";\\n    // Only original asserter can continue bisect\\n    string private constant BIS_SENDER = \\\"BIS_SENDER\\\";\\n    // Incorrect previous state\\n    string private constant BIS_PREV = \\\"BIS_PREV\\\";\\n    // Can't timeout before deadline\\n    string private constant TIMEOUT_DEADLINE = \\\"TIMEOUT_DEADLINE\\\";\\n\\n    bytes32 private constant UNREACHABLE_ASSERTION = bytes32(uint256(0));\\n\\n    uint256 private constant MAX_BISECTION_DEGREE = 2;\\n\\n    // Other contracts\\n    address internal resultReceiver;\\n    IVerifierEntry internal verifier;\\n\\n    // Challenge state\\n    address public defender;\\n    address public challenger;\\n    uint256 public lastMoveBlockTime;\\n    uint256 public defenderTimeLeft;\\n    uint256 public challengerTimeLeft;\\n\\n    Turn public turn;\\n    // See `ChallengeLib.computeBisectionHash` for the format of this commitment.\\n    bytes32 public bisectionHash;\\n    bytes32[3] public prevBisection;\\n\\n    // Initial state used to initialize bisectionHash (write-once).\\n    bytes32 private startStateHash;\\n    bytes32 private endStateHash;\\n\\n    address public winner;\\n\\n    bool public rollback;\\n    uint256 public startInboxSize;\\n\\n    BisectedStore public currentBisected;\\n\\n    /**\\n     * @notice Pre-condition: `msg.sender` is correct and still has time remaining.\\n     * Post-condition: `turn` changes and `lastMoveBlock` set to current `block.number`.\\n     */\\n    modifier onlyOnTurn() {\\n        require(msg.sender == currentResponder(), BIS_SENDER);\\n        require(block.timestamp - lastMoveBlockTime <= currentResponderTimeLeft(), BIS_DEADLINE);\\n\\n        _;\\n\\n        if (turn == Turn.Challenger) {\\n            challengerTimeLeft = challengerTimeLeft - (block.timestamp- lastMoveBlockTime);\\n            turn = Turn.Defender;\\n        } else if (turn == Turn.Defender) {\\n            defenderTimeLeft = defenderTimeLeft - (block.timestamp - lastMoveBlockTime);\\n            turn = Turn.Challenger;\\n        }\\n        lastMoveBlockTime = block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Ensures challenge has been initialized.\\n     */\\n    modifier postInitialization() {\\n        require(bisectionHash != 0, \\\"NOT_INITIALIZED\\\");\\n        _;\\n    }\\n\\n    modifier onlyDefender(){\\n        require(defender != address(0),\\\"Defender not set\\\");\\n        require(msg.sender==defender,\\\"Caller not defender\\\");\\n        _;\\n    }\\n\\n    function initialize(\\n        address _defender,\\n        address _challenger,\\n        IVerifierEntry _verifier,\\n        address _resultReceiver,\\n        uint256 _startInboxSize,\\n        bytes32 _startStateHash,\\n        bytes32 _endStateHash\\n    ) external override {\\n        require(turn == Turn.NoChallenge, CHAL_INIT_STATE);\\n        require(_defender != address(0) && _challenger != address(0) && _resultReceiver != address(0), \\\"ZERO_ADDRESS\\\");\\n        defender = _defender;\\n        challenger = _challenger;\\n        verifier = _verifier;\\n        resultReceiver = _resultReceiver;\\n        startStateHash = _startStateHash;\\n        endStateHash = _endStateHash;\\n\\n        turn = Turn.Defender;\\n        lastMoveBlockTime = block.timestamp;\\n        // TODO(ujval): initialize timeout\\n        defenderTimeLeft = 150;\\n        challengerTimeLeft = 150;\\n        prevBisection[0] = _startStateHash;\\n        prevBisection[1] = bytes32(0);\\n        prevBisection[2] = _endStateHash;\\n\\n        startInboxSize = _startInboxSize;\\n    }\\n\\n    function initializeChallengeLength(bytes32 checkStateHash, uint256 _numSteps) external override onlyOnTurn {\\n        require(bisectionHash == 0, CHAL_INIT_STATE);\\n        require(_numSteps > 0, \\\"INVALID_NUM_STEPS\\\");\\n        bisectionHash = ChallengeLib.computeBisectionHash(0, _numSteps);\\n        // TODO: consider emitting a different event?\\n        currentBisected = BisectedStore(startStateHash, checkStateHash, endStateHash, block.number, block.timestamp, 0, _numSteps);\\n        emit Bisected(startStateHash, checkStateHash, endStateHash, block.number, block.timestamp, 0, _numSteps);\\n    }\\n\\n    function bisectExecution(\\n        bytes32[3] calldata bisection,\\n        uint256 challengedSegmentIndex,\\n        uint256 challengedSegmentStart,\\n        uint256 challengedSegmentLength,\\n        uint256 prevChallengedSegmentStart,\\n        uint256 prevChallengedSegmentLength\\n    ) external override onlyOnTurn postInitialization {\\n        // Verify provided prev bisection.\\n        bytes32 prevHash = ChallengeLib.computeBisectionHash(prevChallengedSegmentStart, prevChallengedSegmentLength);\\n        require(prevHash == bisectionHash, BIS_PREV);\\n\\n        // Require agreed upon start state hash and disagreed upon end state hash.\\n        if (prevBisection[1] != bytes32(0)) {\\n            require(bisection[0] == prevBisection[0] || bisection[0] == prevBisection[1], \\\"AMBIGUOUS_START\\\");\\n        }\\n        require(bisection[2] != prevBisection[2], \\\"INVALID_END\\\");\\n\\n        // Compute segment start/length.\\n        require(challengedSegmentLength > 0, \\\"TOO_SHORT\\\");\\n\\n        // Compute new challenge state.\\n        prevBisection[0] = bisection[0];\\n        prevBisection[1] = bisection[1];\\n        prevBisection[2] = bisection[2];\\n        bisectionHash = ChallengeLib.computeBisectionHash(challengedSegmentStart, challengedSegmentLength);\\n        currentBisected = BisectedStore(bisection[0], bisection[1], bisection[2], block.number, block.timestamp, challengedSegmentStart, challengedSegmentLength);\\n        emit Bisected(bisection[0], bisection[1], bisection[2], block.number, block.timestamp, challengedSegmentStart, challengedSegmentLength);\\n    }\\n\\n    function verifyOneStepProof(\\n        VerificationContext.Context calldata ctx,\\n        uint8 verifyType,\\n        bytes calldata proof,\\n        uint256 challengedStepIndex,\\n        uint256 prevChallengedSegmentStart,\\n        uint256 prevChallengedSegmentLength\\n    ) external override onlyOnTurn {\\n         // Verify provided prev bisection.\\n         bytes32 prevHash =\\n            ChallengeLib.computeBisectionHash(prevChallengedSegmentStart, prevChallengedSegmentLength);\\n         require(prevHash == bisectionHash, BIS_PREV);\\n         // require(challengedStepIndex > 0 && challengedStepIndex < prevBisection.length, \\\"INVALID_INDEX\\\");\\n         // Require that this is the last round.\\n         require(prevChallengedSegmentLength / MAX_BISECTION_DEGREE <= 1, \\\"BISECTION_INCOMPLETE\\\");\\n\\n         // verify OSP\\n         // IVerificationContext ctx = <get ctx from sequenced txs>;\\n\\n         bytes32 nextStateHash = verifier.verifyOneStepProof(\\n             ctx,\\n             verifyType,\\n             prevBisection[challengedStepIndex-1],\\n             proof\\n         );\\n         if (nextStateHash == prevBisection[challengedStepIndex]) {\\n             // osp verified, current win\\n             _currentWin(CompletionReason.OSP_VERIFIED);\\n         } else {\\n             _currentLose(CompletionReason.OSP_VERIFIED);\\n         }\\n    }\\n\\n    function setRollback() public {\\n        if (rollback) {\\n            revert(\\\"ALREADY_SET_ROLLBACK\\\");\\n        }\\n        rollback = true;\\n    }\\n\\n    function timeout() external override {\\n        require(block.timestamp - lastMoveBlockTime > currentResponderTimeLeft(), TIMEOUT_DEADLINE);\\n        if (turn == Turn.Defender) {\\n            _challengerWin(CompletionReason.TIMEOUT);\\n        } else {\\n            _asserterWin(CompletionReason.TIMEOUT);\\n        }\\n    }\\n\\n    function currentResponder() public view override returns (address) {\\n        if (turn == Turn.Defender) {\\n            return defender;\\n        } else if (turn == Turn.Challenger) {\\n            return challenger;\\n        } else {\\n            revert(\\\"NO_TURN\\\");\\n        }\\n    }\\n\\n    function currentResponderTimeLeft() public view override returns (uint256) {\\n        if (turn == Turn.Defender) {\\n            return defenderTimeLeft;\\n        } else if (turn == Turn.Challenger) {\\n            return challengerTimeLeft;\\n        } else {\\n            revert(\\\"NO_TURN\\\");\\n        }\\n    }\\n\\n    function _currentWin(CompletionReason reason) private {\\n        if (turn == Turn.Defender) {\\n            _asserterWin(reason);\\n        } else {\\n            winner = challenger;\\n            _challengerWin(reason);\\n        }\\n    }\\n\\n    function _currentLose(CompletionReason reason) private {\\n        if (turn == Turn.Defender) {\\n            _challengerWin(reason);\\n        } else {\\n            _asserterWin(reason);\\n        }\\n    }\\n\\n    function _asserterWin(CompletionReason reason) private {\\n        winner = defender;\\n        emit ChallengeCompleted(defender, challenger, reason);\\n    }\\n\\n    function _challengerWin(CompletionReason reason) private {\\n        winner = challenger;\\n        emit ChallengeCompleted(challenger, defender, reason);\\n    }\\n\\n    function completeChallenge(bool result) external onlyDefender{\\n        require(winner != address(0),\\\"Do not have winner\\\");\\n\\n        if (winner == challenger) {\\n            if (result) {\\n                IRollup(resultReceiver).completeChallenge(challenger, defender);\\n                return;\\n            }\\n            winner = defender;\\n        }\\n        IRollup(resultReceiver).completeChallenge(defender, challenger);\\n    }\\n}\\n\",\"keccak256\":\"0xd6a65372226b1002e0a29de6e6cdc422539407afd0d7740e738b6fa0bec173ef\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/challenge/ChallengeLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Modifications Copyright 2022, Specular contributors\\n *\\n * This file was changed in accordance to Apache License, Version 2.0.\\n *\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ChallengeLib {\\n    /**\\n     * @notice Computes the initial bisection hash.\\n     * @param numSteps Number of steps from the end of `startState` to the end of `endState`.\\n     */\\n    function initialBisectionHash(uint256 numSteps)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return ChallengeLib.computeBisectionHash(0, numSteps);\\n    }\\n\\n    /**\\n     * @notice Computes H(bisection || segmentStart || segmentLength)\\n     * @param challengedSegmentStart The number of steps preceding `bisection[1]`, relative to the assertion being challenged.\\n     * @param challengedSegmentLength Length of bisected segment (in steps), from the start of bisection[1] to the end of bisection[-1].\\n     */\\n    function computeBisectionHash(\\n        uint256 challengedSegmentStart,\\n        uint256 challengedSegmentLength\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(challengedSegmentStart, challengedSegmentLength));\\n    }\\n\\n    /**\\n     * @notice Returns length of first segment in a bisection.\\n     */\\n    function firstSegmentLength(uint256 length, uint256 bisectionDegree) internal pure returns (uint256) {\\n        return length / bisectionDegree + length % bisectionDegree;\\n    }\\n\\n    /**\\n     * @notice Returns length of a segment (after first) in a bisection.\\n     */\\n    function otherSegmentLength(uint256 length, uint256 bisectionDegree) internal pure returns (uint256) {\\n        return length / bisectionDegree;\\n    }\\n}\\n\",\"keccak256\":\"0x10247ecdac6c56eb5b697e19b54536bdc98a214c77fd2f9cfd054fc546de35e5\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/challenge/IChallenge.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Modifications Copyright 2022, Specular contributors\\n *\\n * This file was changed in accordance to Apache License, Version 2.0.\\n *\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../verifier/IVerifierEntry.sol\\\";\\n\\n/**\\n * @notice Protocol execution:\\n * `initialize` (challenger, via Rollup) ->\\n * `initializeChallengeLength` (defender) ->\\n * `bisectExecution` (challenger, defender -- alternating) ->\\n * `verifyOneStepProof`\\n */\\ninterface IChallenge {\\n    enum CompletionReason {\\n        OSP_VERIFIED, // OSP verified by winner.\\n        TIMEOUT // Loser timed out before completing their round.\\n    }\\n\\n    event ChallengeCompleted(address winner, address loser, CompletionReason reason);\\n\\n    event Bisected(bytes32 startState, bytes32 midState, bytes32 endState, uint256 blockNum, uint256 blockTime, uint256 challengedSegmentStart, uint256 challengedSegmentLength);\\n\\n    /**\\n     * @notice Initializes contract.\\n     * @param _defender Defending party.\\n     * @param _challenger Challenging party. Challenger starts.\\n     * @param _verifier Address of the verifier contract.\\n     * @param _resultReceiver Address of contract that will receive the outcome (via callback `completeChallenge`).\\n     * @param _startStateHash Bisection root being challenged.\\n     * @param _endStateHash Bisection root being challenged.\\n     */\\n    function initialize(\\n        address _defender,\\n        address _challenger,\\n        IVerifierEntry _verifier,\\n        address _resultReceiver,\\n        uint256 _startInboxSize,\\n        bytes32 _startStateHash,\\n        bytes32 _endStateHash\\n    ) external;\\n\\n    /**\\n     * @notice Initializes the length of the challenge. Must be called by defender before bisection rounds begin.\\n     * @param _numSteps Number of steps executed from the start of the assertion to its end.\\n     * If this parameter is incorrect, the defender will be slashed (assuming successful execution of the protocol by the challenger).\\n     */\\n    function initializeChallengeLength(bytes32 checkStateHash, uint256 _numSteps) external;\\n\\n    /**\\n     * @notice Bisects a segment. The challenged segment is defined by: {`challengedSegmentStart`, `challengedSegmentLength`, `bisection[0]`, `oldEndHash`}\\n     * @param bisection Bisection of challenged segment. Each element is a state hash (see `ChallengeLib.stateHash`).\\n     * The first element is the last agreed upon state hash. Must be of length MAX_BISECTION_LENGTH for all rounds except the last.\\n     * In the last round, the bisection segments must be single steps.\\n     * @param challengedSegmentIndex Index into `prevBisection`. Must be greater than 0 (since the first is agreed upon).\\n     * @param challengedSegmentStart Offset of the segment challenged in the preceding round (in steps).\\n     * @param challengedSegmentLength Length of the segment challenged in the preceding round (in steps).\\n     * @param prevChallengedSegmentStart Offset of the segment challenged in the preceding round (in steps).\\n     * Note: this is relative to the assertion being challenged (i.e. always between 0 and the initial `numSteps`).\\n     * @param prevChallengedSegmentLength Length of the segment challenged in the preceding round (in steps).\\n     */\\n    function bisectExecution(\\n        bytes32[3] calldata bisection,\\n        uint256 challengedSegmentIndex,\\n        uint256 challengedSegmentStart,\\n        uint256 challengedSegmentLength,\\n        uint256 prevChallengedSegmentStart,\\n        uint256 prevChallengedSegmentLength\\n    ) external;\\n\\n    /**\\n     * @notice Verifies one step proof and completes challenge protocol.\\n     * @param ctx execution context.\\n     * @param verifyType Index into `prevBisection`. Must be greater than 0 (since the first is agreed upon).\\n     * @param proof one step proof.\\n     * @param prevChallengedSegmentStart Offset of the segment challenged in the preceding round (in steps).\\n     * Note: this is relative to the assertion being challenged (i.e. always between 0 and the initial `numSteps`).\\n     * @param prevChallengedSegmentLength Length of the segment challenged in the preceding round (in steps).\\n     */\\n    function verifyOneStepProof(\\n        VerificationContext.Context calldata ctx,\\n        uint8 verifyType,\\n        bytes calldata proof,\\n        uint256 challengedStepIndex,\\n        uint256 prevChallengedSegmentStart,\\n        uint256 prevChallengedSegmentLength\\n    ) external;\\n\\n    function setRollback() external;\\n\\n    /**\\n     * @notice Triggers completion of challenge protocol if a responder timed out.\\n     */\\n    function timeout() external;\\n\\n    function currentResponder() external view returns (address);\\n\\n    function currentResponderTimeLeft() external view returns (uint256);\\n\\n    function completeChallenge(bool) external;\\n}\\n\",\"keccak256\":\"0xc999c12bf3e2042eca1ed78d45616a95db3dd7e49d78224bbb08d8da3bbbf3da\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/libraries/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n * @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for { let cc := add(_postBytes, 0x20) } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } { mstore(mc, mload(cc)) }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } { sstore(sc, mload(mc)) }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } { sstore(sc, mload(mc)) }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } { mstore(mc, mload(cc)) }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toBytes32Pad(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        bytes32 result;\\n\\n        assembly {\\n            result := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        if (_bytes.length < _start + 32) {\\n            uint256 pad = 32 + _start - _bytes.length;\\n            result = result >> pad << pad;\\n        }\\n\\n        return result;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for { let cc := add(_postBytes, 0x20) }\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0x35162cc8fa7ac784dd613242330c03110274f10e03f2e87f3fe4e48067954813\",\"license\":\"Unlicense\"},\"contracts/L1/fraud-proof/libraries/DeserializationLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BytesLib.sol\\\";\\n\\nlibrary DeserializationLib {\\n    function deserializeAddress(bytes memory data, uint256 startOffset) internal pure returns (uint256, address) {\\n        return (startOffset + 20, BytesLib.toAddress(data, startOffset));\\n    }\\n\\n    function deserializeUint256(bytes memory data, uint256 startOffset) internal pure returns (uint256, uint256) {\\n        require(data.length >= startOffset && data.length - startOffset >= 32, \\\"too short\\\");\\n        return (startOffset + 32, BytesLib.toUint256(data, startOffset));\\n    }\\n\\n    function deserializeBytes32(bytes memory data, uint256 startOffset) internal pure returns (uint256, bytes32) {\\n        require(data.length >= startOffset && data.length - startOffset >= 32, \\\"too short\\\");\\n        return (startOffset + 32, BytesLib.toBytes32(data, startOffset));\\n    }\\n}\\n\",\"keccak256\":\"0x2f3dd8e98a3d8c86d628d345254ee19111d0c4c61ecc4843e78cb1f57be66791\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/libraries/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Thrown when unauthorized (!rollup) address calls an only-rollup function\\n/// @param sender Address of the caller\\n/// @param rollup The rollup address authorized to call this function\\nerror NotRollup(address sender, address rollup);\\n\\n/// @dev Thrown when unauthorized (!challenge) address calls an only-challenge function\\n/// @param sender Address of the caller\\n/// @param challenge The challenge address authorized to call this function\\nerror NotChallenge(address sender, address challenge);\\n\\n/// @dev Thrown when unauthorized (!sequencer) address calls an only-sequencer function\\n/// @param sender Address of the caller\\n/// @param sequencer The sequencer address authorized to call this function\\nerror NotSequencer(address sender, address sequencer);\\n\\n/// @dev Thrown when function is called with a zero address argument\\nerror ZeroAddress();\\n\\n/// @dev Thrown when function is called with a zero address argument\\nerror RedundantInitialized();\\n\",\"keccak256\":\"0x291dce1c6076142cc427721f86cbabad6438166ed85c5b5c02fb24ec3f943c12\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/libraries/MerkleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary MerkleLib {\\n    // Hashes a and b in the order they are passed\\n    function hash_node(bytes32 a, bytes32 b) internal pure returns (bytes32 hash) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            hash := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    // Hashes a and b in order define by boolean\\n    function hash_pair(bytes32 a, bytes32 b, bool order) internal pure returns (bytes32 hash) {\\n        hash = order ? hash_node(a, b) : hash_node(b, a);\\n    }\\n\\n    // Counts number of set bits (1's) in 32-bit unsigned integer\\n    function bit_count_32(uint32 n) internal pure returns (uint32) {\\n        n = n - ((n >> 1) & 0x55555555);\\n        n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\\n\\n        return (((n + (n >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\\n    }\\n\\n    // Round 32-bit unsigned integer up to the nearest power of 2\\n    function round_up_to_power_of_2(uint32 n) internal pure returns (uint32) {\\n        if (bit_count_32(n) == 1) return n;\\n\\n        n |= n >> 1;\\n        n |= n >> 2;\\n        n |= n >> 4;\\n        n |= n >> 8;\\n        n |= n >> 16;\\n\\n        return n + 1;\\n    }\\n\\n    // Get the Element Merkle Root for a tree with just a single bytes32 element in memory\\n    function get_root_from_one(bytes32 element) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(bytes1(0), element));\\n    }\\n\\n    // Get nodes (parent of leafs) from bytes32 elements in memory\\n    function get_nodes_from_elements(bytes32[] memory elements) internal pure returns (bytes32[] memory nodes) {\\n        uint256 element_count = elements.length;\\n        uint256 node_count = (element_count >> 1) + (element_count & 1);\\n        nodes = new bytes32[](node_count);\\n        uint256 write_index;\\n        uint256 left_index;\\n\\n        while (write_index < node_count) {\\n            left_index = write_index << 1;\\n\\n            if (left_index == element_count - 1) {\\n                nodes[write_index] = keccak256(abi.encodePacked(bytes1(0), elements[left_index]));\\n                break;\\n            }\\n\\n            nodes[write_index++] = hash_node(\\n                keccak256(abi.encodePacked(bytes1(0), elements[left_index])),\\n                keccak256(abi.encodePacked(bytes1(0), elements[left_index + 1]))\\n            );\\n        }\\n    }\\n\\n    // Get the Element Merkle Root given nodes (parent of leafs)\\n    function get_root_from_nodes(bytes32[] memory nodes) internal pure returns (bytes32) {\\n        uint256 node_count = nodes.length;\\n        uint256 write_index;\\n        uint256 left_index;\\n\\n        while (node_count > 1) {\\n            left_index = write_index << 1;\\n\\n            if (left_index == node_count - 1) {\\n                nodes[write_index] = nodes[left_index];\\n                write_index = 0;\\n                node_count = (node_count >> 1) + (node_count & 1);\\n                continue;\\n            }\\n\\n            if (left_index >= node_count) {\\n                write_index = 0;\\n                node_count = (node_count >> 1) + (node_count & 1);\\n                continue;\\n            }\\n\\n            nodes[write_index++] = hash_node(nodes[left_index], nodes[left_index + 1]);\\n        }\\n\\n        return nodes[0];\\n    }\\n\\n    // Get the Element Merkle Root for a tree with several bytes32 elements in memory\\n    function get_root_from_many(bytes32[] memory elements) internal pure returns (bytes32) {\\n        return get_root_from_nodes(get_nodes_from_elements(elements));\\n    }\\n\\n    // Get the original Element Merkle Root, given a Size Proof\\n    function get_root_from_size_proof(uint256 element_count, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        uint256 proof_index = bit_count_32(uint32(element_count)) - 1;\\n        hash = proof[proof_index];\\n\\n        while (proof_index > 0) {\\n            hash = hash_node(proof[--proof_index], hash);\\n        }\\n    }\\n\\n    // Get the original Element Merkle Root, given an index, a leaf, and a Single Proof\\n    function get_root_from_leaf_and_single_proof(uint256 index, bytes32 leaf, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        uint256 proof_index = proof.length - 1;\\n        uint256 upper_bound = uint256(proof[0]) - 1;\\n\\n        while (proof_index > 0) {\\n            if (index != upper_bound || (index & 1 == 1)) {\\n                leaf = (index & 1 == 1) ? hash_node(proof[proof_index], leaf) : hash_node(leaf, proof[proof_index]);\\n                proof_index -= 1;\\n            }\\n\\n            index >>= 1;\\n            upper_bound >>= 1;\\n        }\\n\\n        return leaf;\\n    }\\n\\n    // Get the original Element Merkle Root, given an index, a bytes32 element, and a Single Proof\\n    function get_root_from_single_proof(uint256 index, bytes32 element, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        hash = keccak256(abi.encodePacked(bytes1(0), element));\\n        hash = get_root_from_leaf_and_single_proof(index, hash, proof);\\n    }\\n\\n    // Get the original and updated Element Merkle Root, given an index, a leaf, an update leaf, and a Single Proof\\n    function get_roots_from_leaf_and_single_proof_update(\\n        uint256 index,\\n        bytes32 leaf,\\n        bytes32 update_leaf,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 scratch, bytes32) {\\n        uint256 proof_index = proof.length - 1;\\n        uint256 upper_bound = uint256(proof[0]) - 1;\\n\\n        while (proof_index > 0) {\\n            if ((index != upper_bound) || (index & 1 == 1)) {\\n                scratch = proof[proof_index];\\n                proof_index -= 1;\\n                leaf = (index & 1 == 1) ? hash_node(scratch, leaf) : hash_node(leaf, scratch);\\n                update_leaf = (index & 1 == 1) ? hash_node(scratch, update_leaf) : hash_node(update_leaf, scratch);\\n            }\\n\\n            index >>= 1;\\n            upper_bound >>= 1;\\n        }\\n\\n        return (leaf, update_leaf);\\n    }\\n\\n    // Get the original and updated Element Merkle Root, given an index, a bytes32 element, a bytes32 update element, and a Single Proof\\n    function get_roots_from_single_proof_update(\\n        uint256 index,\\n        bytes32 element,\\n        bytes32 update_element,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 hash, bytes32 update_hash) {\\n        hash = keccak256(abi.encodePacked(bytes1(0), element));\\n        update_hash = keccak256(abi.encodePacked(bytes1(0), update_element));\\n        return get_roots_from_leaf_and_single_proof_update(index, hash, update_hash, proof);\\n    }\\n\\n    // Get the indices of the elements being proven, given an Existence Multi Proof\\n    function get_indices_from_multi_proof(uint256 element_count, bytes32 flags, bytes32 skips, bytes32 orders)\\n        internal\\n        pure\\n        returns (uint256[] memory indices)\\n    {\\n        indices = new uint256[](element_count);\\n        uint256[] memory bits_pushed = new uint256[](element_count);\\n        bool[] memory grouped_with_next = new bool[](element_count);\\n        element_count -= 1;\\n        uint256 index = element_count;\\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n        bytes32 flag;\\n        bytes32 skip;\\n        bytes32 order;\\n        uint256 bits_to_push;\\n\\n        while (true) {\\n            flag = flags & bit_check;\\n            skip = skips & bit_check;\\n            order = orders & bit_check;\\n            bits_to_push = 1 << bits_pushed[index];\\n\\n            if (skip == bit_check) {\\n                if (flag == bit_check) return indices;\\n\\n                while (true) {\\n                    bits_pushed[index]++;\\n\\n                    if (index == 0) {\\n                        index = element_count;\\n                        break;\\n                    }\\n\\n                    if (!grouped_with_next[index--]) break;\\n                }\\n\\n                bit_check <<= 1;\\n                continue;\\n            }\\n\\n            if (flag == bit_check) {\\n                while (true) {\\n                    if (order == bit_check) {\\n                        indices[index] |= bits_to_push;\\n                    }\\n\\n                    bits_pushed[index]++;\\n\\n                    if (index == 0) {\\n                        index = element_count;\\n                        break;\\n                    }\\n\\n                    if (!grouped_with_next[index]) {\\n                        grouped_with_next[index--] = true;\\n                        break;\\n                    }\\n\\n                    grouped_with_next[index--] = true;\\n                }\\n            }\\n\\n            while (true) {\\n                if (order != bit_check) {\\n                    indices[index] |= bits_to_push;\\n                }\\n\\n                bits_pushed[index]++;\\n\\n                if (index == 0) {\\n                    index = element_count;\\n                    break;\\n                }\\n\\n                if (!grouped_with_next[index--]) break;\\n            }\\n\\n            bit_check <<= 1;\\n        }\\n    }\\n\\n    // Get leafs from bytes32 elements in memory, in reverse order\\n    function get_reversed_leafs_from_elements(bytes32[] memory elements)\\n        internal\\n        pure\\n        returns (bytes32[] memory leafs)\\n    {\\n        uint256 element_count = elements.length;\\n        leafs = new bytes32[](element_count);\\n        // uint256 read_index = element_count - 1;\\n        // uint256 write_index;\\n\\n        for (uint64 i = 0; i < element_count; i++) {\\n            leafs[i] = keccak256(abi.encodePacked(bytes1(0), elements[element_count - 1 - i]));\\n        }\\n\\n        // while (write_index < element_count) {\\n        //     leafs[write_index] = keccak256(abi.encodePacked(bytes1(0), elements[read_index]));\\n        //     write_index += 1;\\n        //     read_index -= 1;\\n        // }\\n    }\\n\\n    // Get the original Element Merkle Root, given leafs and an Existence Multi Proof\\n    function get_root_from_leafs_and_multi_proof(bytes32[] memory leafs, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 right)\\n    {\\n        uint256 leaf_count = leafs.length;\\n        uint256 read_index;\\n        uint256 write_index;\\n        uint256 proof_index = 4;\\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n        bytes32 flags = proof[1];\\n        bytes32 skips = proof[2];\\n        bytes32 orders = proof[3];\\n\\n        while (true) {\\n            if (skips & bit_check == bit_check) {\\n                if (flags & bit_check == bit_check) return leafs[(write_index == 0 ? leaf_count : write_index) - 1];\\n\\n                leafs[write_index] = leafs[read_index];\\n\\n                read_index = (read_index + 1) % leaf_count;\\n                write_index = (write_index + 1) % leaf_count;\\n                bit_check <<= 1;\\n                continue;\\n            }\\n\\n            right = (flags & bit_check == bit_check) ? leafs[read_index++] : proof[proof_index++];\\n\\n            read_index %= leaf_count;\\n\\n            leafs[write_index] = hash_pair(leafs[read_index], right, orders & bit_check == bit_check);\\n\\n            read_index = (read_index + 1) % leaf_count;\\n            write_index = (write_index + 1) % leaf_count;\\n            bit_check <<= 1;\\n        }\\n    }\\n\\n    // Get the original Element Merkle Root, given bytes32 memory in memory and an Existence Multi Proof\\n    function get_root_from_multi_proof(bytes32[] memory elements, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return get_root_from_leafs_and_multi_proof(get_reversed_leafs_from_elements(elements), proof);\\n    }\\n\\n    // Get current and update leafs from current bytes32 elements in memory and update bytes32 elements in memory, in reverse order\\n    function get_reversed_leafs_from_current_and_update_elements(\\n        bytes32[] memory elements,\\n        bytes32[] memory update_elements\\n    ) internal pure returns (bytes32[] memory leafs, bytes32[] memory update_leafs) {\\n        uint256 element_count = elements.length;\\n        require(update_elements.length == element_count, \\\"LENGTH_MISMATCH\\\");\\n\\n        leafs = new bytes32[](element_count);\\n        update_leafs = new bytes32[](element_count);\\n        // uint256 read_index = element_count - 1;\\n        // uint256 write_index;\\n\\n        // while (write_index < element_count) {\\n        //     leafs[write_index] = keccak256(abi.encodePacked(bytes1(0), elements[read_index]));\\n        //     update_leafs[write_index] = keccak256(abi.encodePacked(bytes1(0), update_elements[read_index]));\\n        //     write_index += 1;\\n        //     read_index -= 1;\\n        // }\\n\\n        for (uint64 i = 0; i < element_count; i++) {\\n            leafs[i] = keccak256(abi.encodePacked(bytes1(0), elements[element_count - 1 - i]));\\n            update_leafs[i] = keccak256(abi.encodePacked(bytes1(0), update_elements[element_count - 1 - i]));\\n        }\\n    }\\n\\n    // Get the original and updated Element Merkle Root, given leafs, update leafs, and an Existence Multi Proof\\n    function get_roots_from_leafs_and_multi_proof_update(\\n        bytes32[] memory leafs,\\n        bytes32[] memory update_leafs,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 flags, bytes32 skips) {\\n        uint256 leaf_count = update_leafs.length;\\n        uint256 read_index;\\n        uint256 write_index;\\n        uint256 proof_index = 4;\\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n        flags = proof[1];\\n        skips = proof[2];\\n        bytes32 orders = proof[3];\\n        bytes32 scratch;\\n        uint256 scratch_2;\\n\\n        while (true) {\\n            if (skips & bit_check == bit_check) {\\n                if (flags & bit_check == bit_check) {\\n                    read_index = (write_index == 0 ? leaf_count : write_index) - 1;\\n\\n                    return (leafs[read_index], update_leafs[read_index]);\\n                }\\n\\n                leafs[write_index] = leafs[read_index];\\n                update_leafs[write_index] = update_leafs[read_index];\\n\\n                read_index = (read_index + 1) % leaf_count;\\n                write_index = (write_index + 1) % leaf_count;\\n                bit_check <<= 1;\\n                continue;\\n            }\\n\\n            if (flags & bit_check == bit_check) {\\n                scratch_2 = (read_index + 1) % leaf_count;\\n\\n                leafs[write_index] = hash_pair(leafs[scratch_2], leafs[read_index], orders & bit_check == bit_check);\\n                update_leafs[write_index] =\\n                    hash_pair(update_leafs[scratch_2], update_leafs[read_index], orders & bit_check == bit_check);\\n\\n                read_index += 2;\\n            } else {\\n                scratch = proof[proof_index++];\\n\\n                leafs[write_index] = hash_pair(leafs[read_index], scratch, orders & bit_check == bit_check);\\n                update_leafs[write_index] =\\n                    hash_pair(update_leafs[read_index], scratch, orders & bit_check == bit_check);\\n\\n                read_index += 1;\\n            }\\n\\n            read_index %= leaf_count;\\n            write_index = (write_index + 1) % leaf_count;\\n            bit_check <<= 1;\\n        }\\n    }\\n\\n    // Get the original and updated Element Merkle Root,\\n    // given bytes32 elements in memory, bytes32 update elements in memory, and an Existence Multi Proof\\n    function get_roots_from_multi_proof_update(\\n        bytes32[] memory elements,\\n        bytes32[] memory update_elements,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32, bytes32) {\\n        (bytes32[] memory leafs, bytes32[] memory update_leafs) =\\n            get_reversed_leafs_from_current_and_update_elements(elements, update_elements);\\n        return get_roots_from_leafs_and_multi_proof_update(leafs, update_leafs, proof);\\n    }\\n\\n    // Get the original Element Merkle Root, given an Append Proof\\n    function get_root_from_append_proof(bytes32[] memory proof) internal pure returns (bytes32 hash) {\\n        uint256 proof_index = bit_count_32(uint32(uint256(proof[0])));\\n        hash = proof[proof_index];\\n\\n        while (proof_index > 1) {\\n            proof_index -= 1;\\n            hash = hash_node(proof[proof_index], hash);\\n        }\\n    }\\n\\n    // Get the original and updated Element Merkle Root, given append leaf and an Append Proof\\n    function get_roots_from_leaf_and_append_proof_single_append(bytes32 append_leaf, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 hash, bytes32 scratch)\\n    {\\n        uint256 proof_index = bit_count_32(uint32(uint256(proof[0])));\\n        hash = proof[proof_index];\\n        append_leaf = hash_node(hash, append_leaf);\\n\\n        while (proof_index > 1) {\\n            proof_index -= 1;\\n            scratch = proof[proof_index];\\n            append_leaf = hash_node(scratch, append_leaf);\\n            hash = hash_node(scratch, hash);\\n        }\\n\\n        return (hash, append_leaf);\\n    }\\n\\n    // Get the original and updated Element Merkle Root, given a bytes32 append element in memory and an Append Proof\\n    function get_roots_from_append_proof_single_append(bytes32 append_element, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 append_leaf, bytes32)\\n    {\\n        append_leaf = keccak256(abi.encodePacked(bytes1(0), append_element));\\n        return get_roots_from_leaf_and_append_proof_single_append(append_leaf, proof);\\n    }\\n\\n    // Get leafs from bytes32 elements in memory\\n    function get_leafs_from_elements(bytes32[] memory elements) internal pure returns (bytes32[] memory leafs) {\\n        uint256 element_count = elements.length;\\n        leafs = new bytes32[](element_count);\\n\\n        while (element_count > 0) {\\n            element_count -= 1;\\n            leafs[element_count] = keccak256(abi.encodePacked(bytes1(0), elements[element_count]));\\n        }\\n    }\\n\\n    // Get the original and updated Element Merkle Root, given append leafs and an Append Proof\\n    function get_roots_from_leafs_and_append_proof_multi_append(bytes32[] memory append_leafs, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 hash, bytes32)\\n    {\\n        uint256 leaf_count = append_leafs.length;\\n        uint256 write_index;\\n        uint256 read_index;\\n        uint256 offset = uint256(proof[0]);\\n        uint256 index = offset;\\n\\n        // reuse leaf_count variable as upper_bound, since leaf_count no longer needed\\n        leaf_count += offset;\\n        leaf_count -= 1;\\n        uint256 proof_index = bit_count_32(uint32(offset));\\n        hash = proof[proof_index];\\n\\n        while (leaf_count > 0) {\\n            if ((write_index == 0) && (index & 1 == 1)) {\\n                append_leafs[0] = hash_node(proof[proof_index], append_leafs[read_index]);\\n                proof_index -= 1;\\n                read_index += 1;\\n\\n                if (proof_index > 0) {\\n                    hash = hash_node(proof[proof_index], hash);\\n                }\\n\\n                write_index = 1;\\n                index += 1;\\n            } else if (index < leaf_count) {\\n                append_leafs[write_index++] = hash_node(append_leafs[read_index++], append_leafs[read_index]);\\n                read_index += 1;\\n                index += 2;\\n            }\\n\\n            if (index >= leaf_count) {\\n                if (index == leaf_count) {\\n                    append_leafs[write_index] = append_leafs[read_index];\\n                }\\n\\n                read_index = 0;\\n                write_index = 0;\\n                leaf_count >>= 1;\\n                offset >>= 1;\\n                index = offset;\\n            }\\n        }\\n\\n        return (hash, append_leafs[0]);\\n    }\\n\\n    // Get the original and updated Element Merkle Root, given bytes32 append elements in memory and an Append Proof\\n    function get_roots_from_append_proof_multi_append(bytes32[] memory append_elements, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32, bytes32)\\n    {\\n        return get_roots_from_leafs_and_append_proof_multi_append(get_leafs_from_elements(append_elements), proof);\\n    }\\n\\n    // Get the updated Element Merkle Root, given an append leaf and an Append Proof\\n    function get_new_root_from_leafs_and_append_proof_single_append(bytes32 append_leaf, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 append_hash)\\n    {\\n        uint256 proof_index = bit_count_32(uint32(uint256(proof[0])));\\n        append_hash = hash_node(proof[proof_index], append_leaf);\\n\\n        while (proof_index > 1) {\\n            proof_index -= 1;\\n            append_hash = hash_node(proof[proof_index], append_hash);\\n        }\\n    }\\n\\n    // Get the updated Element Merkle Root, given a bytes32 append elements in memory and an Append Proof\\n    function get_new_root_from_append_proof_single_append(bytes32 append_element, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 append_leaf)\\n    {\\n        append_leaf = keccak256(abi.encodePacked(bytes1(0), append_element));\\n        return get_new_root_from_leafs_and_append_proof_single_append(append_leaf, proof);\\n    }\\n\\n    // Get the updated Element Merkle Root, given append leafs and an Append Proof\\n    function get_new_root_from_leafs_and_append_proof_multi_append(\\n        bytes32[] memory append_leafs,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32) {\\n        uint256 leaf_count = append_leafs.length;\\n        uint256 write_index;\\n        uint256 read_index;\\n        uint256 offset = uint256(proof[0]);\\n        uint256 index = offset;\\n\\n        // reuse leaf_count variable as upper_bound, since leaf_count no longer needed\\n        leaf_count += offset;\\n        leaf_count -= 1;\\n        uint256 proof_index = proof.length - 1;\\n\\n        while (leaf_count > 0) {\\n            if ((write_index == 0) && (index & 1 == 1)) {\\n                append_leafs[0] = hash_node(proof[proof_index], append_leafs[read_index]);\\n\\n                read_index += 1;\\n                proof_index -= 1;\\n                write_index = 1;\\n                index += 1;\\n            } else if (index < leaf_count) {\\n                append_leafs[write_index++] = hash_node(append_leafs[read_index++], append_leafs[read_index++]);\\n\\n                index += 2;\\n            }\\n\\n            if (index >= leaf_count) {\\n                if (index == leaf_count) {\\n                    append_leafs[write_index] = append_leafs[read_index];\\n                }\\n\\n                read_index = 0;\\n                write_index = 0;\\n                leaf_count >>= 1;\\n                offset >>= 1;\\n                index = offset;\\n            }\\n        }\\n\\n        return append_leafs[0];\\n    }\\n\\n    // Get the updated Element Merkle Root, given bytes32 append elements in memory and an Append Proof\\n    function get_new_root_from_append_proof_multi_append(bytes32[] memory append_elements, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return get_new_root_from_leafs_and_append_proof_multi_append(get_leafs_from_elements(append_elements), proof);\\n    }\\n\\n    // Get the original Element Merkle Root and derive Append Proof, given an index, an append leaf, and a Single Proof\\n    function get_append_proof_from_leaf_and_single_proof(uint256 index, bytes32 leaf, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 append_hash, bytes32[] memory append_proof)\\n    {\\n        uint256 proof_index = proof.length - 1;\\n        uint256 append_node_index = uint256(proof[0]);\\n        uint256 upper_bound = append_node_index - 1;\\n        uint256 append_proof_index = bit_count_32(uint32(append_node_index)) + 1;\\n        append_proof = new bytes32[](append_proof_index);\\n        append_proof[0] = bytes32(append_node_index);\\n        bytes32 scratch;\\n\\n        while (proof_index > 0) {\\n            if (index != upper_bound || (index & 1 == 1)) {\\n                scratch = proof[proof_index];\\n\\n                leaf = (index & 1 == 1) ? hash_node(scratch, leaf) : hash_node(leaf, scratch);\\n\\n                if (append_node_index & 1 == 1) {\\n                    append_proof_index -= 1;\\n                    append_proof[append_proof_index] = scratch;\\n                    append_hash = hash_node(scratch, append_hash);\\n                }\\n\\n                proof_index -= 1;\\n            } else if (append_node_index & 1 == 1) {\\n                append_proof_index -= 1;\\n                append_proof[append_proof_index] = leaf;\\n                append_hash = leaf;\\n            }\\n\\n            index >>= 1;\\n            upper_bound >>= 1;\\n            append_node_index >>= 1;\\n        }\\n\\n        require(append_proof_index == 2 || append_hash == leaf, \\\"INVALID_PROOF\\\");\\n\\n        if (append_proof_index == 2) {\\n            append_proof[1] = leaf;\\n        }\\n    }\\n\\n    // Get the original Element Merkle Root and derive Append Proof, given an index, a bytes32 element, and a Single Proof\\n    function get_append_proof_from_single_proof(uint256 index, bytes32 element, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 leaf, bytes32[] memory)\\n    {\\n        leaf = keccak256(abi.encodePacked(bytes1(0), element));\\n        return get_append_proof_from_leaf_and_single_proof(index, leaf, proof);\\n    }\\n\\n    // Get the original Element Merkle Root and derive Append Proof, given an index, a leaf, an update leaf, and a Single Proof\\n    function get_append_proof_from_leaf_and_single_proof_update(\\n        uint256 index,\\n        bytes32 leaf,\\n        bytes32 update_leaf,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 append_hash, bytes32[] memory append_proof) {\\n        uint256 proof_index = proof.length - 1;\\n        uint256 append_node_index = uint256(proof[0]);\\n        uint256 upper_bound = append_node_index - 1;\\n        uint256 append_proof_index = bit_count_32(uint32(append_node_index)) + 1;\\n        append_proof = new bytes32[](append_proof_index);\\n        append_proof[0] = bytes32(append_node_index);\\n        bytes32 scratch;\\n\\n        while (proof_index > 0) {\\n            if (index != upper_bound || (index & 1 == 1)) {\\n                scratch = proof[proof_index];\\n\\n                leaf = (index & 1 == 1) ? hash_node(scratch, leaf) : hash_node(leaf, scratch);\\n\\n                update_leaf = (index & 1 == 1) ? hash_node(scratch, update_leaf) : hash_node(update_leaf, scratch);\\n\\n                if (append_node_index & 1 == 1) {\\n                    append_proof_index -= 1;\\n                    append_proof[append_proof_index] = scratch;\\n                    append_hash = hash_node(scratch, append_hash);\\n                }\\n\\n                proof_index -= 1;\\n            } else if (append_node_index & 1 == 1) {\\n                append_proof_index -= 1;\\n                append_proof[append_proof_index] = update_leaf;\\n                append_hash = leaf;\\n            }\\n\\n            index >>= 1;\\n            upper_bound >>= 1;\\n            append_node_index >>= 1;\\n        }\\n\\n        require(append_proof_index == 2 || append_hash == leaf, \\\"INVALID_PROOF\\\");\\n\\n        if (append_proof_index == 2) {\\n            append_proof[1] = update_leaf;\\n        }\\n    }\\n\\n    // Get the original Element Merkle Root and derive Append Proof,\\n    // given an index, a bytes32 element, a bytes32 update element, and a Single Proof\\n    function get_append_proof_from_single_proof_update(\\n        uint256 index,\\n        bytes32 element,\\n        bytes32 update_element,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 leaf, bytes32[] memory) {\\n        leaf = keccak256(abi.encodePacked(bytes1(0), element));\\n        bytes32 update_leaf = keccak256(abi.encodePacked(bytes1(0), update_element));\\n        return get_append_proof_from_leaf_and_single_proof_update(index, leaf, update_leaf, proof);\\n    }\\n\\n    // Hashes leaf at read index and next index (circular) to write index\\n    function hash_within_leafs(\\n        bytes32[] memory leafs,\\n        uint256 write_index,\\n        uint256 read_index,\\n        uint256 leaf_count,\\n        bool order\\n    ) internal pure {\\n        leafs[write_index] = order\\n            ? hash_node(leafs[(read_index + 1) % leaf_count], leafs[read_index])\\n            : hash_node(leafs[read_index], leafs[(read_index + 1) % leaf_count]);\\n    }\\n\\n    // Hashes value with leaf at read index to write index\\n    function hash_with_leafs(bytes32[] memory leafs, bytes32 value, uint256 write_index, uint256 read_index, bool order)\\n        internal\\n        pure\\n    {\\n        leafs[write_index] = order ? hash_node(leafs[read_index], value) : hash_node(value, leafs[read_index]);\\n    }\\n\\n    // Get the original Element Merkle Root and derive Append Proof, given leafs and an Existence Multi Proof\\n    function get_append_proof_from_leafs_and_multi_proof(bytes32[] memory leafs, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 append_hash, bytes32[] memory append_proof)\\n    {\\n        uint256 leaf_count = leafs.length;\\n        uint256 read_index;\\n        uint256 write_index;\\n        uint256 proof_index = 4;\\n        uint256 append_node_index = uint256(proof[0]);\\n        uint256 append_proof_index = uint256(bit_count_32(uint32(append_node_index))) + 1;\\n        append_proof = new bytes32[](append_proof_index);\\n        append_proof[0] = bytes32(append_node_index);\\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n        bytes32 skips = proof[2];\\n        uint256 read_index_of_append_node;\\n        bool scratch;\\n\\n        while (true) {\\n            if (skips & bit_check == bit_check) {\\n                if (proof[1] & bit_check == bit_check) {\\n                    read_index = (write_index == 0 ? leaf_count : write_index) - 1;\\n\\n                    // reuse bit_check as scratch variable\\n                    bit_check = leafs[read_index];\\n\\n                    require(append_proof_index == 2 || append_hash == bit_check, \\\"INVALID_PROOF\\\");\\n\\n                    if (append_proof_index == 2) {\\n                        append_proof[1] = bit_check;\\n                    }\\n\\n                    return (append_hash, append_proof);\\n                }\\n\\n                if (append_node_index & 1 == 1) {\\n                    append_proof_index -= 1;\\n                    append_hash = leafs[read_index]; // TODO scratch this leafs[read_index] above\\n                    append_proof[append_proof_index] = leafs[read_index];\\n                }\\n\\n                read_index_of_append_node = write_index;\\n                append_node_index >>= 1;\\n\\n                leafs[write_index] = leafs[read_index];\\n\\n                read_index = (read_index + 1) % leaf_count;\\n                write_index = (write_index + 1) % leaf_count;\\n                bit_check <<= 1;\\n                continue;\\n            }\\n\\n            scratch = proof[1] & bit_check == bit_check;\\n\\n            if (read_index_of_append_node == read_index) {\\n                if (append_node_index & 1 == 1) {\\n                    append_proof_index -= 1;\\n\\n                    if (scratch) {\\n                        // reuse read_index_of_append_node as temporary scratch variable\\n                        read_index_of_append_node = (read_index + 1) % leaf_count;\\n\\n                        append_hash = hash_node(leafs[read_index_of_append_node], append_hash);\\n                        append_proof[append_proof_index] = leafs[read_index_of_append_node];\\n                    } else {\\n                        append_hash = hash_node(proof[proof_index], append_hash);\\n                        append_proof[append_proof_index] = proof[proof_index];\\n                    }\\n                }\\n\\n                read_index_of_append_node = write_index;\\n                append_node_index >>= 1;\\n            }\\n\\n            if (scratch) {\\n                scratch = proof[3] & bit_check == bit_check;\\n                hash_within_leafs(leafs, write_index, read_index, leaf_count, scratch);\\n                read_index += 2;\\n            } else {\\n                scratch = proof[3] & bit_check == bit_check;\\n                hash_with_leafs(leafs, proof[proof_index], write_index, read_index, scratch);\\n                proof_index += 1;\\n                read_index += 1;\\n            }\\n\\n            read_index %= leaf_count;\\n            write_index = (write_index + 1) % leaf_count;\\n            bit_check <<= 1;\\n        }\\n    }\\n\\n    // Get the original Element Merkle Root and derive Append Proof, given bytes32 elements in memory and an Existence Multi Proof\\n    function get_append_proof_from_multi_proof(bytes32[] memory elements, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32, bytes32[] memory)\\n    {\\n        return get_append_proof_from_leafs_and_multi_proof(get_reversed_leafs_from_elements(elements), proof);\\n    }\\n\\n    // Get combined current and update leafs from current bytes32 elements in memory and update bytes32 elements in memory, in reverse order\\n    function get_reversed_combined_leafs_from_current_and_update_elements(\\n        bytes32[] memory elements,\\n        bytes32[] memory update_elements\\n    ) internal pure returns (bytes32[] memory combined_leafs) {\\n        uint256 element_count = elements.length;\\n        require(update_elements.length == element_count, \\\"LENGTH_MISMATCH\\\");\\n\\n        combined_leafs = new bytes32[](element_count << 1);\\n        // uint256 read_index = element_count - 1;\\n        // uint256 write_index;\\n\\n        // while (write_index < element_count) {\\n        //     combined_leafs[write_index] = keccak256(abi.encodePacked(bytes1(0), elements[read_index]));\\n        //     combined_leafs[element_count + write_index] =\\n        //         keccak256(abi.encodePacked(bytes1(0), update_elements[read_index]));\\n        //     write_index += 1;\\n        //     read_index -= 1;\\n        // }\\n\\n        for (uint64 i = 0; i < element_count; i++) {\\n            combined_leafs[i] = keccak256(abi.encodePacked(bytes1(0), elements[element_count - 1 - i]));\\n            combined_leafs[element_count + i] =\\n                keccak256(abi.encodePacked(bytes1(0), update_elements[element_count - 1 - i]));\\n        }\\n    }\\n\\n    // Copy leaf and update leaf at read indices and to write indices\\n    function copy_within_combined_leafs(\\n        bytes32[] memory combined_leafs,\\n        uint256 write_index,\\n        uint256 read_index,\\n        uint256 leaf_count\\n    ) internal pure {\\n        combined_leafs[write_index] = combined_leafs[read_index];\\n        combined_leafs[leaf_count + write_index] = combined_leafs[leaf_count + read_index];\\n    }\\n\\n    // Hashes leaf and update leaf at read indices and next indices (circular) to write indices\\n    function hash_within_combined_leafs(\\n        bytes32[] memory combined_leafs,\\n        uint256 write_index,\\n        uint256 read_index,\\n        uint256 leaf_count,\\n        bool order\\n    ) internal pure {\\n        uint256 scratch = (read_index + 1) % leaf_count;\\n\\n        combined_leafs[write_index] = order\\n            ? hash_node(combined_leafs[scratch], combined_leafs[read_index])\\n            : hash_node(combined_leafs[read_index], combined_leafs[scratch]);\\n\\n        combined_leafs[leaf_count + write_index] = order\\n            ? hash_node(combined_leafs[leaf_count + scratch], combined_leafs[leaf_count + read_index])\\n            : hash_node(combined_leafs[leaf_count + read_index], combined_leafs[leaf_count + scratch]);\\n    }\\n\\n    // Hashes value with leaf and update leaf at read indices to write indices\\n    function hash_with_combined_leafs(\\n        bytes32[] memory combined_leafs,\\n        bytes32 value,\\n        uint256 write_index,\\n        uint256 read_index,\\n        uint256 leaf_count,\\n        bool order\\n    ) internal pure {\\n        combined_leafs[write_index] =\\n            order ? hash_node(combined_leafs[read_index], value) : hash_node(value, combined_leafs[read_index]);\\n\\n        combined_leafs[leaf_count + write_index] = order\\n            ? hash_node(combined_leafs[leaf_count + read_index], value)\\n            : hash_node(value, combined_leafs[leaf_count + read_index]);\\n    }\\n\\n    // Get the original Element Merkle Root and derive Append Proof, given combined leafs and update leafs and an Existence Multi Proof\\n    function get_append_proof_from_leafs_and_multi_proof_update(bytes32[] memory combined_leafs, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 append_hash, bytes32[] memory append_proof)\\n    {\\n        uint256 leaf_count = combined_leafs.length >> 1;\\n        uint256 read_index;\\n        uint256 write_index;\\n        uint256 read_index_of_append_node;\\n        uint256 proof_index = 4;\\n        uint256 append_node_index = uint256(proof[0]);\\n        uint256 append_proof_index = bit_count_32(uint32(append_node_index)) + 1;\\n        append_proof = new bytes32[](append_proof_index);\\n        append_proof[0] = bytes32(append_node_index);\\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n        bool scratch;\\n\\n        while (true) {\\n            if (proof[2] & bit_check == bit_check) {\\n                if (proof[1] & bit_check == bit_check) {\\n                    read_index = (write_index == 0 ? leaf_count : write_index) - 1;\\n\\n                    // reuse bit_check as scratch variable\\n                    bit_check = combined_leafs[read_index];\\n\\n                    require(append_proof_index == 2 || append_hash == bit_check, \\\"INVALID_PROOF\\\");\\n\\n                    if (append_proof_index == 2) {\\n                        append_proof[1] = combined_leafs[leaf_count + read_index];\\n                    }\\n\\n                    return (bit_check, append_proof);\\n                }\\n\\n                if (append_node_index & 1 == 1) {\\n                    append_proof_index -= 1;\\n                    append_hash = combined_leafs[read_index];\\n                    append_proof[append_proof_index] = combined_leafs[leaf_count + read_index];\\n                }\\n\\n                read_index_of_append_node = write_index;\\n                append_node_index >>= 1;\\n\\n                copy_within_combined_leafs(combined_leafs, write_index, read_index, leaf_count);\\n\\n                read_index = (read_index + 1) % leaf_count;\\n                write_index = (write_index + 1) % leaf_count;\\n                bit_check <<= 1;\\n                continue;\\n            }\\n\\n            scratch = proof[1] & bit_check == bit_check;\\n\\n            if (read_index_of_append_node == read_index) {\\n                if (append_node_index & 1 == 1) {\\n                    append_proof_index -= 1;\\n\\n                    if (scratch) {\\n                        // use read_index_of_append_node as temporary scratch\\n                        read_index_of_append_node = (read_index + 1) % leaf_count;\\n\\n                        append_hash = hash_node(combined_leafs[read_index_of_append_node], append_hash);\\n                        append_proof[append_proof_index] = combined_leafs[leaf_count + read_index_of_append_node];\\n                    } else {\\n                        append_hash = hash_node(proof[proof_index], append_hash);\\n                        append_proof[append_proof_index] = proof[proof_index];\\n                    }\\n                }\\n\\n                read_index_of_append_node = write_index;\\n                append_node_index >>= 1;\\n            }\\n\\n            if (scratch) {\\n                scratch = proof[3] & bit_check == bit_check;\\n\\n                hash_within_combined_leafs(combined_leafs, write_index, read_index, leaf_count, scratch);\\n\\n                read_index += 2;\\n            } else {\\n                scratch = proof[3] & bit_check == bit_check;\\n\\n                hash_with_combined_leafs(\\n                    combined_leafs, proof[proof_index], write_index, read_index, leaf_count, scratch\\n                );\\n\\n                proof_index += 1;\\n                read_index += 1;\\n            }\\n\\n            read_index %= leaf_count;\\n            write_index = (write_index + 1) % leaf_count;\\n            bit_check <<= 1;\\n        }\\n    }\\n\\n    // Get the original Element Merkle Root and derive Append Proof,\\n    // given bytes32 elements in memory, bytes32 update elements in memory, and an Existence Multi Proof\\n    function get_append_proof_from_multi_proof_update(\\n        bytes32[] memory elements,\\n        bytes32[] memory update_elements,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32, bytes32[] memory) {\\n        return get_append_proof_from_leafs_and_multi_proof_update(\\n            get_reversed_combined_leafs_from_current_and_update_elements(elements, update_elements), proof\\n        );\\n    }\\n\\n    // INTERFACE: Check if bytes32 element exists at index, given a root and a Single Proof\\n    function element_exists(bytes32 root, uint256 index, bytes32 element, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return hash_node(proof[0], get_root_from_single_proof(index, element, proof)) == root;\\n    }\\n\\n    // INTERFACE: Check if bytes32 elements in memory exist, given a root and a Single Proof\\n    function elements_exist(bytes32 root, bytes32[] memory elements, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return hash_node(proof[0], get_root_from_multi_proof(elements, proof)) == root;\\n    }\\n\\n    // INTERFACE: Get the indices of the bytes32 elements in memory, given an Existence Multi Proof\\n    function get_indices(bytes32[] memory elements, bytes32[] memory proof) internal pure returns (uint256[] memory) {\\n        return get_indices_from_multi_proof(elements.length, proof[1], proof[2], proof[3]);\\n    }\\n\\n    // INTERFACE: Check tree size, given a Size Proof\\n    function verify_size_with_proof(bytes32 root, uint256 size, bytes32[] memory proof) internal pure returns (bool) {\\n        if (root == bytes32(0) && size == 0) return true;\\n\\n        return hash_node(bytes32(size), get_root_from_size_proof(size, proof)) == root;\\n    }\\n\\n    // INTERFACE: Check tree size, given a the Element Merkle Root\\n    function verify_size(bytes32 root, uint256 size, bytes32 element_root) internal pure returns (bool) {\\n        if (root == bytes32(0) && size == 0) return true;\\n\\n        return hash_node(bytes32(size), element_root) == root;\\n    }\\n\\n    // INTERFACE: Try to update a bytes32 element, given a root, and index, an bytes32 element, and a Single Proof\\n    function try_update_one(\\n        bytes32 root,\\n        uint256 index,\\n        bytes32 element,\\n        bytes32 update_element,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 new_element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32 old_element_root;\\n        (old_element_root, new_element_root) = get_roots_from_single_proof_update(index, element, update_element, proof);\\n\\n        require(hash_node(total_element_count, old_element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        return hash_node(total_element_count, new_element_root);\\n    }\\n\\n    // INTERFACE: Try to update bytes32 elements in memory, given a root, bytes32 elements in memory, and an Existence Multi Proof\\n    function try_update_many(\\n        bytes32 root,\\n        bytes32[] memory elements,\\n        bytes32[] memory update_elements,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 new_element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32 old_element_root;\\n        (old_element_root, new_element_root) = get_roots_from_multi_proof_update(elements, update_elements, proof);\\n\\n        require(hash_node(total_element_count, old_element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        return hash_node(total_element_count, new_element_root);\\n    }\\n\\n    // INTERFACE: Try to append a bytes32 element, given a root and an Append Proof\\n    function try_append_one(bytes32 root, bytes32 append_element, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 new_element_root)\\n    {\\n        bytes32 total_element_count = proof[0];\\n\\n        require((root == bytes32(0)) == (total_element_count == bytes32(0)), \\\"INVALID_TREE\\\");\\n\\n        if (root == bytes32(0)) return hash_node(bytes32(uint256(1)), get_root_from_one(append_element));\\n\\n        bytes32 old_element_root;\\n        (old_element_root, new_element_root) = get_roots_from_append_proof_single_append(append_element, proof);\\n\\n        require(hash_node(total_element_count, old_element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        return hash_node(bytes32(uint256(total_element_count) + 1), new_element_root);\\n    }\\n\\n    // INTERFACE: Try to append bytes32 elements in memory, given a root and an Append Proof\\n    function try_append_many(bytes32 root, bytes32[] memory append_elements, bytes32[] memory proof)\\n        internal\\n        pure\\n        returns (bytes32 new_element_root)\\n    {\\n        bytes32 total_element_count = proof[0];\\n\\n        require((root == bytes32(0)) == (total_element_count == bytes32(0)), \\\"INVALID_TREE\\\");\\n\\n        if (root == bytes32(0)) {\\n            return hash_node(bytes32(append_elements.length), get_root_from_many(append_elements));\\n        }\\n\\n        bytes32 old_element_root;\\n        (old_element_root, new_element_root) = get_roots_from_append_proof_multi_append(append_elements, proof);\\n\\n        require(hash_node(total_element_count, old_element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), new_element_root);\\n    }\\n\\n    // INTERFACE: Try to append a bytes32 element, given a root, an index, a bytes32 element, and a Single Proof\\n    function try_append_one_using_one(\\n        bytes32 root,\\n        uint256 index,\\n        bytes32 element,\\n        bytes32 append_element,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32[] memory append_proof;\\n        (element_root, append_proof) = get_append_proof_from_single_proof(index, element, proof);\\n\\n        require(hash_node(total_element_count, element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        element_root = get_new_root_from_append_proof_single_append(append_element, append_proof);\\n\\n        return hash_node(bytes32(uint256(total_element_count) + 1), element_root);\\n    }\\n\\n    // INTERFACE: Try to append bytes32 elements in memory, given a root, an index, a bytes32 element, and a Single Proof\\n    function try_append_many_using_one(\\n        bytes32 root,\\n        uint256 index,\\n        bytes32 element,\\n        bytes32[] memory append_elements,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32[] memory append_proof;\\n        (element_root, append_proof) = get_append_proof_from_single_proof(index, element, proof);\\n\\n        require(hash_node(total_element_count, element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        element_root = get_new_root_from_append_proof_multi_append(append_elements, append_proof);\\n\\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), element_root);\\n    }\\n\\n    // INTERFACE: Try to append a bytes32 element, given a root, bytes32 elements in memory, and an Existence Multi Proof\\n    function try_append_one_using_many(\\n        bytes32 root,\\n        bytes32[] memory elements,\\n        bytes32 append_element,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32[] memory append_proof;\\n        (element_root, append_proof) = get_append_proof_from_multi_proof(elements, proof);\\n\\n        require(hash_node(total_element_count, element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        element_root = get_new_root_from_append_proof_single_append(append_element, append_proof);\\n\\n        return hash_node(bytes32(uint256(total_element_count) + 1), element_root);\\n    }\\n\\n    // INTERFACE: Try to append bytes32 elements in memory, given a root, bytes32 elements in memory, and an Existence Multi Proof\\n    function try_append_many_using_many(\\n        bytes32 root,\\n        bytes32[] memory elements,\\n        bytes32[] memory append_elements,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32[] memory append_proof;\\n        (element_root, append_proof) = get_append_proof_from_multi_proof(elements, proof);\\n\\n        require(hash_node(total_element_count, element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        element_root = get_new_root_from_append_proof_multi_append(append_elements, append_proof);\\n\\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), element_root);\\n    }\\n\\n    // INTERFACE: Try to update a bytes32 element and append a bytes32 element,\\n    // given a root, an index, a bytes32 element, and a Single Proof\\n    function try_update_one_and_append_one(\\n        bytes32 root,\\n        uint256 index,\\n        bytes32 element,\\n        bytes32 update_element,\\n        bytes32 append_element,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32[] memory append_proof;\\n        (element_root, append_proof) = get_append_proof_from_single_proof_update(index, element, update_element, proof);\\n\\n        require(hash_node(total_element_count, element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        element_root = get_new_root_from_append_proof_single_append(append_element, append_proof);\\n\\n        return hash_node(bytes32(uint256(total_element_count) + 1), element_root);\\n    }\\n\\n    // INTERFACE: Try to update a bytes32 element and append bytes32 elements in memory,\\n    // given a root, an index, a bytes32 element, and a Single Proof\\n    function try_update_one_and_append_many(\\n        bytes32 root,\\n        uint256 index,\\n        bytes32 element,\\n        bytes32 update_element,\\n        bytes32[] memory append_elements,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32[] memory append_proof;\\n        (element_root, append_proof) = get_append_proof_from_single_proof_update(index, element, update_element, proof);\\n\\n        require(hash_node(total_element_count, element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        element_root = get_new_root_from_append_proof_multi_append(append_elements, append_proof);\\n\\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), element_root);\\n    }\\n\\n    // INTERFACE: Try to update bytes32 elements in memory and append a bytes32 element,\\n    // given a root, bytes32 elements in memory, and a Single Proof\\n    function try_update_many_and_append_one(\\n        bytes32 root,\\n        bytes32[] memory elements,\\n        bytes32[] memory update_elements,\\n        bytes32 append_element,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32[] memory append_proof;\\n        (element_root, append_proof) = get_append_proof_from_multi_proof_update(elements, update_elements, proof);\\n\\n        require(hash_node(total_element_count, element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        element_root = get_new_root_from_append_proof_single_append(append_element, append_proof);\\n\\n        return hash_node(bytes32(uint256(total_element_count) + 1), element_root);\\n    }\\n\\n    // INTERFACE: Try to update bytes32 elements in memory and append bytes32 elements in memory,\\n    // given a root, bytes32 elements in memory, and an Existence Multi Proof\\n    function try_update_many_and_append_many(\\n        bytes32 root,\\n        bytes32[] memory elements,\\n        bytes32[] memory update_elements,\\n        bytes32[] memory append_elements,\\n        bytes32[] memory proof\\n    ) internal pure returns (bytes32 element_root) {\\n        bytes32 total_element_count = proof[0];\\n\\n        require(root != bytes32(0) || total_element_count == bytes32(0), \\\"EMPTY_TREE\\\");\\n\\n        bytes32[] memory append_proof;\\n        (element_root, append_proof) = get_append_proof_from_multi_proof_update(elements, update_elements, proof);\\n\\n        require(hash_node(total_element_count, element_root) == root, \\\"INVALID_PROOF\\\");\\n\\n        element_root = get_new_root_from_append_proof_multi_append(append_elements, append_proof);\\n\\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), element_root);\\n    }\\n\\n    // INTERFACE: Create a tree and return the root, given a bytes32 element\\n    function create_from_one(bytes32 element) internal pure returns (bytes32 new_element_root) {\\n        return hash_node(bytes32(uint256(1)), get_root_from_one(element));\\n    }\\n\\n    // INTERFACE: Create a tree and return the root, given bytes32 elements in memory\\n    function create_from_many(bytes32[] memory elements) internal pure returns (bytes32 new_element_root) {\\n        return hash_node(bytes32(elements.length), get_root_from_many(elements));\\n    }\\n}\\n\",\"keccak256\":\"0x287df71c610876eb503766565c160917df28cb0ae9780c10753dbb2bd2058409\",\"license\":\"MIT\"},\"contracts/L1/fraud-proof/libraries/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n    * @param self The iterator.\\n    * @return The next element in the iteration.\\n    */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n    * @dev Returns true if the iteration has more elements.\\n    * @param self The iterator.\\n    * @return true if the iteration has more elements.\\n    */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n    * @param item RLP encoded bytes\\n    */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n    * @dev Create an iterator. Reverts if item is not a list.\\n    * @param self The RLP item.\\n    * @return An 'Iterator' over the item.\\n    */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n    * @param the RLP item.\\n    */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return RLPItem of (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadToRlpItem(RLPItem memory item) internal pure returns (RLPItem memory) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return RLPItem(memPtr, len);\\n    }\\n\\n    /*\\n    * @param the RLP item.\\n    */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n    * @param the RLP item containing the encoded list.\\n    */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * RLPItem conversions into data types *\\n     */\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shfit to the correct location if neccesary\\n            if lt(len, 32) { result := div(result, exp(256, sub(32, len))) }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n    * Private Helpers\\n    */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (\\n            byte0 < LIST_SHORT_START // being explicit\\n        ) {\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n    * @param src Pointer to source\\n    * @param dest Pointer to destination\\n    * @param len Amount of memory to copy from the source\\n    */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256 ** (WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8bf8579e473cf267b43ce28dfa9b66b6cb9480cb293e0f995e7b6074f66b9c39\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/libraries/RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n * @title RLPWriter\\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n *         modifications to improve legibility.\\n */\\nlibrary RLPWriter {\\n    /**\\n     * @notice RLP encodes a byte string.\\n     *\\n     * @param _in The byte string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\\n     *\\n     * @param _in The list of RLP encoded byte strings.\\n     *\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * @notice RLP encodes a string.\\n     *\\n     * @param _in The string to encode.\\n     *\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes an address.\\n     *\\n     * @param _in The address to encode.\\n     *\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a uint.\\n     *\\n     * @param _in The uint256 to encode.\\n     *\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * @notice RLP encodes a bool.\\n     *\\n     * @param _in The bool to encode.\\n     *\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n     *\\n     * @param _len    The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encode integer in big endian binary form with no leading zeroes.\\n     *\\n     * @param _x The integer to encode.\\n     *\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n     * @notice Copies a piece of memory to another location.\\n     *\\n     * @param _dest Destination location.\\n     * @param _src  Source location.\\n     * @param _len  Length of memory to copy.\\n     */\\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n     * @notice Flattens a list of byte strings into one byte string.\\n     *\\n     * @param _list List of byte strings to flatten.\\n     *\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\",\"keccak256\":\"0xe5a21bf190b08cd999280f22383da1703688309b47ba4c60a36fb40c628e3e78\",\"license\":\"MIT\"},\"contracts/L1/fraud-proof/verifier/IVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/VerificationContext.sol\\\";\\n\\ninterface IVerifier {\\n    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\\n        external\\n        pure\\n        returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1ae9ce9afd67261074a4242b9fb804d90f78f11eb667ed7bb0b97a51aee7b43b\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/verifier/IVerifierEntry.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/VerificationContext.sol\\\";\\n\\ninterface IVerifierEntry {\\n    function verifyOneStepProof(\\n        VerificationContext.Context memory ctx,\\n        uint8 verifier,\\n        bytes32 currStateHash,\\n        bytes calldata encoded\\n    ) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xd50cc2ff3f6f64c1a92543eaddafc253c706d53ee40c0bd88141d53c555fe6c0\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/verifier/libraries/BloomLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../libraries/BytesLib.sol\\\";\\n\\nlibrary BloomLib {\\n    using BytesLib for bytes;\\n\\n    struct Bloom {\\n        bytes32[8] data;\\n    }\\n\\n    function emptyBloom() internal pure returns (Bloom memory b) {\\n        return b;\\n    }\\n\\n    function decodeBloom(bytes calldata encoded, uint64 offset) internal pure returns (Bloom memory) {\\n        Bloom memory bloom;\\n        for (uint256 i = 0; i < 8; i++) {\\n            bloom.data[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        return bloom;\\n    }\\n\\n    function addHash(Bloom memory bloom, bytes32 h) internal pure {\\n        uint16 i1 = 255 - (uint16(uint256(h) >> 240) & 0x7ff) >> 3;\\n        uint8 v1 = uint8(1 << (uint8(h[1]) & 0x7));\\n        bloom.data[i1 >> 5] = bytes32(uint256(bloom.data[i1 >> 5]) | (uint256(v1) << 8 * (31 - (i1 & 0x1f))));\\n        uint16 i2 = 255 - (uint16(uint256(h) >> 224) & 0x7ff) >> 3;\\n        uint8 v2 = uint8(1 << (uint8(h[3]) & 0x7));\\n        bloom.data[i2 >> 5] = bytes32(uint256(bloom.data[i2 >> 5]) | (uint256(v2) << 8 * (31 - (i2 & 0x1f))));\\n        uint16 i3 = 255 - (uint16(uint256(h) >> 208) & 0x7ff) >> 3;\\n        uint8 v3 = uint8(1 << (uint8(h[5]) & 0x7));\\n        bloom.data[i3 >> 5] = bytes32(uint256(bloom.data[i3 >> 5]) | (uint256(v3) << 8 * (31 - (i3 & 0x1f))));\\n    }\\n\\n    function add(Bloom memory bloom, bytes memory data) internal pure {\\n        bytes32 h;\\n        assembly {\\n            h := keccak256(add(data, 0x20), mload(data))\\n        }\\n        addHash(bloom, h);\\n    }\\n\\n    function add(Bloom memory bloom, address data) internal pure {\\n        bytes32 h = keccak256(abi.encodePacked(data));\\n        addHash(bloom, h);\\n    }\\n\\n    function add(Bloom memory bloom, bytes32 data) internal pure {\\n        bytes32 h = keccak256(abi.encodePacked(data));\\n        addHash(bloom, h);\\n    }\\n}\\n\",\"keccak256\":\"0x2077a2c7d984643614fd1d639e0d9e217d4e62645849b92ec70cd56cb9845105\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/verifier/libraries/EVMTypesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../libraries/BytesLib.sol\\\";\\nimport \\\"../../libraries/RLPReader.sol\\\";\\nimport \\\"../../libraries/RLPWriter.sol\\\";\\nimport \\\"./BloomLib.sol\\\";\\n\\nlibrary EVMTypesLib {\\n    using BytesLib for bytes;\\n    using RLPReader for bytes;\\n    using RLPReader for RLPReader.RLPItem;\\n\\n    struct BlockHeader {\\n        bytes32 parentHash;\\n        bytes32 ommerHash;\\n        address beneficiary;\\n        bytes32 stateRoot;\\n        bytes32 transactionRoot;\\n        bytes32 receiptsRoot;\\n        uint256 difficulty;\\n        uint256 number;\\n        uint64 gasLimit;\\n        uint64 gasUsed;\\n        uint64 timestamp;\\n        BloomLib.Bloom logsBloom;\\n    }\\n\\n    function hashBlockHeader(BlockHeader memory header) internal pure returns (bytes32) {\\n        bytes[] memory raw = new bytes[](15);\\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(header.parentHash));\\n        raw[1] = RLPWriter.writeBytes(abi.encodePacked(header.ommerHash));\\n        raw[2] = RLPWriter.writeAddress(header.beneficiary);\\n        raw[3] = RLPWriter.writeBytes(abi.encodePacked(header.stateRoot));\\n        raw[4] = RLPWriter.writeBytes(abi.encodePacked(header.transactionRoot));\\n        raw[5] = RLPWriter.writeBytes(abi.encodePacked(header.receiptsRoot));\\n        raw[6] = RLPWriter.writeBytes(abi.encodePacked(header.logsBloom.data));\\n        raw[7] = RLPWriter.writeUint(header.difficulty);\\n        raw[8] = RLPWriter.writeUint(header.number);\\n        raw[9] = RLPWriter.writeUint(uint256(header.gasLimit));\\n        raw[10] = RLPWriter.writeUint(uint256(header.gasUsed));\\n        raw[11] = RLPWriter.writeUint(uint256(header.timestamp));\\n        raw[12] = RLPWriter.writeBytes(\\\"\\\"); // Extra\\n        raw[13] = RLPWriter.writeBytes(abi.encodePacked(bytes32(0))); // MixDigest\\n        raw[14] = RLPWriter.writeBytes(abi.encodePacked(bytes8(0))); // Nonce\\n        return keccak256(RLPWriter.writeList(raw));\\n    }\\n\\n    struct Transaction {\\n        uint64 nonce;\\n        uint256 gasPrice;\\n        uint64 gas;\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        uint256 v;\\n        uint256 r;\\n        uint256 s;\\n    }\\n\\n    function decodeTransaction(bytes memory data) internal pure returns (Transaction memory transaction) {\\n        RLPReader.RLPItem[] memory decoded = data.toRlpItem().toList();\\n        transaction.nonce = uint64(decoded[0].toUint());\\n        transaction.gasPrice = decoded[1].toUint();\\n        transaction.gas = uint64(decoded[2].toUint());\\n        transaction.to = address(uint160(decoded[3].toUint()));\\n        transaction.value = decoded[4].toUint();\\n        transaction.data = decoded[5].toBytes();\\n        transaction.v = decoded[6].toUint();\\n        transaction.r = decoded[7].toUint();\\n        transaction.s = decoded[8].toUint();\\n    }\\n\\n    function hashTransaction(Transaction memory txn) internal pure returns (bytes32) {\\n        bytes[] memory raw = new bytes[](9);\\n        raw[0] = RLPWriter.writeUint(uint256(txn.nonce));\\n        raw[1] = RLPWriter.writeUint(txn.gasPrice);\\n        raw[2] = RLPWriter.writeUint(uint256(txn.gas));\\n        raw[3] = RLPWriter.writeAddress(txn.to);\\n        raw[4] = RLPWriter.writeUint(txn.value);\\n        raw[5] = RLPWriter.writeBytes(txn.data);\\n        raw[6] = RLPWriter.writeUint(txn.v);\\n        raw[7] = RLPWriter.writeUint(txn.r);\\n        raw[8] = RLPWriter.writeUint(txn.s);\\n        return keccak256(RLPWriter.writeList(raw));\\n    }\\n\\n    struct Account {\\n        uint64 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    function decodeAccount(RLPReader.RLPItem memory encoded) internal pure returns (Account memory proof) {\\n        RLPReader.RLPItem[] memory items = encoded.toList();\\n        require(items.length == 4, \\\"Invalid Account\\\");\\n        proof.nonce = uint64(items[0].toUint());\\n        proof.balance = items[1].toUint();\\n        proof.storageRoot = bytes32(items[2].toUint());\\n        proof.codeHash = bytes32(items[3].toUint());\\n    }\\n\\n    function encodeRLP(Account memory account) internal pure returns (bytes memory) {\\n        bytes[] memory raw = new bytes[](4);\\n        raw[0] = RLPWriter.writeUint(uint256(account.nonce));\\n        raw[1] = RLPWriter.writeUint(account.balance);\\n        raw[2] = RLPWriter.writeBytes(abi.encodePacked(account.storageRoot));\\n        raw[3] = RLPWriter.writeBytes(abi.encodePacked(account.codeHash));\\n        return RLPWriter.writeList(raw);\\n    }\\n\\n    function hashLogEntry(address addr, uint256[] memory topics, bytes memory data) internal pure returns (bytes32) {\\n        bytes[] memory topicRaw = new bytes[](topics.length);\\n        for (uint256 i = 0; i < topics.length; i++) {\\n            topicRaw[i] = RLPWriter.writeBytes(abi.encodePacked(bytes32(topics[i])));\\n        }\\n        bytes[] memory raw = new bytes[](3);\\n        raw[0] = RLPWriter.writeAddress(addr);\\n        raw[1] = RLPWriter.writeBytes(RLPWriter.writeList(topicRaw));\\n        raw[2] = RLPWriter.writeBytes(data);\\n        return keccak256(RLPWriter.writeList(raw));\\n    }\\n}\\n\",\"keccak256\":\"0x4f11333325ad94cd5f673e9d375e033534ab48c8497149add79ceacb69124b77\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/verifier/libraries/MemoryLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../libraries/DeserializationLib.sol\\\";\\nimport \\\"../../libraries/MerkleLib.sol\\\";\\nimport \\\"../../libraries/BytesLib.sol\\\";\\nimport \\\"./OneStepProof.sol\\\";\\n\\nlibrary MemoryLib {\\n    using BytesLib for bytes;\\n\\n    function calcCellNum(uint64 offset, uint64 length) internal pure returns (uint64) {\\n        return (offset + length + 31) / 32 - offset / 32;\\n    }\\n\\n    function getMemoryRoot(bytes memory content) internal pure returns (bytes32) {\\n        uint64 cellNum = MemoryLib.calcCellNum(0, uint64(content.length));\\n        bytes32[] memory elements = new bytes32[](cellNum);\\n        for (uint256 i = 0; i < cellNum - 1; i++) {\\n            elements[i] = content.toBytes32(i * 32);\\n        }\\n        elements[cellNum - 1] = content.toBytes32Pad((cellNum - 1) * 32);\\n        return MerkleLib.create_from_many(elements);\\n    }\\n\\n    function decodeAndVerifyMemoryReadProof(\\n        OneStepProof.StateProof memory stateProof,\\n        bytes calldata encoded,\\n        uint64 offset,\\n        uint64 memoryOffset,\\n        uint64 memoryReadLength\\n    ) internal pure returns (uint64, bytes memory) {\\n        if (stateProof.memSize == 0 || memoryReadLength == 0) {\\n            return (offset, new bytes(memoryReadLength));\\n        }\\n        uint64 startCell = memoryOffset / 32;\\n        uint64 cellNum = calcCellNum(memoryOffset, memoryReadLength);\\n        uint64 memoryCell = calcCellNum(0, stateProof.memSize);\\n        OneStepProof.MemoryMerkleProof memory merkleProof;\\n        {\\n            if (memoryCell <= startCell) {\\n                cellNum += startCell - memoryCell;\\n                OneStepProof.MemoryAppendProof memory appendProof;\\n                (offset, appendProof) = OneStepProof.decodeMemoryAppendProof(encoded, offset, cellNum);\\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\\n                stateProof.memRoot =\\n                    MerkleLib.try_append_many(stateProof.memRoot, appendProof.appendCells, merkleProof.proof);\\n                if (memoryOffset + memoryReadLength > stateProof.memSize) {\\n                    stateProof.memSize = (memoryOffset + memoryReadLength + 31) / 32 * 32; // Expand by words\\n                }\\n                bytes memory readContent = new bytes(memoryReadLength);\\n                return (offset, readContent);\\n            }\\n        }\\n        {\\n            if (memoryCell >= startCell + cellNum) {\\n                OneStepProof.MemoryReadProof memory readProof;\\n                (offset, readProof) = OneStepProof.decodeMemoryReadProof(encoded, offset, cellNum);\\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\\n                if (cellNum == 1) {\\n                    MerkleLib.element_exists(stateProof.memRoot, startCell, readProof.cells[0], merkleProof.proof);\\n                    require(\\n                        MerkleLib.element_exists(stateProof.memRoot, startCell, readProof.cells[0], merkleProof.proof),\\n                        \\\"IMP\\\"\\n                    );\\n                } else {\\n                    {\\n                        // avoid stack too deep\\n                        uint256[] memory indices = MerkleLib.get_indices(readProof.cells, merkleProof.proof);\\n                        for (uint64 i = 0; i < cellNum; i++) {\\n                            require(indices[i] == startCell + i, \\\"IMP\\\");\\n                        }\\n                    }\\n                    MerkleLib.elements_exist(stateProof.memRoot, readProof.cells, merkleProof.proof);\\n                    require(MerkleLib.elements_exist(stateProof.memRoot, readProof.cells, merkleProof.proof), \\\"IMP\\\");\\n                }\\n                bytes memory readContent = abi.encodePacked(readProof.cells).slice(memoryOffset % 32, memoryReadLength);\\n                return (offset, readContent);\\n            }\\n        }\\n        uint64 existCellNum = memoryCell - startCell;\\n        OneStepProof.MemoryCombinedReadProof memory combinedReadProof;\\n        (offset, combinedReadProof) =\\n            OneStepProof.decodeMemoryCombinedReadProof(encoded, offset, existCellNum, cellNum - existCellNum);\\n        (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\\n        if (existCellNum == 1) {\\n            stateProof.memRoot = MerkleLib.try_append_many_using_one(\\n                stateProof.memRoot,\\n                startCell,\\n                combinedReadProof.cells[0],\\n                combinedReadProof.appendCells,\\n                merkleProof.proof\\n            );\\n        } else {\\n            {\\n                // avoid stack too deep\\n                uint256[] memory indices = MerkleLib.get_indices(combinedReadProof.cells, merkleProof.proof);\\n                for (uint64 i = 0; i < existCellNum; i++) {\\n                    require(indices[i] == startCell + i, \\\"IMP\\\");\\n                }\\n            }\\n            stateProof.memRoot = MerkleLib.try_append_many_using_many(\\n                stateProof.memRoot, combinedReadProof.cells, combinedReadProof.appendCells, merkleProof.proof\\n            );\\n        }\\n        if (memoryOffset + memoryReadLength > stateProof.memSize) {\\n            stateProof.memSize = (memoryOffset + memoryReadLength + 31) / 32 * 32; // Expand by words\\n        }\\n        bytes memory readContent = abi.encodePacked(combinedReadProof.cells, combinedReadProof.appendCells).slice(\\n            memoryOffset % 32, memoryReadLength\\n        );\\n        return (offset, readContent);\\n    }\\n\\n    function decodeAndVerifyMemoryLikeReadProofNoAppend(\\n        bytes32 memoryLikeRoot,\\n        uint64 memoryLikeSize,\\n        bytes calldata encoded,\\n        uint64 offset,\\n        uint64 memoryLikeOffset,\\n        uint64 memoryLikeReadLength\\n    ) internal pure returns (uint64, bytes memory) {\\n        if (memoryLikeSize == 0 || memoryLikeReadLength == 0) {\\n            return (offset, new bytes(memoryLikeReadLength));\\n        }\\n        uint64 startCell = memoryLikeOffset / 32;\\n        uint64 cellNum = calcCellNum(memoryLikeOffset, memoryLikeReadLength);\\n        uint64 memoryCell = calcCellNum(0, memoryLikeSize);\\n        {\\n            if (memoryCell <= startCell) {\\n                bytes memory readContent;\\n                readContent = new bytes(memoryLikeReadLength);\\n                return (offset, readContent);\\n            }\\n        }\\n        {\\n            if (memoryCell >= startCell + cellNum) {\\n                bytes memory readContent;\\n                OneStepProof.MemoryReadProof memory readProof;\\n                OneStepProof.MemoryMerkleProof memory merkleProof;\\n                (offset, readProof) = OneStepProof.decodeMemoryReadProof(encoded, offset, cellNum);\\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\\n                if (cellNum == 1) {\\n                    MerkleLib.element_exists(memoryLikeRoot, startCell, readProof.cells[0], merkleProof.proof);\\n                    require(\\n                        MerkleLib.element_exists(memoryLikeRoot, startCell, readProof.cells[0], merkleProof.proof),\\n                        \\\"IMP\\\"\\n                    );\\n                } else {\\n                    {\\n                        uint256[] memory indices = MerkleLib.get_indices(readProof.cells, merkleProof.proof);\\n                        for (uint64 i = 0; i < cellNum; i++) {\\n                            require(indices[i] == startCell + i, \\\"IMP2\\\");\\n                        }\\n                    }\\n                    MerkleLib.elements_exist(memoryLikeRoot, readProof.cells, merkleProof.proof);\\n                    require(MerkleLib.elements_exist(memoryLikeRoot, readProof.cells, merkleProof.proof), \\\"IMP\\\");\\n                }\\n                readContent = abi.encodePacked(readProof.cells).slice(memoryLikeOffset % 32, memoryLikeReadLength);\\n                return (offset, readContent);\\n            }\\n        }\\n        uint64 existCellNum = memoryCell - startCell;\\n        OneStepProof.MemoryReadProof memory readProof;\\n        OneStepProof.MemoryMerkleProof memory merkleProof;\\n        (offset, readProof) = OneStepProof.decodeMemoryReadProof(encoded, offset, existCellNum);\\n        (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\\n        if (existCellNum == 1) {\\n            MerkleLib.element_exists(memoryLikeRoot, startCell, readProof.cells[0], merkleProof.proof);\\n            require(MerkleLib.element_exists(memoryLikeRoot, startCell, readProof.cells[0], merkleProof.proof), \\\"IMP\\\");\\n        } else {\\n            {\\n                uint256[] memory indices = MerkleLib.get_indices(readProof.cells, merkleProof.proof);\\n                for (uint64 i = 0; i < cellNum; i++) {\\n                    require(indices[i] == startCell + i, \\\"IMP\\\");\\n                }\\n            }\\n            MerkleLib.elements_exist(memoryLikeRoot, readProof.cells, merkleProof.proof);\\n            require(MerkleLib.elements_exist(memoryLikeRoot, readProof.cells, merkleProof.proof), \\\"IMP\\\");\\n        }\\n        bytes memory padding = new bytes(32 * (cellNum - existCellNum));\\n        bytes memory readContent;\\n        readContent = abi.encodePacked(readProof.cells, padding).slice(memoryLikeOffset % 32, memoryLikeReadLength);\\n        return (offset, readContent);\\n    }\\n\\n    function decodeAndVerifyMemoryWriteProof(\\n        OneStepProof.StateProof memory stateProof,\\n        bytes calldata encoded,\\n        uint64 offset,\\n        uint64 memoryOffset,\\n        uint64 memoryWriteLength\\n    ) internal pure returns (uint64, bytes memory) {\\n        if (memoryWriteLength == 0) {\\n            return (offset, new bytes(0));\\n        }\\n        if (stateProof.memSize == 0) {\\n            // Don't call decodeMemoryWriteProof if memory is empty\\n            // Instead, update memory root and size directly\\n            revert();\\n        }\\n        uint64 startCell = memoryOffset / 32;\\n        uint64 cellNum = calcCellNum(memoryOffset, memoryWriteLength);\\n        uint64 memoryCell = calcCellNum(0, stateProof.memSize);\\n        OneStepProof.MemoryMerkleProof memory merkleProof;\\n\\n        {\\n            if (memoryCell <= startCell) {\\n                cellNum += startCell - memoryCell;\\n                OneStepProof.MemoryAppendProof memory appendProof;\\n                (offset, appendProof) = OneStepProof.decodeMemoryAppendProof(encoded, offset, cellNum);\\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\\n                if (cellNum == 1) {\\n                    stateProof.memRoot =\\n                        MerkleLib.try_append_one(stateProof.memRoot, appendProof.appendCells[0], merkleProof.proof);\\n                } else {\\n                    stateProof.memRoot =\\n                        MerkleLib.try_append_many(stateProof.memRoot, appendProof.appendCells, merkleProof.proof);\\n                }\\n                if (memoryOffset + memoryWriteLength > stateProof.memSize) {\\n                    stateProof.memSize = (memoryOffset + memoryWriteLength + 31) / 32 * 32; // Expand by words\\n                }\\n                bytes memory writeContent =\\n                    abi.encodePacked(appendProof.appendCells).slice(memoryOffset % 32, memoryWriteLength);\\n                return (offset, writeContent);\\n            }\\n        }\\n        {\\n            if (memoryCell >= startCell + cellNum) {\\n                OneStepProof.MemoryWriteProof memory writeProof;\\n                (offset, writeProof) = OneStepProof.decodeMemoryWriteProof(encoded, offset, cellNum);\\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\\n                if (cellNum == 1) {\\n                    stateProof.memRoot = MerkleLib.try_update_one(\\n                        stateProof.memRoot,\\n                        startCell,\\n                        writeProof.cells[0],\\n                        writeProof.updatedCells[0],\\n                        merkleProof.proof\\n                    );\\n                } else {\\n                    {\\n                        // Avoid stack too deep\\n                        uint256[] memory indices = MerkleLib.get_indices(writeProof.cells, merkleProof.proof);\\n                        for (uint64 i = 0; i < cellNum; i++) {\\n                            require(indices[i] == startCell + i, \\\"IMP\\\");\\n                        }\\n                    }\\n                    stateProof.memRoot = MerkleLib.try_update_many(\\n                        stateProof.memRoot, writeProof.cells, writeProof.updatedCells, merkleProof.proof\\n                    );\\n                }\\n                bytes memory writeContent =\\n                    abi.encodePacked(writeProof.updatedCells).slice(memoryOffset % 32, memoryWriteLength);\\n                return (offset, writeContent);\\n            }\\n        }\\n        uint64 existCellNum = memoryCell - startCell;\\n        OneStepProof.MemoryCombinedWriteProof memory combinedWriteProof;\\n        (offset, combinedWriteProof) =\\n            OneStepProof.decodeMemoryCombinedWriteProof(encoded, offset, existCellNum, cellNum - existCellNum);\\n        if (cellNum == 1) {\\n            stateProof.memRoot = MerkleLib.try_update_one_and_append_many(\\n                stateProof.memRoot,\\n                startCell,\\n                combinedWriteProof.cells[0],\\n                combinedWriteProof.updatedCells[0],\\n                combinedWriteProof.appendCells,\\n                merkleProof.proof\\n            );\\n        } else {\\n            {\\n                // avoid stack too deep\\n                uint256[] memory indices = MerkleLib.get_indices(combinedWriteProof.cells, merkleProof.proof);\\n                for (uint64 i = 0; i < cellNum; i++) {\\n                    require(indices[i] == startCell + i, \\\"IMP\\\");\\n                }\\n            }\\n            stateProof.memRoot = MerkleLib.try_update_many_and_append_many(\\n                stateProof.memRoot,\\n                combinedWriteProof.cells,\\n                combinedWriteProof.updatedCells,\\n                combinedWriteProof.appendCells,\\n                merkleProof.proof\\n            );\\n        }\\n        if (memoryOffset + memoryWriteLength > stateProof.memSize) {\\n            stateProof.memSize = (memoryOffset + memoryWriteLength + 31) / 32 * 32; // Expand by words\\n        }\\n        bytes memory writeContent = abi.encodePacked(combinedWriteProof.updatedCells, combinedWriteProof.appendCells)\\n            .slice(memoryOffset % 32, memoryWriteLength);\\n        return (offset, writeContent);\\n    }\\n}\\n\",\"keccak256\":\"0x4dbce765ce53e496d00a664726fc755288ceb0f6867e27de2f8e674db98d589c\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/verifier/libraries/OneStepProof.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../libraries/RLPReader.sol\\\";\\nimport \\\"../../libraries/BytesLib.sol\\\";\\nimport \\\"./BloomLib.sol\\\";\\nimport \\\"./VerificationContext.sol\\\";\\n\\nlibrary OneStepProof {\\n    using BytesLib for bytes;\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for RLPReader.Iterator;\\n    using RLPReader for bytes;\\n    using VerificationContext for VerificationContext.Context;\\n\\n    // [encode rule]\\n    struct StateProof {\\n        uint64 blockNumber; // Block number of current transaction [always]\\n        uint64 transactionIdx; // Transaction index in block [always]\\n        uint16 depth; // Current call depth [always]\\n        uint64 gas; // Gas left in the current call [always]\\n        uint64 refund; // Gas refund accumulated in the current transaction [always]\\n        bytes32 lastDepthHash; // The state hash of the last depth call frame [always]\\n        address contractAddress; // Current executing contract address [depth > 1]\\n        address caller; // Current caller [depth > 1]\\n        uint256 value; // Current call value [depth > 1]\\n        uint8 callFlag; // Current call type [depth > 1]\\n        uint64 out; // Offset of the return data of current call to be copied to the last depth call frame [depth > 1]\\n        uint64 outSize; // Size of the return data of current call to be copied to the last depth call frame [depth > 1]\\n        uint64 pc; // Current program counter [always]\\n        uint8 opCode; // Current opcode to be executed [always]\\n        bytes32 codeHash; // Current executing contract code hash [always]\\n        uint64 stackSize; // Size of the stack [always]\\n        bytes32 stackHash; // Commitment of the stack [always]\\n        uint64 memSize; // Size of the memory [always]\\n        bytes32 memRoot; // Commitment of the memory [memSize > 0]\\n        uint64 inputDataSize; // Size of the call data [depth > 1]\\n        bytes32 inputDataRoot; // Commitment of the return data [depth > 1 && inputDataSize > 0]\\n        uint64 returnDataSize; // Size of the return data [always]\\n        bytes32 returnDataRoot; // Commitment of the return data [returnDataSize > 0]\\n        bytes32 committedGlobalStateRoot; // Commitment of the global MPT state at the start of transaction [always]\\n        bytes32 globalStateRoot; // Commitment of the global MPT state [always]\\n        bytes32 selfDestructAcc; // Commitment of the self destructed contracts in the current transaction [always]\\n        bytes32 logAcc; // Commitment of the logs emitted in the current transaction [always]\\n        bytes32 blockHashRoot; // Commitment of the 256 previous blockhash in the current block [always]\\n        bytes32 accessListRoot; // Commitment of the access list in the current transaction [always]\\n    }\\n\\n    function decodeStateProof(VerificationContext.Context memory ctx, bytes calldata encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, StateProof memory proof)\\n    {\\n        uint64 remainLength = uint64(encoded.length) - offset;\\n        uint64 stateProofLen = 323;\\n        require(remainLength >= stateProofLen, \\\"Proof Underflow (State)\\\");\\n        proof.blockNumber = encoded.toUint64(offset);\\n        proof.transactionIdx = encoded.toUint64(offset + 8);\\n        proof.depth = encoded.toUint16(offset + 16);\\n        proof.gas = encoded.toUint64(offset + 18);\\n        proof.refund = encoded.toUint64(offset + 26);\\n        proof.lastDepthHash = encoded.toBytes32(offset + 34);\\n        offset = offset + 66;\\n        if (proof.depth > 1) {\\n            stateProofLen += 97;\\n            require(remainLength >= stateProofLen, \\\"Proof Underflow (State)\\\");\\n            proof.contractAddress = encoded.toAddress(offset);\\n            proof.caller = encoded.toAddress(offset + 20);\\n            proof.value = encoded.toUint256(offset + 40);\\n            proof.callFlag = encoded.toUint8(offset + 72);\\n            proof.out = encoded.toUint64(offset + 73);\\n            proof.outSize = encoded.toUint64(offset + 81);\\n            offset += 89;\\n        } else {\\n            proof.contractAddress = ctx.getRecipient();\\n            proof.caller = ctx.getOrigin();\\n            proof.value = ctx.getValue();\\n            if (ctx.getRecipient() == address(0)) {\\n                proof.callFlag = 4;\\n            } else {\\n                proof.callFlag = 0;\\n            }\\n        }\\n        proof.pc = encoded.toUint64(offset);\\n        proof.opCode = encoded.toUint8(offset + 8);\\n        proof.codeHash = encoded.toBytes32(offset + 9);\\n        proof.stackSize = encoded.toUint64(offset + 41);\\n        offset += 49;\\n        if (proof.stackSize != 0) {\\n            stateProofLen += 32;\\n            require(remainLength >= stateProofLen, \\\"Proof Underflow (State)\\\");\\n            proof.stackHash = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        proof.memSize = encoded.toUint64(offset);\\n        offset += 8;\\n        if (proof.memSize != 0) {\\n            stateProofLen += 32;\\n            require(remainLength >= stateProofLen, \\\"Proof Underflow (State)\\\");\\n            proof.memRoot = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        if (proof.depth > 1) {\\n            proof.inputDataSize = encoded.toUint64(offset);\\n            offset += 8;\\n            if (proof.inputDataSize != 0) {\\n                stateProofLen += 32;\\n                require(remainLength >= stateProofLen, \\\"Proof Underflow (State)\\\");\\n                proof.inputDataRoot = encoded.toBytes32(offset);\\n                offset += 32;\\n            }\\n        } else {\\n            proof.inputDataSize = ctx.getInputSize();\\n            proof.inputDataRoot = ctx.getInputRoot();\\n        }\\n        proof.returnDataSize = encoded.toUint64(offset);\\n        offset += 8;\\n        if (proof.returnDataSize != 0) {\\n            stateProofLen += 32;\\n            require(remainLength >= stateProofLen, \\\"Proof Underflow (State)\\\");\\n            proof.returnDataRoot = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        proof.committedGlobalStateRoot = encoded.toBytes32(offset);\\n        proof.globalStateRoot = encoded.toBytes32(offset + 32);\\n        proof.selfDestructAcc = encoded.toBytes32(offset + 64);\\n        proof.logAcc = encoded.toBytes32(offset + 96);\\n        proof.blockHashRoot = encoded.toBytes32(offset + 128);\\n        proof.accessListRoot = encoded.toBytes32(offset + 160);\\n        return (offset + 192, proof);\\n    }\\n\\n    function encodeStateProof(StateProof memory proof) internal pure returns (bytes memory encoded) {\\n        encoded = encoded.concat(abi.encodePacked(proof.blockNumber));\\n        encoded = encoded.concat(abi.encodePacked(proof.transactionIdx));\\n        encoded = encoded.concat(abi.encodePacked(proof.depth));\\n        encoded = encoded.concat(abi.encodePacked(proof.gas));\\n        encoded = encoded.concat(abi.encodePacked(proof.refund));\\n        encoded = encoded.concat(abi.encodePacked(proof.lastDepthHash));\\n        if (proof.depth > 1) {\\n            encoded = encoded.concat(abi.encodePacked(proof.contractAddress));\\n            encoded = encoded.concat(abi.encodePacked(proof.caller));\\n            encoded = encoded.concat(abi.encodePacked(proof.value));\\n            encoded = encoded.concat(abi.encodePacked(proof.callFlag));\\n            encoded = encoded.concat(abi.encodePacked(proof.out));\\n            encoded = encoded.concat(abi.encodePacked(proof.outSize));\\n        }\\n        encoded = encoded.concat(abi.encodePacked(proof.pc));\\n        encoded = encoded.concat(abi.encodePacked(proof.opCode));\\n        encoded = encoded.concat(abi.encodePacked(proof.codeHash));\\n        encoded = encoded.concat(abi.encodePacked(proof.stackSize));\\n        if (proof.stackSize != 0) {\\n            encoded = encoded.concat(abi.encodePacked(proof.stackHash));\\n        }\\n        encoded = encoded.concat(abi.encodePacked(proof.memSize));\\n        if (proof.memSize != 0) {\\n            encoded = encoded.concat(abi.encodePacked(proof.memRoot));\\n        }\\n        if (proof.depth > 1) {\\n            encoded = encoded.concat(abi.encodePacked(proof.inputDataSize));\\n            if (proof.inputDataSize != 0) {\\n                encoded = encoded.concat(abi.encodePacked(proof.inputDataRoot));\\n            }\\n        }\\n        encoded = encoded.concat(abi.encodePacked(proof.returnDataSize));\\n        if (proof.returnDataSize != 0) {\\n            encoded = encoded.concat(abi.encodePacked(proof.returnDataRoot));\\n        }\\n        encoded = encoded.concat(abi.encodePacked(proof.committedGlobalStateRoot));\\n        encoded = encoded.concat(abi.encodePacked(proof.globalStateRoot));\\n        encoded = encoded.concat(abi.encodePacked(proof.selfDestructAcc));\\n        encoded = encoded.concat(abi.encodePacked(proof.logAcc));\\n        encoded = encoded.concat(abi.encodePacked(proof.blockHashRoot));\\n        encoded = encoded.concat(abi.encodePacked(proof.accessListRoot));\\n    }\\n\\n    function hashStateProof(StateProof memory proof) internal pure returns (bytes32) {\\n        if (proof.depth == 0) {\\n            // When returning/reverting from depth 1, we can't directly return an InterStateProof\\n            // Therefore we reuse some of the fields in the IntraStateProof to store an InterStateProof\\n            // The field mappings are as follows:\\n            InterStateProof memory interProof;\\n            interProof.blockNumber = proof.blockNumber;\\n            interProof.transactionIdx = proof.transactionIdx;\\n            interProof.globalStateRoot = proof.globalStateRoot;\\n            interProof.cumulativeGasUsed = proof.value;\\n            interProof.blockGasUsed = uint256(proof.lastDepthHash);\\n            interProof.blockHashRoot = proof.blockHashRoot;\\n            interProof.transactionTrieRoot = proof.selfDestructAcc;\\n            interProof.receiptTrieRoot = proof.logAcc;\\n            return hashInterStateProof(interProof);\\n        }\\n        return keccak256(encodeStateProof(proof));\\n    }\\n\\n    struct InterStateProof {\\n        uint64 blockNumber;\\n        uint64 transactionIdx;\\n        bytes32 globalStateRoot;\\n        uint256 cumulativeGasUsed;\\n        uint256 blockGasUsed;\\n        bytes32 blockHashRoot;\\n        bytes32 transactionTrieRoot;\\n        bytes32 receiptTrieRoot;\\n        BloomLib.Bloom logsBloom;\\n    }\\n\\n    function decodeInterStateProof(bytes calldata encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, InterStateProof memory proof)\\n    {\\n        require(encoded.length - offset >= 464, \\\"Proof Underflow (Inter)\\\");\\n        proof.blockNumber = encoded.toUint64(offset);\\n        proof.transactionIdx = encoded.toUint64(offset + 8);\\n        proof.globalStateRoot = encoded.toBytes32(offset + 16);\\n        proof.cumulativeGasUsed = encoded.toUint64(offset + 48);\\n        proof.blockGasUsed = encoded.toUint64(offset + 80);\\n        proof.blockHashRoot = encoded.toBytes32(offset + 112);\\n        proof.transactionTrieRoot = encoded.toBytes32(offset + 144);\\n        proof.receiptTrieRoot = encoded.toBytes32(offset + 176);\\n        proof.logsBloom = BloomLib.decodeBloom(encoded, offset + 208);\\n        return (offset + 464, proof);\\n    }\\n\\n    function encodeInterStateProof(InterStateProof memory proof) internal pure returns (bytes memory encoded) {\\n        encoded = encoded.concat(abi.encodePacked(proof.blockNumber));\\n        encoded = encoded.concat(abi.encodePacked(proof.transactionIdx));\\n        encoded = encoded.concat(abi.encodePacked(proof.globalStateRoot));\\n        encoded = encoded.concat(abi.encodePacked(proof.cumulativeGasUsed));\\n        encoded = encoded.concat(abi.encodePacked(proof.blockGasUsed));\\n        encoded = encoded.concat(abi.encodePacked(proof.blockHashRoot));\\n        encoded = encoded.concat(abi.encodePacked(proof.transactionTrieRoot));\\n        encoded = encoded.concat(abi.encodePacked(proof.receiptTrieRoot));\\n        encoded = encoded.concat(abi.encodePacked(proof.logsBloom.data));\\n    }\\n\\n    function hashInterStateProof(InterStateProof memory proof) internal pure returns (bytes32) {\\n        return keccak256(encodeInterStateProof(proof));\\n    }\\n\\n    struct BlockStateProof {\\n        uint64 blockNumber;\\n        bytes32 globalStateRoot;\\n        uint256 cumulativeGasUsed;\\n        bytes32 blockHashRoot;\\n    }\\n\\n    function decodeBlockStateProof(bytes calldata encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, BlockStateProof memory proof)\\n    {\\n        require(encoded.length - offset >= 104, \\\"Proof Underflow (Block)\\\");\\n        proof.blockNumber = encoded.toUint64(offset);\\n        proof.globalStateRoot = encoded.toBytes32(offset + 8);\\n        proof.cumulativeGasUsed = encoded.toUint64(offset + 40);\\n        proof.blockHashRoot = encoded.toBytes32(offset + 72);\\n        return (offset + 104, proof);\\n    }\\n\\n    function encodeBlockStateProof(BlockStateProof memory proof) internal pure returns (bytes memory encoded) {\\n        encoded = encoded.concat(abi.encodePacked(proof.blockNumber));\\n        encoded = encoded.concat(abi.encodePacked(proof.globalStateRoot));\\n        encoded = encoded.concat(abi.encodePacked(proof.cumulativeGasUsed));\\n        encoded = encoded.concat(abi.encodePacked(proof.blockHashRoot));\\n    }\\n\\n    function hashBlockStateProof(BlockStateProof memory proof) internal pure returns (bytes32) {\\n        return keccak256(encodeBlockStateProof(proof));\\n    }\\n\\n    struct CodeProof {\\n        uint64 ptr;\\n        uint64 size;\\n    }\\n\\n    function decodeCodeProof(bytes calldata encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, CodeProof memory proof)\\n    {\\n        require(encoded.length - offset >= 8, \\\"Proof Underflow (Code)\\\");\\n        // Decode bytecode size in bytes\\n        uint64 contentSize = encoded.toUint64(offset);\\n        require(encoded.length - offset >= 8 + contentSize, \\\"Proof Underflow (Code)\\\");\\n        offset += 8;\\n        proof.ptr = offset;\\n        proof.size = contentSize;\\n        return (offset + contentSize, proof);\\n    }\\n\\n    function getOpCodeAt(CodeProof memory proof, bytes calldata encoded, uint64 idx) internal pure returns (uint8) {\\n        if (idx >= proof.size) {\\n            return 0;\\n        }\\n        return uint8(encoded[proof.ptr + idx]);\\n    }\\n\\n    function getCodeSlice(CodeProof memory proof, bytes calldata encoded, uint64 offset, uint64 size)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (offset + size > proof.size) {\\n            return encoded.slice(proof.ptr + offset, size).concat(new bytes(size - (proof.size - offset)));\\n        }\\n        return encoded.slice(proof.ptr + offset, size);\\n    }\\n\\n    function hashCodeProof(CodeProof memory proof, bytes calldata encoded) internal pure returns (bytes32) {\\n        return keccak256(encoded[proof.ptr:proof.ptr + proof.size]);\\n    }\\n\\n    struct StackProof {\\n        // The elements popped in the step\\n        uint256[] pops;\\n        // The stack hash after popping above elements\\n        bytes32 stackHashAfterPops;\\n    }\\n\\n    function decodeStackProof(bytes calldata encoded, uint64 offset, uint64 popNum)\\n        internal\\n        pure\\n        returns (uint64, StackProof memory proof)\\n    {\\n        if (popNum == 0) {\\n            // No StackProof needed for popNum == 0\\n            return (offset, proof);\\n        }\\n        require(encoded.length - offset >= 32 * (popNum + 1), \\\"Proof Underflow (Stack)\\\");\\n        proof.pops = new uint256[](popNum);\\n        // Decode popped elements\\n        for (uint64 i = 0; i < popNum; i++) {\\n            proof.pops[i] = encoded.toUint256(offset);\\n            offset += 32;\\n        }\\n        // Decode stackHashAfterPops\\n        proof.stackHashAfterPops = encoded.toBytes32(offset);\\n        offset += 32;\\n        return (offset, proof);\\n    }\\n\\n    function encodeStackProof(StackProof memory proof) internal pure returns (bytes memory encoded) {\\n        for (uint64 i = 0; i < proof.pops.length; i++) {\\n            encoded = encoded.concat(abi.encodePacked(proof.pops[i]));\\n        }\\n        encoded = encoded.concat(abi.encodePacked(proof.stackHashAfterPops));\\n    }\\n\\n    struct MemoryMerkleProof {\\n        bytes32[] proof;\\n    }\\n\\n    function decodeMemoryMerkleProof(bytes calldata encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, MemoryMerkleProof memory proof)\\n    {\\n        require(encoded.length - offset >= 8, \\\"Proof Underflow\\\");\\n        uint64 len = encoded.toUint64(offset);\\n        offset += 8;\\n        require(encoded.length - offset >= 32 * len, \\\"Proof Underflow\\\");\\n        proof.proof = new bytes32[](len);\\n        for (uint64 i = 0; i < len; i++) {\\n            proof.proof[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        return (offset, proof);\\n    }\\n\\n    struct MemoryReadProof {\\n        bytes32[] cells;\\n    }\\n\\n    function decodeMemoryReadProof(bytes calldata encoded, uint64 offset, uint64 cellNum)\\n        internal\\n        pure\\n        returns (uint64, MemoryReadProof memory proof)\\n    {\\n        require(encoded.length - offset >= 32 * cellNum, \\\"Proof Underflow\\\");\\n        proof.cells = new bytes32[](cellNum);\\n        for (uint64 i = 0; i < cellNum; i++) {\\n            proof.cells[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        return (offset, proof);\\n    }\\n\\n    struct MemoryWriteProof {\\n        bytes32[] cells;\\n        bytes32[] updatedCells;\\n    }\\n\\n    function decodeMemoryWriteProof(bytes calldata encoded, uint64 offset, uint64 cellNum)\\n        internal\\n        pure\\n        returns (uint64, MemoryWriteProof memory proof)\\n    {\\n        require(encoded.length - offset >= 64 * cellNum, \\\"Proof Underflow\\\");\\n        proof.cells = new bytes32[](cellNum);\\n        for (uint64 i = 0; i < cellNum; i++) {\\n            proof.cells[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        proof.updatedCells = new bytes32[](cellNum);\\n        for (uint64 i = 0; i < cellNum; i++) {\\n            proof.updatedCells[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        return (offset, proof);\\n    }\\n\\n    struct MemoryAppendProof {\\n        bytes32[] appendCells;\\n    }\\n\\n    function decodeMemoryAppendProof(bytes calldata encoded, uint64 offset, uint64 cellNum)\\n        internal\\n        pure\\n        returns (uint64, MemoryAppendProof memory proof)\\n    {\\n        require(encoded.length - offset >= 32 * cellNum, \\\"Proof Underflow\\\");\\n        proof.appendCells = new bytes32[](cellNum);\\n        for (uint64 i = 0; i < cellNum; i++) {\\n            proof.appendCells[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        return (offset, proof);\\n    }\\n\\n    struct MemoryCombinedReadProof {\\n        bytes32[] cells;\\n        bytes32[] appendCells;\\n    }\\n\\n    function decodeMemoryCombinedReadProof(bytes calldata encoded, uint64 offset, uint64 cellNum, uint64 appendCellNum)\\n        internal\\n        pure\\n        returns (uint64, MemoryCombinedReadProof memory proof)\\n    {\\n        require(encoded.length - offset >= 32 * (cellNum + appendCellNum), \\\"Proof Underflow\\\");\\n        proof.cells = new bytes32[](cellNum);\\n        for (uint64 i = 0; i < cellNum; i++) {\\n            proof.cells[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        proof.appendCells = new bytes32[](appendCellNum);\\n        for (uint64 i = 0; i < appendCellNum; i++) {\\n            proof.appendCells[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        return (offset, proof);\\n    }\\n\\n    struct MemoryCombinedWriteProof {\\n        bytes32[] cells;\\n        bytes32[] updatedCells;\\n        bytes32[] appendCells;\\n    }\\n\\n    function decodeMemoryCombinedWriteProof(bytes calldata encoded, uint64 offset, uint64 cellNum, uint64 appendCellNum)\\n        internal\\n        pure\\n        returns (uint64, MemoryCombinedWriteProof memory proof)\\n    {\\n        require(encoded.length - offset >= 32 * (2 * cellNum + appendCellNum), \\\"Proof Underflow\\\");\\n        proof.cells = new bytes32[](cellNum);\\n        for (uint64 i = 0; i < cellNum; i++) {\\n            proof.cells[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        proof.updatedCells = new bytes32[](cellNum);\\n        for (uint64 i = 0; i < cellNum; i++) {\\n            proof.updatedCells[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        proof.appendCells = new bytes32[](appendCellNum);\\n        for (uint64 i = 0; i < appendCellNum; i++) {\\n            proof.appendCells[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        return (offset, proof);\\n    }\\n\\n    // For MPT proof, receipt proof\\n    struct RLPProof {\\n        RLPReader.RLPItem proof;\\n    }\\n\\n    function decodeRLPProof(bytes calldata encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, RLPProof memory proof)\\n    {\\n        require(encoded.length - offset >= 8, \\\"Proof Underflow\\\");\\n        uint64 len = encoded.toUint64(offset);\\n        offset += 8;\\n        require(encoded.length - offset >= len, \\\"Proof Underflow\\\");\\n        proof.proof = encoded.slice(offset, len).toRlpItem();\\n        return (offset + len, proof);\\n    }\\n\\n    struct BlockHashProof {\\n        bytes32 blockHash;\\n    }\\n\\n    function decodeBlockHashProof(bytes calldata encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, BlockHashProof memory proof)\\n    {\\n        require(encoded.length - offset >= 32, \\\"Proof Underflow\\\");\\n        proof.blockHash = encoded.toBytes32(offset);\\n        return (offset + 32, proof);\\n    }\\n\\n    struct BlockHashMerkleProof {\\n        uint64 path;\\n        bytes32[] proof;\\n    }\\n\\n    function decodeBlockHashMerkleProof(bytes memory encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, BlockHashMerkleProof memory proof)\\n    {\\n        require(encoded.length - offset >= 9, \\\"Proof Underflow\\\");\\n        proof.path = encoded.toUint64(offset);\\n        uint8 len = encoded.toUint8(offset + 8);\\n        offset += 9;\\n        require(encoded.length - offset >= 32 * len, \\\"Proof Underflow\\\");\\n        proof.proof = new bytes32[](len);\\n        for (uint64 i = 0; i < len; i++) {\\n            proof.proof[i] = encoded.toBytes32(offset);\\n            offset += 32;\\n        }\\n        return (offset, proof);\\n    }\\n\\n    struct LogProof {\\n        bytes32 accumulateHash;\\n        BloomLib.Bloom bloom;\\n    }\\n\\n    function decodeLogProof(bytes calldata encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, LogProof memory proof)\\n    {\\n        require(encoded.length - offset >= 288, \\\"Proof Underflow\\\");\\n        proof.accumulateHash = encoded.toBytes32(offset);\\n        proof.bloom = BloomLib.decodeBloom(encoded, offset + 32);\\n        return (offset + 288, proof);\\n    }\\n\\n    function hashLogProof(LogProof memory proof) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(proof.accumulateHash, proof.bloom.data));\\n    }\\n\\n    struct SelfDestructSetProof {\\n        address[] contracts;\\n    }\\n\\n    function decodeSelfDestructSetProof(bytes calldata encoded, uint64 offset)\\n        internal\\n        pure\\n        returns (uint64, SelfDestructSetProof memory proof)\\n    {\\n        require(encoded.length - offset >= 8, \\\"Proof Underflow\\\");\\n        uint64 len = encoded.toUint64(offset);\\n        offset += 8;\\n        require(encoded.length - offset >= 20 * len, \\\"Proof Underflow\\\");\\n        proof.contracts = new address[](len);\\n        for (uint64 i = 0; i < len; i++) {\\n            proof.contracts[i] = encoded.toAddress(offset);\\n            offset += 20;\\n        }\\n        return (offset, proof);\\n    }\\n}\\n\",\"keccak256\":\"0x62ab225aa64668d73fe77eb0cd364240958325d6a7b985989069e198f5f2506b\",\"license\":\"Apache-2.0\"},\"contracts/L1/fraud-proof/verifier/libraries/VerificationContext.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2022, Specular contributors\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../libraries/DeserializationLib.sol\\\";\\nimport \\\"../../libraries/BytesLib.sol\\\";\\nimport \\\"../../libraries/MerkleLib.sol\\\";\\n\\nimport \\\"./MemoryLib.sol\\\";\\nimport \\\"./EVMTypesLib.sol\\\";\\n\\nlibrary VerificationContext {\\n    using BytesLib for bytes;\\n    using EVMTypesLib for EVMTypesLib.Transaction;\\n\\n    struct Context {\\n        address coinbase;\\n        uint256 timestamp;\\n        uint256 number;\\n        address origin;\\n        EVMTypesLib.Transaction transaction;\\n        bytes32 inputRoot;\\n        bytes32 txHash;\\n    }\\n\\n    function newContext(bytes calldata proof) internal view returns (Context memory ctx) {\\n//        inbox.verifyTxInclusion(proof);\\n//        ctx.coinbase = inbox.sequencerAddress();\\n        ctx.coinbase = address(0); // TODO FIXME\\n        uint256 offset = 0;\\n        uint256 txDataLength;\\n        (offset, ctx.origin) = DeserializationLib.deserializeAddress(proof, offset);\\n        (offset, ctx.number) = DeserializationLib.deserializeUint256(proof, offset);\\n        (offset, ctx.timestamp) = DeserializationLib.deserializeUint256(proof, offset);\\n        (offset, txDataLength) = DeserializationLib.deserializeUint256(proof, offset);\\n        bytes memory txData = bytes(proof[offset:txDataLength]);\\n        ctx.transaction = EVMTypesLib.decodeTransaction(txData);\\n    }\\n\\n    function getCoinbase(Context memory ctx) internal pure returns (address) {\\n        return ctx.coinbase;\\n    }\\n\\n    function getTimestamp(Context memory ctx) internal pure returns (uint256) {\\n        return ctx.timestamp;\\n    }\\n\\n    function getBlockNumber(Context memory ctx) internal pure returns (uint256) {\\n        return ctx.number;\\n    }\\n\\n    function getDifficulty(Context memory) internal pure returns (uint256) {\\n        return 1;\\n    }\\n\\n    function getGasLimit(Context memory) internal pure returns (uint64) {\\n        return 80000000;\\n    }\\n\\n    function getChainID(Context memory) internal pure returns (uint256) {\\n        return 13527;\\n    }\\n\\n    // Transaction\\n    function getOrigin(Context memory ctx) internal pure returns (address) {\\n        return ctx.origin;\\n    }\\n\\n    function getRecipient(Context memory ctx) internal pure returns (address) {\\n        return ctx.transaction.to;\\n    }\\n\\n    function getValue(Context memory ctx) internal pure returns (uint256) {\\n        return ctx.transaction.value;\\n    }\\n\\n    function getGas(Context memory ctx) internal pure returns (uint64) {\\n        return ctx.transaction.gas;\\n    }\\n\\n    function getGasPrice(Context memory ctx) internal pure returns (uint256) {\\n        return ctx.transaction.gasPrice;\\n    }\\n\\n    function getInput(Context memory ctx) internal pure returns (bytes memory) {\\n        return ctx.transaction.data;\\n    }\\n\\n    function getInputSize(Context memory ctx) internal pure returns (uint64) {\\n        return uint64(ctx.transaction.data.length);\\n    }\\n\\n    function getInputRoot(Context memory ctx) internal pure returns (bytes32) {\\n        if (ctx.inputRoot == 0x0) {\\n            ctx.inputRoot = MemoryLib.getMemoryRoot(ctx.transaction.data);\\n        }\\n        return ctx.inputRoot;\\n    }\\n\\n    function getTxHash(Context memory ctx) internal pure returns (bytes32) {\\n        if (ctx.txHash == 0x0) {\\n            ctx.txHash = ctx.transaction.hashTransaction();\\n        }\\n        return ctx.transaction.hashTransaction();\\n    }\\n}\\n\",\"keccak256\":\"0x6d6c6af5ddc7d9af49703ddbb96358a952537ecaec3a1d32ab0272dddf419017\",\"license\":\"Apache-2.0\"},\"contracts/libraries/codec/Lib_BVMCodec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title Lib_BVMCodec\\n */\\nlibrary Lib_BVMCodec {\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes signature;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex; // QUEUED TX ONLY\\n        uint256 timestamp; // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData; // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 transactionHash;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Encodes a standard BVM transaction.\\n     * @param _transaction BVM transaction to encode.\\n     * @return Encoded transaction bytes.\\n     */\\n    function encodeTransaction(Transaction memory _transaction)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodePacked(\\n                _transaction.timestamp,\\n                _transaction.blockNumber,\\n                _transaction.l1QueueOrigin,\\n                _transaction.l1TxOrigin,\\n                _transaction.entrypoint,\\n                _transaction.gasLimit,\\n                _transaction.data\\n            );\\n    }\\n\\n    /**\\n     * Hashes a standard BVM transaction.\\n     * @param _transaction BVM transaction to encode.\\n     * @return Hashed transaction\\n     */\\n    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return Account state struct.\\n     */\\n    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return\\n            EVMAccount({\\n                nonce: Lib_RLPReader.readUint256(accountState[0]),\\n                balance: Lib_RLPReader.readUint256(accountState[1]),\\n                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n                codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n            });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return Hash of the header.\\n     */\\n    function hashBatchHeader(Lib_BVMCodec.ChainBatchHeader memory _batchHeader)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    _batchHeader.batchRoot,\\n                    _batchHeader.batchSize,\\n                    _batchHeader.prevTotalElements,\\n                    _batchHeader.signature,\\n                    _batchHeader.extraData\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xc74431c3b4f435e5581dc786892a5cb1674b717a03eaa4a79a4987ee19700f99\",\"license\":\"MIT\"},\"contracts/libraries/resolver/Lib_AddressManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping(bytes32 => address) private addresses;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\",\"keccak256\":\"0xcde9b29429d512c549f7c1b8a033f161fa71c18cda08b241748663854196ae14\",\"license\":\"MIT\"},\"contracts/libraries/resolver/Lib_AddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public libAddressManager;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(address _libAddressManager) {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Resolves the address associated with a given name.\\n     * @param _name Name to resolve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function resolve(string memory _name) public view returns (address) {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\",\"keccak256\":\"0x515c4db671a28e2fe180201f6d11c0208c05f582ca3489fb6b8e81c27659bc62\",\"license\":\"MIT\"},\"contracts/libraries/rlp/Lib_RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.LIST_ITEM, \\\"Invalid RLP list value.\\\");\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(itemCount < MAX_LIST_LENGTH, \\\"Provided RLP list exceeds max list length.\\\");\\n\\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\\n            );\\n\\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\\n        return readList(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes value.\\\");\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        return readBytes(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(bytes memory _in) internal pure returns (string memory) {\\n        return readString(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\\n        require(_in.length <= 33, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\\n        return readBytes32(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\\n        return readUint256(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\\n        require(_in.length == 1, \\\"Invalid RLP boolean value.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        require(out == 0 || out == 1, \\\"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\\\");\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(bytes memory _in) internal pure returns (bool) {\\n        return readBool(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(_in.length == 21, \\\"Invalid RLP address value.\\\");\\n\\n        return address(uint160(readUint256(_in)));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(bytes memory _in) internal pure returns (address) {\\n        return readAddress(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        return _copy(_in);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(_in.length > 0, \\\"RLP item cannot be null.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            // slither-disable-next-line variable-scope\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(_in.length > strLen, \\\"Invalid RLP short string.\\\");\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(_in.length > lenOfStrLen, \\\"Invalid RLP long string length.\\\");\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\\n            }\\n\\n            require(_in.length > lenOfStrLen + strLen, \\\"Invalid RLP long string.\\\");\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            // slither-disable-next-line variable-scope\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(_in.length > listLen, \\\"Invalid RLP short list.\\\");\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(_in.length > lenOfListLen, \\\"Invalid RLP long list length.\\\");\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\\n            }\\n\\n            require(_in.length > lenOfListLen + listLen, \\\"Invalid RLP long list.\\\");\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    ) private pure returns (bytes memory) {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - (_length % 32)) - 1;\\n        }\\n\\n        assembly {\\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n        }\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\",\"keccak256\":\"0xd794d1b32c6e31d40e2526b5e519de1b4e8d14d6933889f9b916e69c5d1848c6\",\"license\":\"MIT\"},\"contracts/libraries/rlp/Lib_RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    ) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\",\"keccak256\":\"0x215b90672ce126effc3f2df61ca0cdf52d2b1cc9be602877e637829b0bf229fd\",\"license\":\"MIT\"},\"contracts/libraries/utils/Lib_Bytes32Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \\\"true.\\\"\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as a boolean.\\n     */\\n    function toBool(bytes32 _in) internal pure returns (bool) {\\n        return _in != 0;\\n    }\\n\\n    /**\\n     * Converts a boolean to a bytes32 value.\\n     * @param _in Input boolean value.\\n     * @return Boolean as a bytes32.\\n     */\\n    function fromBool(bool _in) internal pure returns (bytes32) {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    /**\\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as an address.\\n     */\\n    function toAddress(bytes32 _in) internal pure returns (address) {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    /**\\n     * Converts an address to a bytes32.\\n     * @param _in Input address value.\\n     * @return Address as a bytes32.\\n     */\\n    function fromAddress(address _in) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_in)));\\n    }\\n}\\n\",\"keccak256\":\"0xf2d1a526f2529e51fc2fffccf093c1691e291cbbb6de8a3da7d7f80024a9a234\",\"license\":\"MIT\"},\"contracts/libraries/utils/Lib_BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0xc39ee13f97e4ccfbc72a5aac571deb3c1aff882fca2dd18be794d43ac5de0a30\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50600080546001600160a01b03191690556200002c62000032565b62000101565b600054600160a81b900460ff1615620000a15760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff600160a01b90910481161015620000ff576000805460ff60a01b191660ff60a01b17905560405160ff81527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b615d9e80620001116000396000f3fe608060405234801561001057600080fd5b50600436106102745760003560e01c80636aabc35011610151578063b553ee84116100c3578063cfc5901d11610087578063cfc5901d14610641578063de574efc14610654578063e03c863214610667578063f2fde38b14610687578063fa7803e61461069a578063fe2ba848146106ad57600080fd5b8063b553ee84146105f7578063b6da898f14610600578063c8525c3e14610613578063c94b584714610626578063c97a59191461062e57600080fd5b80638c669739116101155780638c6697391461052a5780638da5cb5b146105325780639168ae72146105455780639efbea23146105c8578063a56ba93b146105db578063aca9a518146105e457600080fd5b80636aabc350146104c95780636c8b052a146104f257806371129559146104fb5780637acb7757146105045780638821b2ae1461051757600080fd5b806330b26075116101ea578063461a4478116101ae578063461a44781461043957806349cd30041461044c5780634d26732d1461045f57806351ed6a30146104675780636177fd181461047a5780636a368561146104b657600080fd5b806330b26075146103fa57806337d1fbdd146104025780633ccfd60b1461041557806340d9224b1461041d57806345e38b641461043057600080fd5b80632aa234f61161023c5780632aa234f61461036e5780632b7ac3f3146103815780632e17de78146103945780632f06d1b0146103a75780632f30cabd146103ba578063300a7161146103da57600080fd5b80630e456acf14610279578063107035a4146102f05780632052465e146103075780632906040e14610339578063299ca47814610343575b600080fd5b607754607854607954607a54607b546102ac9460ff8116946001600160a01b036101009092048216949082169391169186565b6040805196151587526001600160a01b0395861660208801529385169386019390935292166060840152608083019190915260a082015260c0015b60405180910390f35b6102f960715481565b6040519081526020016102e7565b61031a610315366004613bad565b6106c0565b604080516001600160a01b0390931683526020830191909152016102e7565b6103416106f8565b005b600054610356906001600160a01b031681565b6040516001600160a01b0390911681526020016102e7565b61035661037c366004613bad565b6109a8565b600554610356906001600160a01b031681565b6103416103a2366004613bad565b6109d2565b6103566103b5366004613bd7565b610b52565b6102f96103c8366004613c31565b60756020526000908152604090205481565b6102f96103e8366004613c31565b60396020526000908152604090205481565b6103416111cc565b610356610410366004613bad565b611518565b610341611528565b600454610356906001600160a01b031681565b6102f960015481565b610356610447366004613d0a565b611618565b61034161045a366004613da7565b611699565b6002546102f9565b600354610356906001600160a01b031681565b6104a6610488366004613c31565b6001600160a01b031660009081526073602052604090205460ff1690565b60405190151581526020016102e7565b6103416104c4366004613e61565b6118c6565b6103566104d7366004613c31565b6074602052600090815260409020546001600160a01b031681565b6102f960725481565b6102f960025481565b610341610512366004613ea3565b6119c0565b610341610525366004613bad565b611dac565b610341611f3a565b603854610356906001600160a01b031681565b610592610553366004613c31565b6073602052600090815260409020805460018201546002830154600384015460049094015460ff90931693919290916001600160a01b03908116911685565b6040805195151586526020860194909452928401919091526001600160a01b03908116606084015216608082015260a0016102e7565b6103416105d6366004613e61565b611f7d565b6102f960705481565b6103416105f2366004613e61565b612159565b6102f9606f5481565b61034161060e366004613ed3565b612335565b610341610621366004613e61565b6126f6565b6102f96127ea565b61034161063c366004613ef5565b61286f565b61034161064f366004614003565b612c57565b610341610662366004614053565b612da3565b6102f9610675366004613c31565b603b6020526000908152604090205481565b610341610695366004613c31565b6131f0565b6103416106a836600461410c565b613288565b6103416106bb366004613c31565b6134ca565b607681815481106106d057600080fd5b6000918252602090912060029091020180546001909101546001600160a01b03909116915082565b336000908152607460205260409020546001600160a01b03166107365760405162461bcd60e51b815260040161072d9061413a565b60405180910390fd5b607154606f54106107815760405162461bcd60e51b81526020600482015260156024820152742737aab73932b9b7b63b32b220b9b9b2b93a34b7b760591b604482015260640161072d565b6000607254116107be5760405162461bcd60e51b81526020600482015260086024820152672737a9ba30b5b2b960c11b604482015260640161072d565b6000606f5460016107cf9190614175565b60048054604051638286227560e01b81529293506001600160a01b0316916382862275916108039185910190815260200190565b60206040518083038186803b15801561081b57600080fd5b505afa15801561082f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610853919061418d565b42101561089b5760405162461bcd60e51b81526020600482015260166024820152754368616c6c656e6765506572696f6450656e64696e6760501b604482015260640161072d565b6070546004805460405163030b947760e41b81529182018490526001600160a01b0316906330b947709060240160206040518083038186803b1580156108e057600080fd5b505afa1580156108f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610918919061418d565b146109555760405162461bcd60e51b815260206004820152600d60248201526c125b9d985b1a5914185c995b9d609a1b604482015260640161072d565b606f8054906000610965836141a6565b9091555050606f5460708190556040519081527f453430d123684340024ae0a229704bdab39c93dc48bb5a0b4bc83142d95d48ef9060200160405180910390a150565b603a81815481106109b857600080fd5b6000918252602090912001546001600160a01b0316905081565b6109db3361361b565b33600090815260736020526040902060705460028201541115610a405760405162461bcd60e51b815260206004820152601c60248201527f5374616b65644f6e556e636f6e6669726d6564417373657274696f6e00000000604482015260640161072d565b6002548160010154610a5291906141c1565b821115610a955760405162461bcd60e51b8152602060048201526011602482015270496e73756666696369656e745374616b6560781b604482015260640161072d565b81816001016000828254610aa991906141c1565b909155505060035460405163a9059cbb60e01b8152336004820152602481018490526001600160a01b039091169063a9059cbb90604401602060405180830381600087803b158015610afa57600080fd5b505af1158015610b0e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b3291906141d8565b610b4e5760405162461bcd60e51b815260040161072d906141fa565b5050565b336000908152607460205260408120546001600160a01b0316610b875760405162461bcd60e51b815260040161072d9061413a565b81356020830135808210610bca5760405162461bcd60e51b815260206004820152600a6024820152692bb937b733a7b93232b960b11b604482015260640161072d565b607154811115610c125760405162461bcd60e51b81526020600482015260136024820152722ab7383937b837b9b2b220b9b9b2b93a34b7b760691b604482015260640161072d565b8160705410610c635760405162461bcd60e51b815260206004820152601860248201527f417373657274696f6e416c72656164795265736f6c7665640000000000000000604482015260640161072d565b6004805460405163030b947760e41b81529182018490526000916001600160a01b03909116906330b947709060240160206040518083038186803b158015610caa57600080fd5b505afa158015610cbe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ce2919061418d565b6004805460405163030b947760e41b81529293506001600160a01b0316916330b9477091610d169186910190815260200190565b60206040518083038186803b158015610d2e57600080fd5b505afa158015610d42573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d66919061418d565b8114610da65760405162461bcd60e51b815260206004820152600f60248201526e111a5999995c995b9d14185c995b9d608a1b604482015260640161072d565b6000610db56020880188613c31565b90506000610dc96040890160208a01613c31565b9050806001600160a01b0316826001600160a01b03161415610e3b5760405162461bcd60e51b815260206004820152602560248201527f646566656e64657220616e64206368616c6c656e6765206d757374206e6f7420604482015264195c5d585b60da1b606482015260840161072d565b6001600160a01b038083166000908152607460205260408082205484841683529120549082169116610e6c8261366f565b610e758161366f565b6000604051610e8390613b5a565b604051809103906000f080158015610e9f573d6000803e3d6000fd5b506001600160a01b038084166000908152607360209081526040808320600490810180548688166001600160a01b031991821681179092558a871686528386209092018054831682179055825160c0810184529485529284018390528a8516848301819052948a1660608501819052608085018f905260a09094018d905260778054610100949094026001600160a81b031990941693909317909255607880548316909417909355607980549091169091179055607a8a9055607b8990555190915081907fd0ebe74b4f7d89a9b0fdc9d95f887a7b925c6c7300b5c4b2c3304d97925840fa90610fa4908b9084909182526001600160a01b0316602082015260400190565b60405180910390a160048054604051632b27e93b60e01b81529182018990526000916001600160a01b0390911690632b27e93b9060240160206040518083038186803b158015610ff357600080fd5b505afa158015611007573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061102b919061418d565b60048054604051632a411f3360e11b81529182018b90529192506000916001600160a01b0316906354823e669060240160206040518083038186803b15801561107357600080fd5b505afa158015611087573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110ab919061418d565b60048054604051632a411f3360e11b81529182018e90529192506000916001600160a01b0316906354823e669060240160206040518083038186803b1580156110f357600080fd5b505afa158015611107573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061112b919061418d565b60055460405163abf4801360e01b81526001600160a01b038c811660048301528b8116602483015291821660448201523060648201526084810186905260a4810185905260c4810183905291925086169063abf480139060e401600060405180830381600087803b15801561119f57600080fd5b505af11580156111b3573d6000803e3d6000fd5b50959e5050505050505050505050505050505b92915050565b336000908152607460205260409020546001600160a01b03166112015760405162461bcd60e51b815260040161072d9061413a565b607154606f541061124c5760405162461bcd60e51b81526020600482015260156024820152742737aab73932b9b7b63b32b220b9b9b2b93a34b7b760591b604482015260640161072d565b6000606f54600161125d9190614175565b6070546004805460405163030b947760e41b815291820184905292935090916001600160a01b0316906330b947709060240160206040518083038186803b1580156112a757600080fd5b505afa1580156112bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112df919061418d565b14156114685760048054604051638286227560e01b81529182018390526001600160a01b03169063828622759060240160206040518083038186803b15801561132757600080fd5b505afa15801561133b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061135f919061418d565b4210156113a75760405162461bcd60e51b81526020600482015260166024820152754368616c6c656e6765506572696f6450656e64696e6760501b604482015260640161072d565b6113b0816136d6565b6004805460405163366b2b6960e01b81529182018490526001600160a01b03169063366b2b699060240160206040518083038186803b1580156113f257600080fd5b505afa158015611406573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061142a919061418d565b146114685760405162461bcd60e51b815260206004820152600e60248201526d14dd185ad95c9cd41c995cd95b9d60921b604482015260640161072d565b606f8054906000611478836141a6565b91905055507f5b24ab8ceb442373727ac5c559a027521cb52db451c74710ebed9faa5fe15a7c606f546040516114b091815260200190565b60405180910390a160048054606f5460405163d8a4e5af60e01b8152928301526001600160a01b03169063d8a4e5af90602401600060405180830381600087803b1580156114fd57600080fd5b505af1158015611511573d6000803e3d6000fd5b5050505050565b603c81815481106109b857600080fd5b336000908152607460205260409020546001600160a01b031661155d5760405162461bcd60e51b815260040161072d9061413a565b336000818152607560205260408082208054929055600354905163a9059cbb60e01b815260048101939093526024830182905290916001600160a01b039091169063a9059cbb90604401602060405180830381600087803b1580156115c157600080fd5b505af11580156115d5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115f991906141d8565b6116155760405162461bcd60e51b815260040161072d906141fa565b50565b6000805460405163bf40fac160e01b81526001600160a01b039091169063bf40fac19061164990859060040161429f565b60206040518083038186803b15801561166157600080fd5b505afa158015611675573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111c691906142b2565b336000908152607460205260409020546001600160a01b03166116ce5760405162461bcd60e51b815260040161072d9061413a565b6116fb6040518060400160405280600c81526020016b212b26afa937b6363ab832b960a11b815250611618565b6001600160a01b0316336001600160a01b0316146117795760405162461bcd60e51b815260206004820152603560248201527f6d73672e73656e646572206973206e6f7420726f6c6c75702070726f706f73656044820152740e45840c6c2dc4ee840c2e0e0cadcc840c4c2e8c6d605b1b606482015260840161072d565b6117838787612335565b60006117ba6040518060400160405280601481526020017329ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760611b815250611618565b90506000816001600160a01b031687878787876040516024016117e19594939291906142cf565b60408051601f198184030181529181526020820180516001600160e01b0316632169f79f60e01b17905251611816919061433f565b6000604051808303816000865af19150503d8060008114611853576040519150601f19603f3d011682016040523d82523d6000602084013e611858565b606091505b50509050806118bb5760405162461bcd60e51b815260206004820152602960248201527f73636320617070656e64207374617465206261746368206661696c65642c2072604482015268195d995c9d08185b1b60ba1b606482015260840161072d565b505050505050505050565b6038546001600160a01b031633146118f05760405162461bcd60e51b815260040161072d9061435b565b603a5460005b828110156119ba576119088183614175565b6039600086868581811061191e5761191e614231565b90506020020160208101906119339190613c31565b6001600160a01b03168152602081019190915260400160002055603a84848381811061196157611961614231565b90506020020160208101906119769190613c31565b81546001810183556000928352602090922090910180546001600160a01b0319166001600160a01b03909216919091179055806119b2816141a6565b9150506118f6565b50505050565b33600081815260396020526040902054603a805483929081106119e5576119e5614231565b6000918252602090912001546001600160a01b031614611a475760405162461bcd60e51b815260206004820152601760248201527f4e4f545f494e5f5354414b45525f57484954454c495354000000000000000000604482015260640161072d565b6001600160a01b0382166000818152603b6020526040902054603c8054859392908110611a7657611a76614231565b6000918252602090912001546001600160a01b031614611ad85760405162461bcd60e51b815260206004820152601960248201527f4e4f545f494e5f4f50455241544f525f57484954454c49535400000000000000604482015260640161072d565b6003546040516323b872dd60e01b8152336004820152306024820152604481018690526001600160a01b03909116906323b872dd90606401602060405180830381600087803b158015611b2a57600080fd5b505af1158015611b3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b6291906141d8565b611b7e5760405162461bcd60e51b815260040161072d906141fa565b3360009081526073602052604090205460ff1615611c3e57336000908152607360205260409020600301546001600160a01b03848116911614611c115760405162461bcd60e51b815260206004820152602560248201527f7374616b6572203d3e206f70657261746f72206d617070696e67206e6f7420756044820152646e6971756560d81b606482015260840161072d565b3360009081526073602052604081206001018054869290611c33908490614175565b909155506119ba9050565b6001600160a01b038381166000908152607460205260409020541615611c9d5760405162461bcd60e51b81526020600482015260146024820152731bdc195c985d1bdc881a5cc81bd8d8dd5c1a595960621b604482015260640161072d565b600254841015611ce35760405162461bcd60e51b8152602060048201526011602482015270496e73756666696369656e745374616b6560781b604482015260640161072d565b6040805160a0810182526001808252602080830188815260008486018181526001600160a01b03808b16606088018181526080890185815233808752607389528b87209a518b5490151560ff19909116178b559651988a01989098559251600289015591516003880180549183166001600160a01b03199283161790559551600490970180549790911696861696909617909555938452607490915292822080549091169092179091556072805491611d9b836141a6565b91905055506119ba336070546137ca565b336000908152607460205260409020546001600160a01b0316611de15760405162461bcd60e51b815260040161072d9061413a565b336000908152607460209081526040808320546001600160a01b03168084526073909252909120600281015483111580611e1c575060715483115b15611e5f5760405162461bcd60e51b8152602060048201526013602482015272417373657274696f6e4f75744f6652616e676560681b604482015260640161072d565b6004805460405163030b947760e41b81529182018590526001600160a01b0316906330b947709060240160206040518083038186803b158015611ea157600080fd5b505afa158015611eb5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ed9919061418d565b816002015414611f2b5760405162461bcd60e51b815260206004820152601760248201527f506172656e74417373657274696f6e556e7374616b6564000000000000000000604482015260640161072d565b611f3582846137ca565b505050565b336000908152607460205260409020546001600160a01b0316611f6f5760405162461bcd60e51b815260040161072d9061413a565b611f7b60766000613b67565b565b6038546001600160a01b03163314611fa75760405162461bcd60e51b815260040161072d9061435b565b60005b81811015611f35576000603b6000858585818110611fca57611fca614231565b9050602002016020810190611fdf9190613c31565b6001600160a01b03166001600160a01b0316815260200190815260200160002054905080603b6000603c6001603c8054905061201b91906141c1565b8154811061202b5761202b614231565b60009182526020808320909101546001600160a01b03168352820192909252604001902055603c8054612060906001906141c1565b8154811061207057612070614231565b600091825260209091200154603c80546001600160a01b03909216918390811061209c5761209c614231565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550603c8054806120db576120db614390565b600082815260208120820160001990810180546001600160a01b0319169055909101909155603b9085858581811061211557612115614231565b905060200201602081019061212a9190613c31565b6001600160a01b0316815260208101919091526040016000908120555080612151816141a6565b915050611faa565b6038546001600160a01b031633146121835760405162461bcd60e51b815260040161072d9061435b565b60005b81811015611f35576000603960008585858181106121a6576121a6614231565b90506020020160208101906121bb9190613c31565b6001600160a01b03166001600160a01b031681526020019081526020016000205490508060396000603a6001603a805490506121f791906141c1565b8154811061220757612207614231565b60009182526020808320909101546001600160a01b03168352820192909252604001902055603a805461223c906001906141c1565b8154811061224c5761224c614231565b600091825260209091200154603a80546001600160a01b03909216918390811061227857612278614231565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550603a8054806122b7576122b7614390565b600082815260208120820160001990810180546001600160a01b03191690559091019091556039908585858181106122f1576122f1614231565b90506020020160208101906123069190613c31565b6001600160a01b031681526020810191909152604001600090812055508061232d816141a6565b915050612186565b336000908152607460205260409020546001600160a01b031661236a5760405162461bcd60e51b815260040161072d9061413a565b336000908152607460209081526040808320546001600160a01b039081168085526073909352922060040154909116156124005760405162461bcd60e51b815260206004820152603160248201527f63616e206e6f742063726561746520617373657274696f6e207768656e207374604482015270616b657220696e206368616c6c656e676560781b606482015260840161072d565b6001600160a01b038181166000908152607360205260409081902060020154600154600480549351634e04886d60e01b8152908101839052919390921690634e04886d9060240160206040518083038186803b15801561245f57600080fd5b505afa158015612473573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612497919061418d565b6124a190436141c1565b10156124ef5760405162461bcd60e51b815260206004820152601f60248201527f4d696e696d756d417373657274696f6e506572696f644e6f7450617373656400604482015260640161072d565b60048054604051632b27e93b60e01b81529182018390526001600160a01b031690632b27e93b9060240160206040518083038186803b15801561253157600080fd5b505afa158015612545573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612569919061418d565b83116125a85760405162461bcd60e51b815260206004820152600e60248201526d22b6b83a3ca0b9b9b2b93a34b7b760911b604482015260640161072d565b607180549060006125b8836141a6565b9091555050607154604080519182523360208301528101859052606081018490527f5c610f28399ecc14b66149012a0197a5e3257a8c397125afee95d1cf4b9507349060800160405180910390a16004546071546001600160a01b039091169063422815849086868561262961388f565b6040516001600160e01b031960e088901b1681526004810195909552602485019390935260448401919091526064830152608482015260a401600060405180830381600087803b15801561267c57600080fd5b505af1158015612690573d6000803e3d6000fd5b505050506126a0826071546137ca565b606f80549060006126b0836141a6565b9091555050606f5460708190556040519081527f453430d123684340024ae0a229704bdab39c93dc48bb5a0b4bc83142d95d48ef9060200160405180910390a150505050565b6038546001600160a01b031633146127205760405162461bcd60e51b815260040161072d9061435b565b603c5460005b828110156119ba576127388183614175565b603b600086868581811061274e5761274e614231565b90506020020160208101906127639190613c31565b6001600160a01b03168152602081019190915260400160002055603c84848381811061279157612791614231565b90506020020160208101906127a69190613c31565b81546001810183556000928352602090922090910180546001600160a01b0319166001600160a01b03909216919091179055806127e2816141a6565b915050612726565b60048054607054604051632b27e93b60e01b8152928301526000916001600160a01b0390911690632b27e93b9060240160206040518083038186803b15801561283257600080fd5b505afa158015612846573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061286a919061418d565b905090565b600054600160a81b900460ff161580801561289757506000546001600160a01b90910460ff16105b806128b85750303b1580156128b85750600054600160a01b900460ff166001145b61291b5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161072d565b6000805460ff60a01b1916600160a01b1790558015612948576000805460ff60a81b1916600160a81b1790555b6001600160a01b038d16158061296557506001600160a01b038c16155b156129a05760405162461bcd60e51b815260206004820152600b60248201526a5a65726f4164647265737360a81b604482015260640161072d565b8c603860006101000a8154816001600160a01b0302191690836001600160a01b031602179055508a600360006101000a8154816001600160a01b0302191690836001600160a01b031602179055508b600560006101000a8154816001600160a01b0302191690836001600160a01b0316021790555060006001600160a01b031660008054906101000a90046001600160a01b03166001600160a01b031614612a815760405162461bcd60e51b81526020600482015260146024820152731499591d5b99185b9d125b9a5d1a585b1a5e995960621b604482015260640161072d565b600080546001600160a01b0319166001600160a01b038c8116919091179091556004541615612ae95760405162461bcd60e51b81526020600482015260146024820152731499591d5b99185b9d125b9a5d1a585b1a5e995960621b604482015260640161072d565b600480546001600160a01b0319166001600160a01b038b16908117825560018a905560028990556040516303b31b8360e11b8152309281019290925290630766370690602401600060405180830381600087803b158015612b4957600080fd5b505af1158015612b5d573d6000803e3d6000fd5b50506000606f819055607081905560718190556004805460405163108a056160e21b8152918201839052602482018b90526044820183905260648201929092524360848201526001600160a01b0390911692506342281584915060a401600060405180830381600087803b158015612bd457600080fd5b505af1158015612be8573d6000803e3d6000fd5b50505050612bf685856118c6565b612c0083836126f6565b8015612c48576000805460ff60a81b19169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050505050505050565b6038546001600160a01b03163314612c815760405162461bcd60e51b815260040161072d9061435b565b6000612cb86040518060400160405280601481526020017329ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760611b815250611618565b90506000816001600160a01b0316858585604051602401612cdb939291906143a6565b60408051601f198184030181529181526020820180516001600160e01b03166305f9daf960e11b17905251612d10919061433f565b6000604051808303816000865af19150503d8060008114612d4d576040519150601f19603f3d011682016040523d82523d6000602084013e612d52565b606091505b50509050806115115760405162461bcd60e51b815260206004820152601b60248201527f63616c6c20726f6c6c4261636b4c32436861696e206661696c65640000000000604482015260640161072d565b6038546001600160a01b03163314612dcd5760405162461bcd60e51b815260040161072d9061435b565b6000612e046040518060400160405280601481526020017329ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760611b815250611618565b60408051600481526024810182526020810180516001600160e01b0316633958777760e21b17905290519192506000916001600160a01b03841691612e489161433f565b6000604051808303816000865af19150503d8060008114612e85576040519150601f19603f3d011682016040523d82523d6000602084013e612e8a565b606091505b50915050600081612e9a906143c5565b8451909150612ea990826141c1565b600114612f045760405162461bcd60e51b8152602060048201526024808201527f64656c657465206261746368207769746820676170206973206e6f7420616c6c6044820152631bddd95960e21b606482015260840161072d565b6000836001600160a01b031685604051602401612f2191906143ec565b60408051601f198184030181529181526020820180516001600160e01b0316632da6c87160e11b17905251612f56919061433f565b6000604051808303816000865af19150503d8060008114612f93576040519150601f19603f3d011682016040523d82523d6000602084013e612f98565b606091505b5050905080612ffb5760405162461bcd60e51b815260206004820152602960248201527f7363632064656c657465207374617465206261746368206661696c65642c2072604482015268195d995c9d08185b1b60ba1b606482015260840161072d565b606f5460715410156130665760405162461bcd60e51b815260206004820152602e60248201527f64656c65746520617373657274696f6e206265666f7265206c6173742072657360448201526d37b63b32b21034b71032b93937b960911b606482015260840161072d565b7f5b24ab8ceb442373727ac5c559a027521cb52db451c74710ebed9faa5fe15a7c60715460405161309991815260200190565b60405180910390a16004805460715460405163d0087d6160e01b8152928301526001600160a01b03169063d0087d6190602401600060405180830381600087803b1580156130e657600080fd5b505af11580156130fa573d6000803e3d6000fd5b50506071805492509050600061310f8361444d565b9091555050606f80549060006131248361444d565b9091555050607080549060006131398361444d565b919050555060005b603a548110156131e85760715460736000603a848154811061316557613165614231565b60009182526020808320909101546001600160a01b0316835282019290925260400190206002015411156131d65760715460736000603a84815481106131ad576131ad614231565b60009182526020808320909101546001600160a01b031683528201929092526040019020600201555b806131e0816141a6565b915050613141565b505050505050565b6038546001600160a01b0316331461321a5760405162461bcd60e51b815260040161072d9061435b565b6001600160a01b03811661327f5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161072d565b611615816139c2565b336000908152607460205260409020546001600160a01b03166132bd5760405162461bcd60e51b815260040161072d9061413a565b6001600160a01b0380831660009081526074602052604080822054848416835291205490821691166132ee8161361b565b60006132fa8383613a14565b9050336001600160a01b038216146133435760405162461bcd60e51b815260206004820152600c60248201526b4e6f744368616c6c656e676560a01b604482015260640161072d565b6001600160a01b0382166000908152607360205260408120600101546002548111156133ad5760025461337690826141c1565b6001600160a01b0385166000908152607560205260408120805490919061339e908490614175565b909155505060025491506133b1565b8091505b6001600160a01b038516600090815260736020526040812060010180548492906133dc908490614175565b90915550506001600160a01b0380861660009081526073602052604080822060040180546001600160a01b03191690559186168152206002015461341f85613adf565b604080518082019091526001600160a01b03958616815260208101918252607680546001808201835560009290925291517fb5732705f5241370a28908c2fe1303cb223f03b90d857fd0573f003f79fefed4600290930292830180546001600160a01b031916919098161790965590517fb5732705f5241370a28908c2fe1303cb223f03b90d857fd0573f003f79fefed59091015550506077805460ff191690921790915550505050565b6038546001600160a01b031633146134f45760405162461bcd60e51b815260040161072d9061435b565b6134fd8161361b565b6001600160a01b03811660009081526073602052604090206070546002820154111561356b5760405162461bcd60e51b815260206004820152601c60248201527f5374616b65644f6e556e636f6e6669726d6564417373657274696f6e00000000604482015260640161072d565b600181015461357983613adf565b60035460405163a9059cbb60e01b81526001600160a01b038581166004830152602482018490529091169063a9059cbb90604401602060405180830381600087803b1580156135c757600080fd5b505af11580156135db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135ff91906141d8565b611f355760405162461bcd60e51b815260040161072d906141fa565b6001600160a01b03811660009081526073602052604090205460ff166116155760405162461bcd60e51b8152602060048201526009602482015268139bdd14dd185ad95960ba1b604482015260640161072d565b6136788161361b565b6001600160a01b0381811660009081526073602052604090206004015416156116155760405162461bcd60e51b815260206004820152601060248201526f21b430b63632b733b2b229ba30b5b2b960811b604482015260640161072d565b600080805b6076548110156137c357600454607680546001600160a01b039092169163873fd0899187918590811061371057613710614231565b600091825260209091206002909102015460405160e084901b6001600160e01b031916815260048101929092526001600160a01b0316602482015260440160206040518083038186803b15801561376657600080fd5b505afa15801561377a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061379e91906141d8565b156137b157816137ad816141a6565b9250505b806137bb816141a6565b9150506136db565b5092915050565b6001600160a01b038281166000818152607360205260409081902060020184905560048054915163541961d760e11b815290810185905260248101929092529091169063a832c3ae90604401600060405180830381600087803b15801561383057600080fd5b505af1158015613844573d6000803e3d6000fd5b5050604080516001600160a01b0386168152602081018590527f617d31491414a4ab2bd831e566a31837fa7fb6582921c91dffbbe83fbca789f3935001905060405180910390a15050565b6000806138c76040518060400160405280601481526020017329ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760611b815250611618565b60408051600481526024810182526020810180516001600160e01b031663c17b291b60e01b179052905191925060009182916001600160a01b0385169161390e919061433f565b6000604051808303816000865af19150503d806000811461394b576040519150601f19603f3d011682016040523d82523d6000602084013e613950565b606091505b5091509150816139a25760405162461bcd60e51b815260206004820181905260248201527f63616c6c2046524155445f50524f4f465f57494e444f572829206661696c6564604482015260640161072d565b60006139ad826143c5565b90506139b98142614175565b94505050505090565b603880546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b03808316600090815260736020526040808220848416835290822060048201549293919290911680613a805760405162461bcd60e51b815260206004820152600e60248201526d4e6f74496e4368616c6c656e676560901b604482015260640161072d565b60048201546001600160a01b03828116911614613ad65760405162461bcd60e51b8152602060048201526014602482015273496e446966666572656e744368616c6c656e676560601b604482015260640161072d565b95945050505050565b60728054906000613aef8361444d565b90915550506001600160a01b039081166000908152607360209081526040808320600381018054825460ff1916835560018301869055600283018690556001600160a01b03198082169092556004909201805482169055941683526074909152902080549091169055565b6119048061446583390190565b508054600082556002029060005260206000209081019061161591905b80821115613ba95780546001600160a01b031916815560006001820155600201613b84565b5090565b600060208284031215613bbf57600080fd5b5035919050565b80604081018310156111c657600080fd5b60008060808385031215613bea57600080fd5b613bf48484613bc6565b9150613c038460408501613bc6565b90509250929050565b6001600160a01b038116811461161557600080fd5b8035613c2c81613c0c565b919050565b600060208284031215613c4357600080fd5b8135613c4e81613c0c565b9392505050565b634e487b7160e01b600052604160045260246000fd5b60405160c0810167ffffffffffffffff81118282101715613c8e57613c8e613c55565b60405290565b600067ffffffffffffffff80841115613caf57613caf613c55565b604051601f8501601f19908116603f01168101908282118183101715613cd757613cd7613c55565b81604052809350858152868686011115613cf057600080fd5b858560208301376000602087830101525050509392505050565b600060208284031215613d1c57600080fd5b813567ffffffffffffffff811115613d3357600080fd5b8201601f81018413613d4457600080fd5b613d5384823560208401613c94565b949350505050565b60008083601f840112613d6d57600080fd5b50813567ffffffffffffffff811115613d8557600080fd5b6020830191508360208260051b8501011115613da057600080fd5b9250929050565b600080600080600080600060a0888a031215613dc257600080fd5b8735965060208801359550604088013567ffffffffffffffff80821115613de857600080fd5b613df48b838c01613d5b565b909750955060608a0135945060808a0135915080821115613e1457600080fd5b818a0191508a601f830112613e2857600080fd5b813581811115613e3757600080fd5b8b6020828501011115613e4957600080fd5b60208301945080935050505092959891949750929550565b60008060208385031215613e7457600080fd5b823567ffffffffffffffff811115613e8b57600080fd5b613e9785828601613d5b565b90969095509350505050565b60008060408385031215613eb657600080fd5b823591506020830135613ec881613c0c565b809150509250929050565b60008060408385031215613ee657600080fd5b50508035926020909101359150565b6000806000806000806000806000806000806101408d8f031215613f1857600080fd5b613f218d613c21565b9b50613f2f60208e01613c21565b9a50613f3d60408e01613c21565b9950613f4b60608e01613c21565b9850613f5960808e01613c21565b975060a08d0135965060c08d0135955060e08d0135945067ffffffffffffffff6101008e01351115613f8a57600080fd5b613f9b8e6101008f01358f01613d5b565b909450925067ffffffffffffffff6101208e01351115613fba57600080fd5b613fcb8e6101208f01358f01613d5b565b81935080925050509295989b509295989b509295989b565b600082601f830112613ff457600080fd5b613c4e83833560208501613c94565b60008060006060848603121561401857600080fd5b8335925060208401359150604084013567ffffffffffffffff81111561403d57600080fd5b61404986828701613fe3565b9150509250925092565b60006020828403121561406557600080fd5b813567ffffffffffffffff8082111561407d57600080fd5b9083019060c0828603121561409157600080fd5b614099613c6b565b823581526020830135602082015260408301356040820152606083013560608201526080830135828111156140cd57600080fd5b6140d987828601613fe3565b60808301525060a0830135828111156140f157600080fd5b6140fd87828601613fe3565b60a08301525095945050505050565b6000806040838503121561411f57600080fd5b823561412a81613c0c565b91506020830135613ec881613c0c565b6020808252600b908201526a2737ba27b832b930ba37b960a91b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b600082198211156141885761418861415f565b500190565b60006020828403121561419f57600080fd5b5051919050565b60006000198214156141ba576141ba61415f565b5060010190565b6000828210156141d3576141d361415f565b500390565b6000602082840312156141ea57600080fd5b81518015158114613c4e57600080fd5b6020808252601b908201527f7472616e7366657220657263323020746f6b656e206661696c65640000000000604082015260600190565b634e487b7160e01b600052603260045260246000fd5b60005b8381101561426257818101518382015260200161424a565b838111156119ba5750506000910152565b6000815180845261428b816020860160208601614247565b601f01601f19169290920160200192915050565b602081526000613c4e6020830184614273565b6000602082840312156142c457600080fd5b8151613c4e81613c0c565b6060808252810185905260006001600160fb1b038611156142ef57600080fd5b8560051b80886080850137602083018690528201828103608090810160408501528101849052838560a0830137600060a0858301015260a0601f19601f8601168201019150509695505050505050565b60008251614351818460208701614247565b9190910192915050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b634e487b7160e01b600052603160045260246000fd5b838152826020820152606060408201526000613ad66060830184614273565b805160208083015191908110156143e6576000198160200360031b1b821691505b50919050565b60208152815160208201526020820151604082015260408201516060820152606082015160808201526000608083015160c060a084015261443060e0840182614273565b905060a0840151601f198483030160c0850152613ad68282614273565b60008161445c5761445c61415f565b50600019019056fe608060405234801561001057600080fd5b506118e4806100206000396000f3fe608060405234801561001057600080fd5b50600436106101375760003560e01c80638b299903116100b8578063dfbf53ae1161007c578063dfbf53ae146102a3578063e87e3589146102b6578063ed5b1303146102be578063f03a7fcb146102c7578063f2858aa3146102da578063faeff41b146102ed57600080fd5b80638b2999031461022c5780638f2400a8146102465780639afd9d7814610259578063abf480131461027d578063afeae9651461029057600080fd5b8063631acced116100ff578063631acced146101aa57806370dea79a146101b2578063732e6961146101ba5780637f4c91c5146102115780638a8cd2181461022457600080fd5b806318ef160d1461013c5780632a51f6f71461015157806341e8510c1461016d578063534db0e2146101765780635f41e3d6146101a1575b600080fd5b61014f61014a366004611333565b6102f6565b005b61015a60085481565b6040519081526020015b60405180910390f35b61015a60065481565b600354610189906001600160a01b031681565b6040516001600160a01b039091168152602001610164565b61015a60055481565b61014f6105d0565b61014f610636565b6010546011546012546013546014546015546016546101dc9695949392919087565b604080519788526020880196909652948601939093526060850191909152608084015260a083015260c082015260e001610164565b600254610189906001600160a01b031681565b6101896106c9565b6007546102399060ff1681565b604051610164919061136b565b61014f610254366004611385565b61075b565b600e5461026d90600160a01b900460ff1681565b6040519015158152602001610164565b61014f61028b3660046113fc565b610b55565b61015a61029e366004611473565b610cae565b600e54610189906001600160a01b031681565b61015a610cc5565b61015a60045481565b61014f6102d53660046114d5565b610d13565b61014f6102e8366004611579565b611018565b61015a600f5481565b6102fe6106c9565b6001600160a01b0316336001600160a01b0316146040518060400160405280600a8152602001692124a9afa9a2a72222a960b11b8152509061035c5760405162461bcd60e51b815260040161035391906115a2565b60405180910390fd5b50610365610cc5565b60045461037290426115f7565b11156040518060400160405280600c81526020016b4249535f444541444c494e4560a01b815250906103b75760405162461bcd60e51b815260040161035391906115a2565b5060085460408051808201909152600f81526e4348414c5f494e49545f535441544560881b602082015290156104005760405162461bcd60e51b815260040161035391906115a2565b50600081116104455760405162461bcd60e51b8152602060048201526011602482015270494e56414c49445f4e554d5f535445505360781b6044820152606401610353565b604080516000602080830191909152818301849052825180830384018152606090920190925280519101206008556040805160e08082018352600c548083526020808401879052600d54848601819052436060808701829052426080808901829052600060a0808b0182905260c09a8b018d9052601089905560118e9055601287905560138690556014849055601582905560168d90558b519889529688018d90529987019490945290850191909152908301528101939093529082018390527f71809f4d4f7bf3c208a85ccd3c922c984024f8e3cef51e3d03ae677e4217097d910160405180910390a1600160075460ff16600281111561054957610549611355565b141561057e5760045461055c90426115f7565b60065461056991906115f7565b6006556007805460ff191660021790556105c8565b600260075460ff16600281111561059757610597611355565b14156105c8576004546105aa90426115f7565b6005546105b791906115f7565b6005556007805460ff191660011790555b505042600455565b600e54600160a01b900460ff16156106215760405162461bcd60e51b8152602060048201526014602482015273414c52454144595f5345545f524f4c4c4241434b60601b6044820152606401610353565b600e805460ff60a01b1916600160a01b179055565b61063e610cc5565b60045461064b90426115f7565b116040518060400160405280601081526020016f54494d454f55545f444541444c494e4560801b815250906106935760405162461bcd60e51b815260040161035391906115a2565b50600260075460ff1660028111156106ad576106ad611355565b14156106bf576106bd60016111f4565b565b6106bd6001611257565b6000600260075460ff1660028111156106e4576106e4611355565b14156106fa57506002546001600160a01b031690565b600160075460ff16600281111561071357610713611355565b141561072957506003546001600160a01b031690565b60405162461bcd60e51b81526020600482015260076024820152662727afaa2aa92760c91b6044820152606401610353565b6107636106c9565b6001600160a01b0316336001600160a01b0316146040518060400160405280600a8152602001692124a9afa9a2a72222a960b11b815250906107b85760405162461bcd60e51b815260040161035391906115a2565b506107c1610cc5565b6004546107ce90426115f7565b11156040518060400160405280600c81526020016b4249535f444541444c494e4560a01b815250906108135760405162461bcd60e51b815260040161035391906115a2565b506008546108555760405162461bcd60e51b815260206004820152600f60248201526e1393d517d253925512505312569151608a1b6044820152606401610353565b604080516020808201859052818301849052825180830384018152606090920190925280519101206008548114604051806040016040528060088152602001672124a9afa82922ab60c11b815250906108c15760405162461bcd60e51b815260040161035391906115a2565b50600a541561091b57600954873514806108dd5750600a548735145b61091b5760405162461bcd60e51b815260206004820152600f60248201526e1053509251d553d554d7d4d5105495608a1b6044820152606401610353565b600b546040880135141561095f5760405162461bcd60e51b815260206004820152600b60248201526a1253959053125117d1539160aa1b6044820152606401610353565b6000841161099b5760405162461bcd60e51b81526020600482015260096024820152681513d3d7d4d213d49560ba1b6044820152606401610353565b8635600955602080880135600a55604080890135600b558051808301889052808201879052815180820383018152606090910190915280519101206008556040805160e081018252883581526020808a0135908201529081018860026020908102919091013582524382820181905242604080850182905260608086018c905260809586018b905286516010558685015160115586820151601255868101516013558686015160145560a08088015160155560c09788015160165582518f3581528f870135968101969096528e8301358684015290850193909352938301528101889052918201869052517f71809f4d4f7bf3c208a85ccd3c922c984024f8e3cef51e3d03ae677e4217097d9181900360e00190a150600160075460ff166002811115610aca57610aca611355565b1415610aff57600454610add90426115f7565b600654610aea91906115f7565b6006556007805460ff19166002179055610b49565b600260075460ff166002811115610b1857610b18611355565b1415610b4957600454610b2b90426115f7565b600554610b3891906115f7565b6005556007805460ff191660011790555b50504260045550505050565b600060075460ff166002811115610b6e57610b6e611355565b146040518060400160405280600f81526020016e4348414c5f494e49545f535441544560881b81525090610bb55760405162461bcd60e51b815260040161035391906115a2565b506001600160a01b03871615801590610bd657506001600160a01b03861615155b8015610bea57506001600160a01b03841615155b610c255760405162461bcd60e51b815260206004820152600c60248201526b5a45524f5f4144445245535360a01b6044820152606401610353565b600280546001600160a01b03199081166001600160a01b03998a16178255600380548216988a1698909817909755600180548816968916969096179095556000805490961693909616929092178455600c829055600d8590556007805460ff19169093179092554260045560966005819055600655600955600a91909155600b91909155600f55565b60098160038110610cbe57600080fd5b0154905081565b6000600260075460ff166002811115610ce057610ce0611355565b1415610ced575060055490565b600160075460ff166002811115610d0657610d06611355565b1415610729575060065490565b610d1b6106c9565b6001600160a01b0316336001600160a01b0316146040518060400160405280600a8152602001692124a9afa9a2a72222a960b11b81525090610d705760405162461bcd60e51b815260040161035391906115a2565b50610d79610cc5565b600454610d8690426115f7565b11156040518060400160405280600c81526020016b4249535f444541444c494e4560a01b81525090610dcb5760405162461bcd60e51b815260040161035391906115a2565b50604080516020808201859052818301849052825180830384018152606090920190925280519101206008548114604051806040016040528060088152602001672124a9afa82922ab60c11b81525090610e385760405162461bcd60e51b815260040161035391906115a2565b506001610e46600284611632565b1115610e8b5760405162461bcd60e51b8152602060048201526014602482015273424953454354494f4e5f494e434f4d504c45544560601b6044820152606401610353565b600180546000916001600160a01b039091169063625eb72e908b908b90600990610eb5908b6115f7565b60038110610ec557610ec561161c565b01548b8b6040518663ffffffff1660e01b8152600401610ee99594939291906117ac565b60206040518083038186803b158015610f0157600080fd5b505afa158015610f15573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f39919061185f565b905060098560038110610f4e57610f4e61161c565b0154811415610f6657610f6160006112af565b610f70565b610f706000611302565b506001905060075460ff166002811115610f8c57610f8c611355565b1415610fc157600454610f9f90426115f7565b600654610fac91906115f7565b6006556007805460ff1916600217905561100b565b600260075460ff166002811115610fda57610fda611355565b141561100b57600454610fed90426115f7565b600554610ffa91906115f7565b6005556007805460ff191660011790555b5050426004555050505050565b6002546001600160a01b03166110635760405162461bcd60e51b815260206004820152601060248201526f111959995b99195c881b9bdd081cd95d60821b6044820152606401610353565b6002546001600160a01b031633146110b35760405162461bcd60e51b815260206004820152601360248201527221b0b63632b9103737ba103232b332b73232b960691b6044820152606401610353565b600e546001600160a01b03166111005760405162461bcd60e51b81526020600482015260126024820152712237903737ba103430bb32903bb4b73732b960711b6044820152606401610353565b600354600e546001600160a01b03908116911614156111b257801561118f57600054600354600254604051637d3c01f360e11b81526001600160a01b039283166004820152908216602482015291169063fa7803e6906044015b600060405180830381600087803b15801561117457600080fd5b505af1158015611188573d6000803e3d6000fd5b5050505050565b600254600e80546001600160a01b0319166001600160a01b039092169190911790555b600054600254600354604051637d3c01f360e11b81526001600160a01b039283166004820152908216602482015291169063fa7803e69060440161115a565b50565b600354600e80546001600160a01b0319166001600160a01b039283169081179091556002546040517f03f929a9a6b1f0aef5e43cb12b56f862da97ec3de3fda02a52e85f9f3974fb6a9361124c939216908590611878565b60405180910390a150565b600254600e80546001600160a01b0319166001600160a01b039283169081179091556003546040517f03f929a9a6b1f0aef5e43cb12b56f862da97ec3de3fda02a52e85f9f3974fb6a9361124c939216908590611878565b600260075460ff1660028111156112c8576112c8611355565b14156112d7576111f181611257565b600354600e80546001600160a01b0319166001600160a01b039092169190911790556111f1816111f4565b600260075460ff16600281111561131b5761131b611355565b141561132a576111f1816111f4565b6111f181611257565b6000806040838503121561134657600080fd5b50508035926020909101359150565b634e487b7160e01b600052602160045260246000fd5b602081016003831061137f5761137f611355565b91905290565b600080600080600080610100878903121561139f57600080fd5b60608701888111156113b057600080fd5b969896359750505060808701359460a0880135945060c0880135935060e088013592509050565b6001600160a01b03811681146111f157600080fd5b80356113f7816113d7565b919050565b600080600080600080600060e0888a03121561141757600080fd5b8735611422816113d7565b96506020880135611432816113d7565b95506040880135611442816113d7565b94506060880135611452816113d7565b9699959850939660808101359560a0820135955060c0909101359350915050565b60006020828403121561148557600080fd5b5035919050565b60008083601f84011261149e57600080fd5b50813567ffffffffffffffff8111156114b657600080fd5b6020830191508360208285010111156114ce57600080fd5b9250929050565b600080600080600080600060c0888a0312156114f057600080fd5b873567ffffffffffffffff8082111561150857600080fd5b9089019060e0828c03121561151c57600080fd5b90975060208901359060ff8216821461153457600080fd5b9096506040890135908082111561154a57600080fd5b506115578a828b0161148c565b989b979a50986060810135976080820135975060a09091013595509350505050565b60006020828403121561158b57600080fd5b8135801515811461159b57600080fd5b9392505050565b600060208083528351808285015260005b818110156115cf578581018301518582016040015282016115b3565b818111156115e1576000604083870101525b50601f01601f1916929092016040019392505050565b60008282101561161757634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052603260045260246000fd5b60008261164f57634e487b7160e01b600052601260045260246000fd5b500490565b6000823561011e1983360301811261166b57600080fd5b90910192915050565b803567ffffffffffffffff811681146113f757600080fd5b6000808335601e198436030181126116a357600080fd5b830160208101925035905067ffffffffffffffff8111156116c357600080fd5b8036038313156114ce57600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b600061012067ffffffffffffffff61171284611674565b1684526020830135602085015261172b60408401611674565b67ffffffffffffffff166040850152611746606084016113ec565b6001600160a01b031660608501526080838101359085015261176b60a084018461168c565b8260a087015261177e83870182846116d2565b9250505060c083013560c085015260e083013560e08501526101008084013581860152508091505092915050565b60808152600086356117bd816113d7565b6001600160a01b039081166080840152602088013560a0840152604088013560c08401526060880135906117f0826113d7565b1660e08301526118036080880188611654565b60e06101008401526118196101608401826116fb565b60a089013561012085015260c089013561014085015260ff88166020850152905085604084015282810360608401526118538185876116d2565b98975050505050505050565b60006020828403121561187157600080fd5b5051919050565b6001600160a01b0384811682528316602082015260608101600283106118a0576118a0611355565b82604083015294935050505056fea2646970667358221220ccb7efc97baac554457c80cecdacd0363693ddc1ffd8120b287494f2e6e7e88b64736f6c63430008090033a2646970667358221220b2320bae11ac531fb45a91ab63f86f0979c9923b7d16f7e7b868965375a21be764736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102745760003560e01c80636aabc35011610151578063b553ee84116100c3578063cfc5901d11610087578063cfc5901d14610641578063de574efc14610654578063e03c863214610667578063f2fde38b14610687578063fa7803e61461069a578063fe2ba848146106ad57600080fd5b8063b553ee84146105f7578063b6da898f14610600578063c8525c3e14610613578063c94b584714610626578063c97a59191461062e57600080fd5b80638c669739116101155780638c6697391461052a5780638da5cb5b146105325780639168ae72146105455780639efbea23146105c8578063a56ba93b146105db578063aca9a518146105e457600080fd5b80636aabc350146104c95780636c8b052a146104f257806371129559146104fb5780637acb7757146105045780638821b2ae1461051757600080fd5b806330b26075116101ea578063461a4478116101ae578063461a44781461043957806349cd30041461044c5780634d26732d1461045f57806351ed6a30146104675780636177fd181461047a5780636a368561146104b657600080fd5b806330b26075146103fa57806337d1fbdd146104025780633ccfd60b1461041557806340d9224b1461041d57806345e38b641461043057600080fd5b80632aa234f61161023c5780632aa234f61461036e5780632b7ac3f3146103815780632e17de78146103945780632f06d1b0146103a75780632f30cabd146103ba578063300a7161146103da57600080fd5b80630e456acf14610279578063107035a4146102f05780632052465e146103075780632906040e14610339578063299ca47814610343575b600080fd5b607754607854607954607a54607b546102ac9460ff8116946001600160a01b036101009092048216949082169391169186565b6040805196151587526001600160a01b0395861660208801529385169386019390935292166060840152608083019190915260a082015260c0015b60405180910390f35b6102f960715481565b6040519081526020016102e7565b61031a610315366004613bad565b6106c0565b604080516001600160a01b0390931683526020830191909152016102e7565b6103416106f8565b005b600054610356906001600160a01b031681565b6040516001600160a01b0390911681526020016102e7565b61035661037c366004613bad565b6109a8565b600554610356906001600160a01b031681565b6103416103a2366004613bad565b6109d2565b6103566103b5366004613bd7565b610b52565b6102f96103c8366004613c31565b60756020526000908152604090205481565b6102f96103e8366004613c31565b60396020526000908152604090205481565b6103416111cc565b610356610410366004613bad565b611518565b610341611528565b600454610356906001600160a01b031681565b6102f960015481565b610356610447366004613d0a565b611618565b61034161045a366004613da7565b611699565b6002546102f9565b600354610356906001600160a01b031681565b6104a6610488366004613c31565b6001600160a01b031660009081526073602052604090205460ff1690565b60405190151581526020016102e7565b6103416104c4366004613e61565b6118c6565b6103566104d7366004613c31565b6074602052600090815260409020546001600160a01b031681565b6102f960725481565b6102f960025481565b610341610512366004613ea3565b6119c0565b610341610525366004613bad565b611dac565b610341611f3a565b603854610356906001600160a01b031681565b610592610553366004613c31565b6073602052600090815260409020805460018201546002830154600384015460049094015460ff90931693919290916001600160a01b03908116911685565b6040805195151586526020860194909452928401919091526001600160a01b03908116606084015216608082015260a0016102e7565b6103416105d6366004613e61565b611f7d565b6102f960705481565b6103416105f2366004613e61565b612159565b6102f9606f5481565b61034161060e366004613ed3565b612335565b610341610621366004613e61565b6126f6565b6102f96127ea565b61034161063c366004613ef5565b61286f565b61034161064f366004614003565b612c57565b610341610662366004614053565b612da3565b6102f9610675366004613c31565b603b6020526000908152604090205481565b610341610695366004613c31565b6131f0565b6103416106a836600461410c565b613288565b6103416106bb366004613c31565b6134ca565b607681815481106106d057600080fd5b6000918252602090912060029091020180546001909101546001600160a01b03909116915082565b336000908152607460205260409020546001600160a01b03166107365760405162461bcd60e51b815260040161072d9061413a565b60405180910390fd5b607154606f54106107815760405162461bcd60e51b81526020600482015260156024820152742737aab73932b9b7b63b32b220b9b9b2b93a34b7b760591b604482015260640161072d565b6000607254116107be5760405162461bcd60e51b81526020600482015260086024820152672737a9ba30b5b2b960c11b604482015260640161072d565b6000606f5460016107cf9190614175565b60048054604051638286227560e01b81529293506001600160a01b0316916382862275916108039185910190815260200190565b60206040518083038186803b15801561081b57600080fd5b505afa15801561082f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610853919061418d565b42101561089b5760405162461bcd60e51b81526020600482015260166024820152754368616c6c656e6765506572696f6450656e64696e6760501b604482015260640161072d565b6070546004805460405163030b947760e41b81529182018490526001600160a01b0316906330b947709060240160206040518083038186803b1580156108e057600080fd5b505afa1580156108f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610918919061418d565b146109555760405162461bcd60e51b815260206004820152600d60248201526c125b9d985b1a5914185c995b9d609a1b604482015260640161072d565b606f8054906000610965836141a6565b9091555050606f5460708190556040519081527f453430d123684340024ae0a229704bdab39c93dc48bb5a0b4bc83142d95d48ef9060200160405180910390a150565b603a81815481106109b857600080fd5b6000918252602090912001546001600160a01b0316905081565b6109db3361361b565b33600090815260736020526040902060705460028201541115610a405760405162461bcd60e51b815260206004820152601c60248201527f5374616b65644f6e556e636f6e6669726d6564417373657274696f6e00000000604482015260640161072d565b6002548160010154610a5291906141c1565b821115610a955760405162461bcd60e51b8152602060048201526011602482015270496e73756666696369656e745374616b6560781b604482015260640161072d565b81816001016000828254610aa991906141c1565b909155505060035460405163a9059cbb60e01b8152336004820152602481018490526001600160a01b039091169063a9059cbb90604401602060405180830381600087803b158015610afa57600080fd5b505af1158015610b0e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b3291906141d8565b610b4e5760405162461bcd60e51b815260040161072d906141fa565b5050565b336000908152607460205260408120546001600160a01b0316610b875760405162461bcd60e51b815260040161072d9061413a565b81356020830135808210610bca5760405162461bcd60e51b815260206004820152600a6024820152692bb937b733a7b93232b960b11b604482015260640161072d565b607154811115610c125760405162461bcd60e51b81526020600482015260136024820152722ab7383937b837b9b2b220b9b9b2b93a34b7b760691b604482015260640161072d565b8160705410610c635760405162461bcd60e51b815260206004820152601860248201527f417373657274696f6e416c72656164795265736f6c7665640000000000000000604482015260640161072d565b6004805460405163030b947760e41b81529182018490526000916001600160a01b03909116906330b947709060240160206040518083038186803b158015610caa57600080fd5b505afa158015610cbe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ce2919061418d565b6004805460405163030b947760e41b81529293506001600160a01b0316916330b9477091610d169186910190815260200190565b60206040518083038186803b158015610d2e57600080fd5b505afa158015610d42573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d66919061418d565b8114610da65760405162461bcd60e51b815260206004820152600f60248201526e111a5999995c995b9d14185c995b9d608a1b604482015260640161072d565b6000610db56020880188613c31565b90506000610dc96040890160208a01613c31565b9050806001600160a01b0316826001600160a01b03161415610e3b5760405162461bcd60e51b815260206004820152602560248201527f646566656e64657220616e64206368616c6c656e6765206d757374206e6f7420604482015264195c5d585b60da1b606482015260840161072d565b6001600160a01b038083166000908152607460205260408082205484841683529120549082169116610e6c8261366f565b610e758161366f565b6000604051610e8390613b5a565b604051809103906000f080158015610e9f573d6000803e3d6000fd5b506001600160a01b038084166000908152607360209081526040808320600490810180548688166001600160a01b031991821681179092558a871686528386209092018054831682179055825160c0810184529485529284018390528a8516848301819052948a1660608501819052608085018f905260a09094018d905260778054610100949094026001600160a81b031990941693909317909255607880548316909417909355607980549091169091179055607a8a9055607b8990555190915081907fd0ebe74b4f7d89a9b0fdc9d95f887a7b925c6c7300b5c4b2c3304d97925840fa90610fa4908b9084909182526001600160a01b0316602082015260400190565b60405180910390a160048054604051632b27e93b60e01b81529182018990526000916001600160a01b0390911690632b27e93b9060240160206040518083038186803b158015610ff357600080fd5b505afa158015611007573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061102b919061418d565b60048054604051632a411f3360e11b81529182018b90529192506000916001600160a01b0316906354823e669060240160206040518083038186803b15801561107357600080fd5b505afa158015611087573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110ab919061418d565b60048054604051632a411f3360e11b81529182018e90529192506000916001600160a01b0316906354823e669060240160206040518083038186803b1580156110f357600080fd5b505afa158015611107573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061112b919061418d565b60055460405163abf4801360e01b81526001600160a01b038c811660048301528b8116602483015291821660448201523060648201526084810186905260a4810185905260c4810183905291925086169063abf480139060e401600060405180830381600087803b15801561119f57600080fd5b505af11580156111b3573d6000803e3d6000fd5b50959e5050505050505050505050505050505b92915050565b336000908152607460205260409020546001600160a01b03166112015760405162461bcd60e51b815260040161072d9061413a565b607154606f541061124c5760405162461bcd60e51b81526020600482015260156024820152742737aab73932b9b7b63b32b220b9b9b2b93a34b7b760591b604482015260640161072d565b6000606f54600161125d9190614175565b6070546004805460405163030b947760e41b815291820184905292935090916001600160a01b0316906330b947709060240160206040518083038186803b1580156112a757600080fd5b505afa1580156112bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112df919061418d565b14156114685760048054604051638286227560e01b81529182018390526001600160a01b03169063828622759060240160206040518083038186803b15801561132757600080fd5b505afa15801561133b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061135f919061418d565b4210156113a75760405162461bcd60e51b81526020600482015260166024820152754368616c6c656e6765506572696f6450656e64696e6760501b604482015260640161072d565b6113b0816136d6565b6004805460405163366b2b6960e01b81529182018490526001600160a01b03169063366b2b699060240160206040518083038186803b1580156113f257600080fd5b505afa158015611406573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061142a919061418d565b146114685760405162461bcd60e51b815260206004820152600e60248201526d14dd185ad95c9cd41c995cd95b9d60921b604482015260640161072d565b606f8054906000611478836141a6565b91905055507f5b24ab8ceb442373727ac5c559a027521cb52db451c74710ebed9faa5fe15a7c606f546040516114b091815260200190565b60405180910390a160048054606f5460405163d8a4e5af60e01b8152928301526001600160a01b03169063d8a4e5af90602401600060405180830381600087803b1580156114fd57600080fd5b505af1158015611511573d6000803e3d6000fd5b5050505050565b603c81815481106109b857600080fd5b336000908152607460205260409020546001600160a01b031661155d5760405162461bcd60e51b815260040161072d9061413a565b336000818152607560205260408082208054929055600354905163a9059cbb60e01b815260048101939093526024830182905290916001600160a01b039091169063a9059cbb90604401602060405180830381600087803b1580156115c157600080fd5b505af11580156115d5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115f991906141d8565b6116155760405162461bcd60e51b815260040161072d906141fa565b50565b6000805460405163bf40fac160e01b81526001600160a01b039091169063bf40fac19061164990859060040161429f565b60206040518083038186803b15801561166157600080fd5b505afa158015611675573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111c691906142b2565b336000908152607460205260409020546001600160a01b03166116ce5760405162461bcd60e51b815260040161072d9061413a565b6116fb6040518060400160405280600c81526020016b212b26afa937b6363ab832b960a11b815250611618565b6001600160a01b0316336001600160a01b0316146117795760405162461bcd60e51b815260206004820152603560248201527f6d73672e73656e646572206973206e6f7420726f6c6c75702070726f706f73656044820152740e45840c6c2dc4ee840c2e0e0cadcc840c4c2e8c6d605b1b606482015260840161072d565b6117838787612335565b60006117ba6040518060400160405280601481526020017329ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760611b815250611618565b90506000816001600160a01b031687878787876040516024016117e19594939291906142cf565b60408051601f198184030181529181526020820180516001600160e01b0316632169f79f60e01b17905251611816919061433f565b6000604051808303816000865af19150503d8060008114611853576040519150601f19603f3d011682016040523d82523d6000602084013e611858565b606091505b50509050806118bb5760405162461bcd60e51b815260206004820152602960248201527f73636320617070656e64207374617465206261746368206661696c65642c2072604482015268195d995c9d08185b1b60ba1b606482015260840161072d565b505050505050505050565b6038546001600160a01b031633146118f05760405162461bcd60e51b815260040161072d9061435b565b603a5460005b828110156119ba576119088183614175565b6039600086868581811061191e5761191e614231565b90506020020160208101906119339190613c31565b6001600160a01b03168152602081019190915260400160002055603a84848381811061196157611961614231565b90506020020160208101906119769190613c31565b81546001810183556000928352602090922090910180546001600160a01b0319166001600160a01b03909216919091179055806119b2816141a6565b9150506118f6565b50505050565b33600081815260396020526040902054603a805483929081106119e5576119e5614231565b6000918252602090912001546001600160a01b031614611a475760405162461bcd60e51b815260206004820152601760248201527f4e4f545f494e5f5354414b45525f57484954454c495354000000000000000000604482015260640161072d565b6001600160a01b0382166000818152603b6020526040902054603c8054859392908110611a7657611a76614231565b6000918252602090912001546001600160a01b031614611ad85760405162461bcd60e51b815260206004820152601960248201527f4e4f545f494e5f4f50455241544f525f57484954454c49535400000000000000604482015260640161072d565b6003546040516323b872dd60e01b8152336004820152306024820152604481018690526001600160a01b03909116906323b872dd90606401602060405180830381600087803b158015611b2a57600080fd5b505af1158015611b3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b6291906141d8565b611b7e5760405162461bcd60e51b815260040161072d906141fa565b3360009081526073602052604090205460ff1615611c3e57336000908152607360205260409020600301546001600160a01b03848116911614611c115760405162461bcd60e51b815260206004820152602560248201527f7374616b6572203d3e206f70657261746f72206d617070696e67206e6f7420756044820152646e6971756560d81b606482015260840161072d565b3360009081526073602052604081206001018054869290611c33908490614175565b909155506119ba9050565b6001600160a01b038381166000908152607460205260409020541615611c9d5760405162461bcd60e51b81526020600482015260146024820152731bdc195c985d1bdc881a5cc81bd8d8dd5c1a595960621b604482015260640161072d565b600254841015611ce35760405162461bcd60e51b8152602060048201526011602482015270496e73756666696369656e745374616b6560781b604482015260640161072d565b6040805160a0810182526001808252602080830188815260008486018181526001600160a01b03808b16606088018181526080890185815233808752607389528b87209a518b5490151560ff19909116178b559651988a01989098559251600289015591516003880180549183166001600160a01b03199283161790559551600490970180549790911696861696909617909555938452607490915292822080549091169092179091556072805491611d9b836141a6565b91905055506119ba336070546137ca565b336000908152607460205260409020546001600160a01b0316611de15760405162461bcd60e51b815260040161072d9061413a565b336000908152607460209081526040808320546001600160a01b03168084526073909252909120600281015483111580611e1c575060715483115b15611e5f5760405162461bcd60e51b8152602060048201526013602482015272417373657274696f6e4f75744f6652616e676560681b604482015260640161072d565b6004805460405163030b947760e41b81529182018590526001600160a01b0316906330b947709060240160206040518083038186803b158015611ea157600080fd5b505afa158015611eb5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ed9919061418d565b816002015414611f2b5760405162461bcd60e51b815260206004820152601760248201527f506172656e74417373657274696f6e556e7374616b6564000000000000000000604482015260640161072d565b611f3582846137ca565b505050565b336000908152607460205260409020546001600160a01b0316611f6f5760405162461bcd60e51b815260040161072d9061413a565b611f7b60766000613b67565b565b6038546001600160a01b03163314611fa75760405162461bcd60e51b815260040161072d9061435b565b60005b81811015611f35576000603b6000858585818110611fca57611fca614231565b9050602002016020810190611fdf9190613c31565b6001600160a01b03166001600160a01b0316815260200190815260200160002054905080603b6000603c6001603c8054905061201b91906141c1565b8154811061202b5761202b614231565b60009182526020808320909101546001600160a01b03168352820192909252604001902055603c8054612060906001906141c1565b8154811061207057612070614231565b600091825260209091200154603c80546001600160a01b03909216918390811061209c5761209c614231565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550603c8054806120db576120db614390565b600082815260208120820160001990810180546001600160a01b0319169055909101909155603b9085858581811061211557612115614231565b905060200201602081019061212a9190613c31565b6001600160a01b0316815260208101919091526040016000908120555080612151816141a6565b915050611faa565b6038546001600160a01b031633146121835760405162461bcd60e51b815260040161072d9061435b565b60005b81811015611f35576000603960008585858181106121a6576121a6614231565b90506020020160208101906121bb9190613c31565b6001600160a01b03166001600160a01b031681526020019081526020016000205490508060396000603a6001603a805490506121f791906141c1565b8154811061220757612207614231565b60009182526020808320909101546001600160a01b03168352820192909252604001902055603a805461223c906001906141c1565b8154811061224c5761224c614231565b600091825260209091200154603a80546001600160a01b03909216918390811061227857612278614231565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550603a8054806122b7576122b7614390565b600082815260208120820160001990810180546001600160a01b03191690559091019091556039908585858181106122f1576122f1614231565b90506020020160208101906123069190613c31565b6001600160a01b031681526020810191909152604001600090812055508061232d816141a6565b915050612186565b336000908152607460205260409020546001600160a01b031661236a5760405162461bcd60e51b815260040161072d9061413a565b336000908152607460209081526040808320546001600160a01b039081168085526073909352922060040154909116156124005760405162461bcd60e51b815260206004820152603160248201527f63616e206e6f742063726561746520617373657274696f6e207768656e207374604482015270616b657220696e206368616c6c656e676560781b606482015260840161072d565b6001600160a01b038181166000908152607360205260409081902060020154600154600480549351634e04886d60e01b8152908101839052919390921690634e04886d9060240160206040518083038186803b15801561245f57600080fd5b505afa158015612473573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612497919061418d565b6124a190436141c1565b10156124ef5760405162461bcd60e51b815260206004820152601f60248201527f4d696e696d756d417373657274696f6e506572696f644e6f7450617373656400604482015260640161072d565b60048054604051632b27e93b60e01b81529182018390526001600160a01b031690632b27e93b9060240160206040518083038186803b15801561253157600080fd5b505afa158015612545573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612569919061418d565b83116125a85760405162461bcd60e51b815260206004820152600e60248201526d22b6b83a3ca0b9b9b2b93a34b7b760911b604482015260640161072d565b607180549060006125b8836141a6565b9091555050607154604080519182523360208301528101859052606081018490527f5c610f28399ecc14b66149012a0197a5e3257a8c397125afee95d1cf4b9507349060800160405180910390a16004546071546001600160a01b039091169063422815849086868561262961388f565b6040516001600160e01b031960e088901b1681526004810195909552602485019390935260448401919091526064830152608482015260a401600060405180830381600087803b15801561267c57600080fd5b505af1158015612690573d6000803e3d6000fd5b505050506126a0826071546137ca565b606f80549060006126b0836141a6565b9091555050606f5460708190556040519081527f453430d123684340024ae0a229704bdab39c93dc48bb5a0b4bc83142d95d48ef9060200160405180910390a150505050565b6038546001600160a01b031633146127205760405162461bcd60e51b815260040161072d9061435b565b603c5460005b828110156119ba576127388183614175565b603b600086868581811061274e5761274e614231565b90506020020160208101906127639190613c31565b6001600160a01b03168152602081019190915260400160002055603c84848381811061279157612791614231565b90506020020160208101906127a69190613c31565b81546001810183556000928352602090922090910180546001600160a01b0319166001600160a01b03909216919091179055806127e2816141a6565b915050612726565b60048054607054604051632b27e93b60e01b8152928301526000916001600160a01b0390911690632b27e93b9060240160206040518083038186803b15801561283257600080fd5b505afa158015612846573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061286a919061418d565b905090565b600054600160a81b900460ff161580801561289757506000546001600160a01b90910460ff16105b806128b85750303b1580156128b85750600054600160a01b900460ff166001145b61291b5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161072d565b6000805460ff60a01b1916600160a01b1790558015612948576000805460ff60a81b1916600160a81b1790555b6001600160a01b038d16158061296557506001600160a01b038c16155b156129a05760405162461bcd60e51b815260206004820152600b60248201526a5a65726f4164647265737360a81b604482015260640161072d565b8c603860006101000a8154816001600160a01b0302191690836001600160a01b031602179055508a600360006101000a8154816001600160a01b0302191690836001600160a01b031602179055508b600560006101000a8154816001600160a01b0302191690836001600160a01b0316021790555060006001600160a01b031660008054906101000a90046001600160a01b03166001600160a01b031614612a815760405162461bcd60e51b81526020600482015260146024820152731499591d5b99185b9d125b9a5d1a585b1a5e995960621b604482015260640161072d565b600080546001600160a01b0319166001600160a01b038c8116919091179091556004541615612ae95760405162461bcd60e51b81526020600482015260146024820152731499591d5b99185b9d125b9a5d1a585b1a5e995960621b604482015260640161072d565b600480546001600160a01b0319166001600160a01b038b16908117825560018a905560028990556040516303b31b8360e11b8152309281019290925290630766370690602401600060405180830381600087803b158015612b4957600080fd5b505af1158015612b5d573d6000803e3d6000fd5b50506000606f819055607081905560718190556004805460405163108a056160e21b8152918201839052602482018b90526044820183905260648201929092524360848201526001600160a01b0390911692506342281584915060a401600060405180830381600087803b158015612bd457600080fd5b505af1158015612be8573d6000803e3d6000fd5b50505050612bf685856118c6565b612c0083836126f6565b8015612c48576000805460ff60a81b19169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050505050505050565b6038546001600160a01b03163314612c815760405162461bcd60e51b815260040161072d9061435b565b6000612cb86040518060400160405280601481526020017329ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760611b815250611618565b90506000816001600160a01b0316858585604051602401612cdb939291906143a6565b60408051601f198184030181529181526020820180516001600160e01b03166305f9daf960e11b17905251612d10919061433f565b6000604051808303816000865af19150503d8060008114612d4d576040519150601f19603f3d011682016040523d82523d6000602084013e612d52565b606091505b50509050806115115760405162461bcd60e51b815260206004820152601b60248201527f63616c6c20726f6c6c4261636b4c32436861696e206661696c65640000000000604482015260640161072d565b6038546001600160a01b03163314612dcd5760405162461bcd60e51b815260040161072d9061435b565b6000612e046040518060400160405280601481526020017329ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760611b815250611618565b60408051600481526024810182526020810180516001600160e01b0316633958777760e21b17905290519192506000916001600160a01b03841691612e489161433f565b6000604051808303816000865af19150503d8060008114612e85576040519150601f19603f3d011682016040523d82523d6000602084013e612e8a565b606091505b50915050600081612e9a906143c5565b8451909150612ea990826141c1565b600114612f045760405162461bcd60e51b8152602060048201526024808201527f64656c657465206261746368207769746820676170206973206e6f7420616c6c6044820152631bddd95960e21b606482015260840161072d565b6000836001600160a01b031685604051602401612f2191906143ec565b60408051601f198184030181529181526020820180516001600160e01b0316632da6c87160e11b17905251612f56919061433f565b6000604051808303816000865af19150503d8060008114612f93576040519150601f19603f3d011682016040523d82523d6000602084013e612f98565b606091505b5050905080612ffb5760405162461bcd60e51b815260206004820152602960248201527f7363632064656c657465207374617465206261746368206661696c65642c2072604482015268195d995c9d08185b1b60ba1b606482015260840161072d565b606f5460715410156130665760405162461bcd60e51b815260206004820152602e60248201527f64656c65746520617373657274696f6e206265666f7265206c6173742072657360448201526d37b63b32b21034b71032b93937b960911b606482015260840161072d565b7f5b24ab8ceb442373727ac5c559a027521cb52db451c74710ebed9faa5fe15a7c60715460405161309991815260200190565b60405180910390a16004805460715460405163d0087d6160e01b8152928301526001600160a01b03169063d0087d6190602401600060405180830381600087803b1580156130e657600080fd5b505af11580156130fa573d6000803e3d6000fd5b50506071805492509050600061310f8361444d565b9091555050606f80549060006131248361444d565b9091555050607080549060006131398361444d565b919050555060005b603a548110156131e85760715460736000603a848154811061316557613165614231565b60009182526020808320909101546001600160a01b0316835282019290925260400190206002015411156131d65760715460736000603a84815481106131ad576131ad614231565b60009182526020808320909101546001600160a01b031683528201929092526040019020600201555b806131e0816141a6565b915050613141565b505050505050565b6038546001600160a01b0316331461321a5760405162461bcd60e51b815260040161072d9061435b565b6001600160a01b03811661327f5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161072d565b611615816139c2565b336000908152607460205260409020546001600160a01b03166132bd5760405162461bcd60e51b815260040161072d9061413a565b6001600160a01b0380831660009081526074602052604080822054848416835291205490821691166132ee8161361b565b60006132fa8383613a14565b9050336001600160a01b038216146133435760405162461bcd60e51b815260206004820152600c60248201526b4e6f744368616c6c656e676560a01b604482015260640161072d565b6001600160a01b0382166000908152607360205260408120600101546002548111156133ad5760025461337690826141c1565b6001600160a01b0385166000908152607560205260408120805490919061339e908490614175565b909155505060025491506133b1565b8091505b6001600160a01b038516600090815260736020526040812060010180548492906133dc908490614175565b90915550506001600160a01b0380861660009081526073602052604080822060040180546001600160a01b03191690559186168152206002015461341f85613adf565b604080518082019091526001600160a01b03958616815260208101918252607680546001808201835560009290925291517fb5732705f5241370a28908c2fe1303cb223f03b90d857fd0573f003f79fefed4600290930292830180546001600160a01b031916919098161790965590517fb5732705f5241370a28908c2fe1303cb223f03b90d857fd0573f003f79fefed59091015550506077805460ff191690921790915550505050565b6038546001600160a01b031633146134f45760405162461bcd60e51b815260040161072d9061435b565b6134fd8161361b565b6001600160a01b03811660009081526073602052604090206070546002820154111561356b5760405162461bcd60e51b815260206004820152601c60248201527f5374616b65644f6e556e636f6e6669726d6564417373657274696f6e00000000604482015260640161072d565b600181015461357983613adf565b60035460405163a9059cbb60e01b81526001600160a01b038581166004830152602482018490529091169063a9059cbb90604401602060405180830381600087803b1580156135c757600080fd5b505af11580156135db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135ff91906141d8565b611f355760405162461bcd60e51b815260040161072d906141fa565b6001600160a01b03811660009081526073602052604090205460ff166116155760405162461bcd60e51b8152602060048201526009602482015268139bdd14dd185ad95960ba1b604482015260640161072d565b6136788161361b565b6001600160a01b0381811660009081526073602052604090206004015416156116155760405162461bcd60e51b815260206004820152601060248201526f21b430b63632b733b2b229ba30b5b2b960811b604482015260640161072d565b600080805b6076548110156137c357600454607680546001600160a01b039092169163873fd0899187918590811061371057613710614231565b600091825260209091206002909102015460405160e084901b6001600160e01b031916815260048101929092526001600160a01b0316602482015260440160206040518083038186803b15801561376657600080fd5b505afa15801561377a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061379e91906141d8565b156137b157816137ad816141a6565b9250505b806137bb816141a6565b9150506136db565b5092915050565b6001600160a01b038281166000818152607360205260409081902060020184905560048054915163541961d760e11b815290810185905260248101929092529091169063a832c3ae90604401600060405180830381600087803b15801561383057600080fd5b505af1158015613844573d6000803e3d6000fd5b5050604080516001600160a01b0386168152602081018590527f617d31491414a4ab2bd831e566a31837fa7fb6582921c91dffbbe83fbca789f3935001905060405180910390a15050565b6000806138c76040518060400160405280601481526020017329ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760611b815250611618565b60408051600481526024810182526020810180516001600160e01b031663c17b291b60e01b179052905191925060009182916001600160a01b0385169161390e919061433f565b6000604051808303816000865af19150503d806000811461394b576040519150601f19603f3d011682016040523d82523d6000602084013e613950565b606091505b5091509150816139a25760405162461bcd60e51b815260206004820181905260248201527f63616c6c2046524155445f50524f4f465f57494e444f572829206661696c6564604482015260640161072d565b60006139ad826143c5565b90506139b98142614175565b94505050505090565b603880546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b03808316600090815260736020526040808220848416835290822060048201549293919290911680613a805760405162461bcd60e51b815260206004820152600e60248201526d4e6f74496e4368616c6c656e676560901b604482015260640161072d565b60048201546001600160a01b03828116911614613ad65760405162461bcd60e51b8152602060048201526014602482015273496e446966666572656e744368616c6c656e676560601b604482015260640161072d565b95945050505050565b60728054906000613aef8361444d565b90915550506001600160a01b039081166000908152607360209081526040808320600381018054825460ff1916835560018301869055600283018690556001600160a01b03198082169092556004909201805482169055941683526074909152902080549091169055565b6119048061446583390190565b508054600082556002029060005260206000209081019061161591905b80821115613ba95780546001600160a01b031916815560006001820155600201613b84565b5090565b600060208284031215613bbf57600080fd5b5035919050565b80604081018310156111c657600080fd5b60008060808385031215613bea57600080fd5b613bf48484613bc6565b9150613c038460408501613bc6565b90509250929050565b6001600160a01b038116811461161557600080fd5b8035613c2c81613c0c565b919050565b600060208284031215613c4357600080fd5b8135613c4e81613c0c565b9392505050565b634e487b7160e01b600052604160045260246000fd5b60405160c0810167ffffffffffffffff81118282101715613c8e57613c8e613c55565b60405290565b600067ffffffffffffffff80841115613caf57613caf613c55565b604051601f8501601f19908116603f01168101908282118183101715613cd757613cd7613c55565b81604052809350858152868686011115613cf057600080fd5b858560208301376000602087830101525050509392505050565b600060208284031215613d1c57600080fd5b813567ffffffffffffffff811115613d3357600080fd5b8201601f81018413613d4457600080fd5b613d5384823560208401613c94565b949350505050565b60008083601f840112613d6d57600080fd5b50813567ffffffffffffffff811115613d8557600080fd5b6020830191508360208260051b8501011115613da057600080fd5b9250929050565b600080600080600080600060a0888a031215613dc257600080fd5b8735965060208801359550604088013567ffffffffffffffff80821115613de857600080fd5b613df48b838c01613d5b565b909750955060608a0135945060808a0135915080821115613e1457600080fd5b818a0191508a601f830112613e2857600080fd5b813581811115613e3757600080fd5b8b6020828501011115613e4957600080fd5b60208301945080935050505092959891949750929550565b60008060208385031215613e7457600080fd5b823567ffffffffffffffff811115613e8b57600080fd5b613e9785828601613d5b565b90969095509350505050565b60008060408385031215613eb657600080fd5b823591506020830135613ec881613c0c565b809150509250929050565b60008060408385031215613ee657600080fd5b50508035926020909101359150565b6000806000806000806000806000806000806101408d8f031215613f1857600080fd5b613f218d613c21565b9b50613f2f60208e01613c21565b9a50613f3d60408e01613c21565b9950613f4b60608e01613c21565b9850613f5960808e01613c21565b975060a08d0135965060c08d0135955060e08d0135945067ffffffffffffffff6101008e01351115613f8a57600080fd5b613f9b8e6101008f01358f01613d5b565b909450925067ffffffffffffffff6101208e01351115613fba57600080fd5b613fcb8e6101208f01358f01613d5b565b81935080925050509295989b509295989b509295989b565b600082601f830112613ff457600080fd5b613c4e83833560208501613c94565b60008060006060848603121561401857600080fd5b8335925060208401359150604084013567ffffffffffffffff81111561403d57600080fd5b61404986828701613fe3565b9150509250925092565b60006020828403121561406557600080fd5b813567ffffffffffffffff8082111561407d57600080fd5b9083019060c0828603121561409157600080fd5b614099613c6b565b823581526020830135602082015260408301356040820152606083013560608201526080830135828111156140cd57600080fd5b6140d987828601613fe3565b60808301525060a0830135828111156140f157600080fd5b6140fd87828601613fe3565b60a08301525095945050505050565b6000806040838503121561411f57600080fd5b823561412a81613c0c565b91506020830135613ec881613c0c565b6020808252600b908201526a2737ba27b832b930ba37b960a91b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b600082198211156141885761418861415f565b500190565b60006020828403121561419f57600080fd5b5051919050565b60006000198214156141ba576141ba61415f565b5060010190565b6000828210156141d3576141d361415f565b500390565b6000602082840312156141ea57600080fd5b81518015158114613c4e57600080fd5b6020808252601b908201527f7472616e7366657220657263323020746f6b656e206661696c65640000000000604082015260600190565b634e487b7160e01b600052603260045260246000fd5b60005b8381101561426257818101518382015260200161424a565b838111156119ba5750506000910152565b6000815180845261428b816020860160208601614247565b601f01601f19169290920160200192915050565b602081526000613c4e6020830184614273565b6000602082840312156142c457600080fd5b8151613c4e81613c0c565b6060808252810185905260006001600160fb1b038611156142ef57600080fd5b8560051b80886080850137602083018690528201828103608090810160408501528101849052838560a0830137600060a0858301015260a0601f19601f8601168201019150509695505050505050565b60008251614351818460208701614247565b9190910192915050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b634e487b7160e01b600052603160045260246000fd5b838152826020820152606060408201526000613ad66060830184614273565b805160208083015191908110156143e6576000198160200360031b1b821691505b50919050565b60208152815160208201526020820151604082015260408201516060820152606082015160808201526000608083015160c060a084015261443060e0840182614273565b905060a0840151601f198483030160c0850152613ad68282614273565b60008161445c5761445c61415f565b50600019019056fe608060405234801561001057600080fd5b506118e4806100206000396000f3fe608060405234801561001057600080fd5b50600436106101375760003560e01c80638b299903116100b8578063dfbf53ae1161007c578063dfbf53ae146102a3578063e87e3589146102b6578063ed5b1303146102be578063f03a7fcb146102c7578063f2858aa3146102da578063faeff41b146102ed57600080fd5b80638b2999031461022c5780638f2400a8146102465780639afd9d7814610259578063abf480131461027d578063afeae9651461029057600080fd5b8063631acced116100ff578063631acced146101aa57806370dea79a146101b2578063732e6961146101ba5780637f4c91c5146102115780638a8cd2181461022457600080fd5b806318ef160d1461013c5780632a51f6f71461015157806341e8510c1461016d578063534db0e2146101765780635f41e3d6146101a1575b600080fd5b61014f61014a366004611333565b6102f6565b005b61015a60085481565b6040519081526020015b60405180910390f35b61015a60065481565b600354610189906001600160a01b031681565b6040516001600160a01b039091168152602001610164565b61015a60055481565b61014f6105d0565b61014f610636565b6010546011546012546013546014546015546016546101dc9695949392919087565b604080519788526020880196909652948601939093526060850191909152608084015260a083015260c082015260e001610164565b600254610189906001600160a01b031681565b6101896106c9565b6007546102399060ff1681565b604051610164919061136b565b61014f610254366004611385565b61075b565b600e5461026d90600160a01b900460ff1681565b6040519015158152602001610164565b61014f61028b3660046113fc565b610b55565b61015a61029e366004611473565b610cae565b600e54610189906001600160a01b031681565b61015a610cc5565b61015a60045481565b61014f6102d53660046114d5565b610d13565b61014f6102e8366004611579565b611018565b61015a600f5481565b6102fe6106c9565b6001600160a01b0316336001600160a01b0316146040518060400160405280600a8152602001692124a9afa9a2a72222a960b11b8152509061035c5760405162461bcd60e51b815260040161035391906115a2565b60405180910390fd5b50610365610cc5565b60045461037290426115f7565b11156040518060400160405280600c81526020016b4249535f444541444c494e4560a01b815250906103b75760405162461bcd60e51b815260040161035391906115a2565b5060085460408051808201909152600f81526e4348414c5f494e49545f535441544560881b602082015290156104005760405162461bcd60e51b815260040161035391906115a2565b50600081116104455760405162461bcd60e51b8152602060048201526011602482015270494e56414c49445f4e554d5f535445505360781b6044820152606401610353565b604080516000602080830191909152818301849052825180830384018152606090920190925280519101206008556040805160e08082018352600c548083526020808401879052600d54848601819052436060808701829052426080808901829052600060a0808b0182905260c09a8b018d9052601089905560118e9055601287905560138690556014849055601582905560168d90558b519889529688018d90529987019490945290850191909152908301528101939093529082018390527f71809f4d4f7bf3c208a85ccd3c922c984024f8e3cef51e3d03ae677e4217097d910160405180910390a1600160075460ff16600281111561054957610549611355565b141561057e5760045461055c90426115f7565b60065461056991906115f7565b6006556007805460ff191660021790556105c8565b600260075460ff16600281111561059757610597611355565b14156105c8576004546105aa90426115f7565b6005546105b791906115f7565b6005556007805460ff191660011790555b505042600455565b600e54600160a01b900460ff16156106215760405162461bcd60e51b8152602060048201526014602482015273414c52454144595f5345545f524f4c4c4241434b60601b6044820152606401610353565b600e805460ff60a01b1916600160a01b179055565b61063e610cc5565b60045461064b90426115f7565b116040518060400160405280601081526020016f54494d454f55545f444541444c494e4560801b815250906106935760405162461bcd60e51b815260040161035391906115a2565b50600260075460ff1660028111156106ad576106ad611355565b14156106bf576106bd60016111f4565b565b6106bd6001611257565b6000600260075460ff1660028111156106e4576106e4611355565b14156106fa57506002546001600160a01b031690565b600160075460ff16600281111561071357610713611355565b141561072957506003546001600160a01b031690565b60405162461bcd60e51b81526020600482015260076024820152662727afaa2aa92760c91b6044820152606401610353565b6107636106c9565b6001600160a01b0316336001600160a01b0316146040518060400160405280600a8152602001692124a9afa9a2a72222a960b11b815250906107b85760405162461bcd60e51b815260040161035391906115a2565b506107c1610cc5565b6004546107ce90426115f7565b11156040518060400160405280600c81526020016b4249535f444541444c494e4560a01b815250906108135760405162461bcd60e51b815260040161035391906115a2565b506008546108555760405162461bcd60e51b815260206004820152600f60248201526e1393d517d253925512505312569151608a1b6044820152606401610353565b604080516020808201859052818301849052825180830384018152606090920190925280519101206008548114604051806040016040528060088152602001672124a9afa82922ab60c11b815250906108c15760405162461bcd60e51b815260040161035391906115a2565b50600a541561091b57600954873514806108dd5750600a548735145b61091b5760405162461bcd60e51b815260206004820152600f60248201526e1053509251d553d554d7d4d5105495608a1b6044820152606401610353565b600b546040880135141561095f5760405162461bcd60e51b815260206004820152600b60248201526a1253959053125117d1539160aa1b6044820152606401610353565b6000841161099b5760405162461bcd60e51b81526020600482015260096024820152681513d3d7d4d213d49560ba1b6044820152606401610353565b8635600955602080880135600a55604080890135600b558051808301889052808201879052815180820383018152606090910190915280519101206008556040805160e081018252883581526020808a0135908201529081018860026020908102919091013582524382820181905242604080850182905260608086018c905260809586018b905286516010558685015160115586820151601255868101516013558686015160145560a08088015160155560c09788015160165582518f3581528f870135968101969096528e8301358684015290850193909352938301528101889052918201869052517f71809f4d4f7bf3c208a85ccd3c922c984024f8e3cef51e3d03ae677e4217097d9181900360e00190a150600160075460ff166002811115610aca57610aca611355565b1415610aff57600454610add90426115f7565b600654610aea91906115f7565b6006556007805460ff19166002179055610b49565b600260075460ff166002811115610b1857610b18611355565b1415610b4957600454610b2b90426115f7565b600554610b3891906115f7565b6005556007805460ff191660011790555b50504260045550505050565b600060075460ff166002811115610b6e57610b6e611355565b146040518060400160405280600f81526020016e4348414c5f494e49545f535441544560881b81525090610bb55760405162461bcd60e51b815260040161035391906115a2565b506001600160a01b03871615801590610bd657506001600160a01b03861615155b8015610bea57506001600160a01b03841615155b610c255760405162461bcd60e51b815260206004820152600c60248201526b5a45524f5f4144445245535360a01b6044820152606401610353565b600280546001600160a01b03199081166001600160a01b03998a16178255600380548216988a1698909817909755600180548816968916969096179095556000805490961693909616929092178455600c829055600d8590556007805460ff19169093179092554260045560966005819055600655600955600a91909155600b91909155600f55565b60098160038110610cbe57600080fd5b0154905081565b6000600260075460ff166002811115610ce057610ce0611355565b1415610ced575060055490565b600160075460ff166002811115610d0657610d06611355565b1415610729575060065490565b610d1b6106c9565b6001600160a01b0316336001600160a01b0316146040518060400160405280600a8152602001692124a9afa9a2a72222a960b11b81525090610d705760405162461bcd60e51b815260040161035391906115a2565b50610d79610cc5565b600454610d8690426115f7565b11156040518060400160405280600c81526020016b4249535f444541444c494e4560a01b81525090610dcb5760405162461bcd60e51b815260040161035391906115a2565b50604080516020808201859052818301849052825180830384018152606090920190925280519101206008548114604051806040016040528060088152602001672124a9afa82922ab60c11b81525090610e385760405162461bcd60e51b815260040161035391906115a2565b506001610e46600284611632565b1115610e8b5760405162461bcd60e51b8152602060048201526014602482015273424953454354494f4e5f494e434f4d504c45544560601b6044820152606401610353565b600180546000916001600160a01b039091169063625eb72e908b908b90600990610eb5908b6115f7565b60038110610ec557610ec561161c565b01548b8b6040518663ffffffff1660e01b8152600401610ee99594939291906117ac565b60206040518083038186803b158015610f0157600080fd5b505afa158015610f15573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f39919061185f565b905060098560038110610f4e57610f4e61161c565b0154811415610f6657610f6160006112af565b610f70565b610f706000611302565b506001905060075460ff166002811115610f8c57610f8c611355565b1415610fc157600454610f9f90426115f7565b600654610fac91906115f7565b6006556007805460ff1916600217905561100b565b600260075460ff166002811115610fda57610fda611355565b141561100b57600454610fed90426115f7565b600554610ffa91906115f7565b6005556007805460ff191660011790555b5050426004555050505050565b6002546001600160a01b03166110635760405162461bcd60e51b815260206004820152601060248201526f111959995b99195c881b9bdd081cd95d60821b6044820152606401610353565b6002546001600160a01b031633146110b35760405162461bcd60e51b815260206004820152601360248201527221b0b63632b9103737ba103232b332b73232b960691b6044820152606401610353565b600e546001600160a01b03166111005760405162461bcd60e51b81526020600482015260126024820152712237903737ba103430bb32903bb4b73732b960711b6044820152606401610353565b600354600e546001600160a01b03908116911614156111b257801561118f57600054600354600254604051637d3c01f360e11b81526001600160a01b039283166004820152908216602482015291169063fa7803e6906044015b600060405180830381600087803b15801561117457600080fd5b505af1158015611188573d6000803e3d6000fd5b5050505050565b600254600e80546001600160a01b0319166001600160a01b039092169190911790555b600054600254600354604051637d3c01f360e11b81526001600160a01b039283166004820152908216602482015291169063fa7803e69060440161115a565b50565b600354600e80546001600160a01b0319166001600160a01b039283169081179091556002546040517f03f929a9a6b1f0aef5e43cb12b56f862da97ec3de3fda02a52e85f9f3974fb6a9361124c939216908590611878565b60405180910390a150565b600254600e80546001600160a01b0319166001600160a01b039283169081179091556003546040517f03f929a9a6b1f0aef5e43cb12b56f862da97ec3de3fda02a52e85f9f3974fb6a9361124c939216908590611878565b600260075460ff1660028111156112c8576112c8611355565b14156112d7576111f181611257565b600354600e80546001600160a01b0319166001600160a01b039092169190911790556111f1816111f4565b600260075460ff16600281111561131b5761131b611355565b141561132a576111f1816111f4565b6111f181611257565b6000806040838503121561134657600080fd5b50508035926020909101359150565b634e487b7160e01b600052602160045260246000fd5b602081016003831061137f5761137f611355565b91905290565b600080600080600080610100878903121561139f57600080fd5b60608701888111156113b057600080fd5b969896359750505060808701359460a0880135945060c0880135935060e088013592509050565b6001600160a01b03811681146111f157600080fd5b80356113f7816113d7565b919050565b600080600080600080600060e0888a03121561141757600080fd5b8735611422816113d7565b96506020880135611432816113d7565b95506040880135611442816113d7565b94506060880135611452816113d7565b9699959850939660808101359560a0820135955060c0909101359350915050565b60006020828403121561148557600080fd5b5035919050565b60008083601f84011261149e57600080fd5b50813567ffffffffffffffff8111156114b657600080fd5b6020830191508360208285010111156114ce57600080fd5b9250929050565b600080600080600080600060c0888a0312156114f057600080fd5b873567ffffffffffffffff8082111561150857600080fd5b9089019060e0828c03121561151c57600080fd5b90975060208901359060ff8216821461153457600080fd5b9096506040890135908082111561154a57600080fd5b506115578a828b0161148c565b989b979a50986060810135976080820135975060a09091013595509350505050565b60006020828403121561158b57600080fd5b8135801515811461159b57600080fd5b9392505050565b600060208083528351808285015260005b818110156115cf578581018301518582016040015282016115b3565b818111156115e1576000604083870101525b50601f01601f1916929092016040019392505050565b60008282101561161757634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052603260045260246000fd5b60008261164f57634e487b7160e01b600052601260045260246000fd5b500490565b6000823561011e1983360301811261166b57600080fd5b90910192915050565b803567ffffffffffffffff811681146113f757600080fd5b6000808335601e198436030181126116a357600080fd5b830160208101925035905067ffffffffffffffff8111156116c357600080fd5b8036038313156114ce57600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b600061012067ffffffffffffffff61171284611674565b1684526020830135602085015261172b60408401611674565b67ffffffffffffffff166040850152611746606084016113ec565b6001600160a01b031660608501526080838101359085015261176b60a084018461168c565b8260a087015261177e83870182846116d2565b9250505060c083013560c085015260e083013560e08501526101008084013581860152508091505092915050565b60808152600086356117bd816113d7565b6001600160a01b039081166080840152602088013560a0840152604088013560c08401526060880135906117f0826113d7565b1660e08301526118036080880188611654565b60e06101008401526118196101608401826116fb565b60a089013561012085015260c089013561014085015260ff88166020850152905085604084015282810360608401526118538185876116d2565b98975050505050505050565b60006020828403121561187157600080fd5b5051919050565b6001600160a01b0384811682528316602082015260608101600283106118a0576118a0611355565b82604083015294935050505056fea2646970667358221220ccb7efc97baac554457c80cecdacd0363693ddc1ffd8120b287494f2e6e7e88b64736f6c63430008090033a2646970667358221220b2320bae11ac531fb45a91ab63f86f0979c9923b7d16f7e7b868965375a21be764736f6c63430008090033",
  "devdoc": {
    "errors": {
      "AssertionAlreadyResolved()": [
        {
          "details": "Thrown when the assertion is already resolved"
        }
      ],
      "AssertionOutOfRange()": [
        {
          "details": "Thrown when a staker tries to advance stake to invalid assertionId."
        }
      ],
      "ChallengePeriodPending()": [
        {
          "details": "Thrown when the challenge period has not passed"
        }
      ],
      "ChallengedStaker()": [
        {
          "details": "Thrown when the staker is currently in Challenge"
        }
      ],
      "DifferentParent()": [
        {
          "details": "Thrown when the challenger and defender didn't attest to sibling assertions"
        }
      ],
      "EmptyAssertion()": [
        {
          "details": "Thrown when a sender tries to create assertion without any tx."
        }
      ],
      "InDifferentChallenge(address,address)": [
        {
          "details": "Thrown when the two stakers are in different challenge",
          "params": {
            "staker1Challenge": "challenge address of staker 1",
            "staker2Challenge": "challenge address of staker 2"
          }
        }
      ],
      "InboxReadLimitExceeded()": [
        {
          "details": "Thrown when the requested assertion read past the end of current Inbox."
        }
      ],
      "InsufficientStake()": [
        {
          "details": "Thrown when the function is called with Insufficient Stake"
        }
      ],
      "InvalidParent()": [
        {
          "details": "Thrown when the assertion's parent is not the last confirmed assertion"
        }
      ],
      "MinimumAssertionPeriodNotPassed()": [
        {
          "details": "Thrown when a sender tries to create assertion before the minimum assertion time period"
        }
      ],
      "NoStaker()": [
        {
          "details": "Thrown when there are zero stakers"
        }
      ],
      "NoUnresolvedAssertion()": [
        {
          "details": "Thrown when there is no unresolved assertion"
        }
      ],
      "NotAllStaked()": [
        {
          "details": "Thrown when all the stakers are not staked"
        }
      ],
      "NotInChallenge()": [
        {
          "details": "Thrown when the staker is not in a challenge"
        }
      ],
      "NotStaked()": [
        {
          "details": "Thrown when address that have not staked any token calls a only-staked function"
        }
      ],
      "ParentAssertionUnstaked()": [
        {
          "details": "Thrown when a staker tries to advance stake to non-child assertion"
        }
      ],
      "PreviousStateHash()": [
        {
          "details": "Thrown when parent's statehash is not equal to the start state(or previous state)/"
        }
      ],
      "RedundantInitialized()": [
        {
          "details": "Thrown when slot is not blank in initialize step"
        }
      ],
      "StakedOnUnconfirmedAssertion()": [
        {
          "details": "Thrown when the caller is staked on unconfirmed assertion."
        }
      ],
      "StakerStakedOnTarget()": [
        {
          "details": "Thrown staker's assertion is descendant of firstUnresolved assertion"
        }
      ],
      "StakersPresent()": [
        {
          "details": "Thrown when there are staker's present on the assertion"
        }
      ],
      "TransferFailed()": [
        {
          "details": "Thrown when transfer fails"
        }
      ],
      "UnproposedAssertion()": [
        {
          "details": "Thrown when the challenger tries to challenge an unproposed assertion"
        }
      ],
      "WrongOrder()": [
        {
          "details": "Thrown when the challenge assertion Id is not ordered or in range."
        }
      ],
      "ZeroAddress()": [
        {
          "details": "Thrown when function is called with a zero address argument"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "advanceStake(uint256)": {
        "params": {
          "assertionID": "ID of assertion to advance stake to. Currently this must be a child of the current assertion. TODO: generalize to arbitrary descendants."
        }
      },
      "challengeAssertion(address[2],uint256[2])": {
        "params": {
          "assertionIDs": "Assertion IDs of the players engaged in the challenge. The first ID should be the earlier-created and is the one being challenged.",
          "players": "Defender (first) and challenger (second) addresses. Must be staked on DAs on different branches."
        },
        "returns": {
          "_0": "Newly created challenge contract address."
        }
      },
      "completeChallenge(address,address)": {
        "params": {
          "loser": "Address of losing staker.",
          "winner": "Address of winning staker."
        }
      },
      "confirmedInboxSize()": {
        "returns": {
          "_0": "confirmedInboxSize size of inbox confirmed"
        }
      },
      "createAssertion(bytes32,uint256)": {
        "params": {
          "inboxSize": "Size of inbox corresponding to assertion (number of transactions).",
          "vmHash": "New VM hash."
        }
      },
      "createAssertionWithStateBatch(bytes32,uint256,bytes32[],uint256,bytes)": {
        "params": {
          "_batch": "Batch of state roots.",
          "_shouldStartAtElement": "Index of the element at which this batch should start.",
          "_signature": "tss group signature of state batches.",
          "inboxSize": "Size of inbox corresponding to assertion (number of transactions).",
          "vmHash": "New VM hash."
        }
      },
      "currentRequiredStake()": {
        "returns": {
          "_0": "The current required stake amount."
        }
      },
      "isStaked(address)": {
        "params": {
          "addr": "User address."
        },
        "returns": {
          "_0": "True if address is staked, else False."
        }
      },
      "removeStake(address)": {
        "params": {
          "stakerAddress": "Address of staker for which to unstake."
        }
      },
      "resolve(string)": {
        "params": {
          "_name": "Name to resolve an address for."
        },
        "returns": {
          "_0": "Address associated with the given name."
        }
      },
      "rollbackL2Chain(uint256,uint256,bytes)": {
        "params": {
          "_shouldRollBack": "roll back to should start.",
          "_shouldStartAtElement": "Index of the element at which this batch should start",
          "_signature": "signature of rollback message"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "unstake(uint256)": {
        "params": {
          "stakeAmount": "Token amount to withdraw. Must be <= sender's current stake minus the current required stake."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addToOperatorWhitelist(address[])": {
        "notice": "Add to whitelist"
      },
      "addToStakerWhitelist(address[])": {
        "notice": "Add to staker whitelist"
      },
      "advanceStake(uint256)": {
        "notice": "Advances msg.sender's existing sake to assertionID."
      },
      "challengeAssertion(address[2],uint256[2])": {
        "notice": "Initiates a dispute between a defender and challenger on an unconfirmed DA."
      },
      "completeChallenge(address,address)": {
        "notice": "Completes ongoing challenge. Callback, called by a challenge contract."
      },
      "confirmFirstUnresolvedAssertion()": {
        "notice": "Confirms first unresolved assertion. Assertion is confirmed if and only if: (1) there is at least one staker, and (2) challenge period has passed, and (3) predecessor has been confirmed, and (4) all stakers are staked on the assertion."
      },
      "createAssertion(bytes32,uint256)": {
        "notice": "Creates a new DA representing the rollup state after executing a block of transactions (sequenced in SequencerInbox). Block is represented by all transactions in range [prevInboxSize, inboxSize]. The latest staked DA of the sender is considered to be the predecessor. Moves sender stake onto the new DA. The new DA stores the hash of the parameters: vmHash"
      },
      "createAssertionWithStateBatch(bytes32,uint256,bytes32[],uint256,bytes)": {
        "notice": "create assertion with scc state batch"
      },
      "rejectFirstUnresolvedAssertion()": {
        "notice": "Rejects first unresolved assertion. Assertion is rejected if and only if: (1) all of the following are true: (a) challenge period has passed, and (b) at least one staker exists, and (c) no staker remains staked on the assertion (all have been destroyed). OR (2) predecessor has been rejected"
      },
      "removeFromOperatorWhitelist(address[])": {
        "notice": "Remove from whitelist"
      },
      "removeFromStakerWhitelist(address[])": {
        "notice": "Remove from whitelist"
      },
      "removeStake(address)": {
        "notice": "Removes stakerAddress from the set of stakers and withdraws the full stake amount to stakerAddress. This can be called by anyone since it is currently necessary to keep the chain progressing."
      },
      "resolve(string)": {
        "notice": "Resolves the address associated with a given name."
      },
      "rollbackL2Chain(uint256,uint256,bytes)": {
        "notice": "Emit event to notify sequencers to roll back."
      },
      "stake(uint256,address)": {
        "notice": "Deposits stake on staker's current assertion (or the last confirmed assertion if not currently staked).currently use MNT to stake; stakeAmount Token amount to deposit. Must be > than defined threshold if this is a new stake."
      },
      "unstake(uint256)": {
        "notice": "Withdraws stakeAmount from staker's stake by if assertion it is staked on is confirmed."
      },
      "withdraw()": {
        "notice": "Withdraws all of msg.sender's withdrawable funds."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 52622,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "libAddressManager",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Lib_AddressManager)52614"
      },
      {
        "astId": 216,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "_initialized",
        "offset": 20,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 219,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "_initializing",
        "offset": 21,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 14011,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "minimumAssertionPeriod",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 14013,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "baseStakeAmount",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 14016,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "stakeToken",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(IERC20)7331"
      },
      {
        "astId": 14020,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "assertions",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(AssertionMap)13745"
      },
      {
        "astId": 14023,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "verifier",
        "offset": 0,
        "slot": "5",
        "type": "t_contract(IVerifierEntry)24965"
      },
      {
        "astId": 14027,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "rollupBaseGap",
        "offset": 0,
        "slot": "6",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 15740,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "owner",
        "offset": 0,
        "slot": "56",
        "type": "t_address"
      },
      {
        "astId": 15744,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "stakerWhitelist",
        "offset": 0,
        "slot": "57",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 15747,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "stakerslist",
        "offset": 0,
        "slot": "58",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 15751,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "operatorWhitelist",
        "offset": 0,
        "slot": "59",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 15754,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "operatorslist",
        "offset": 0,
        "slot": "60",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 15758,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "whitelistGap",
        "offset": 0,
        "slot": "61",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 14099,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "lastResolvedAssertionID",
        "offset": 0,
        "slot": "111",
        "type": "t_uint256"
      },
      {
        "astId": 14101,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "lastConfirmedAssertionID",
        "offset": 0,
        "slot": "112",
        "type": "t_uint256"
      },
      {
        "astId": 14103,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "lastCreatedAssertionID",
        "offset": 0,
        "slot": "113",
        "type": "t_uint256"
      },
      {
        "astId": 14105,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "numStakers",
        "offset": 0,
        "slot": "114",
        "type": "t_uint256"
      },
      {
        "astId": 14110,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "stakers",
        "offset": 0,
        "slot": "115",
        "type": "t_mapping(t_address,t_struct(Staker)14038_storage)"
      },
      {
        "astId": 14114,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "registers",
        "offset": 0,
        "slot": "116",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 14118,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "withdrawableFunds",
        "offset": 0,
        "slot": "117",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 14122,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "zombies",
        "offset": 0,
        "slot": "118",
        "type": "t_array(t_struct(Zombie)14043_storage)dyn_storage"
      },
      {
        "astId": 14125,
        "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
        "label": "challengeCtx",
        "offset": 0,
        "slot": "119",
        "type": "t_struct(ChallengeCtx)14056_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(Zombie)14043_storage)dyn_storage": {
        "base": "t_struct(Zombie)14043_storage",
        "encoding": "dynamic_array",
        "label": "struct RollupBase.Zombie[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(AssertionMap)13745": {
        "encoding": "inplace",
        "label": "contract AssertionMap",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)7331": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IVerifierEntry)24965": {
        "encoding": "inplace",
        "label": "contract IVerifierEntry",
        "numberOfBytes": "20"
      },
      "t_contract(Lib_AddressManager)52614": {
        "encoding": "inplace",
        "label": "contract Lib_AddressManager",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_struct(Staker)14038_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct RollupBase.Staker)",
        "numberOfBytes": "32",
        "value": "t_struct(Staker)14038_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(ChallengeCtx)14056_storage": {
        "encoding": "inplace",
        "label": "struct RollupBase.ChallengeCtx",
        "members": [
          {
            "astId": 14045,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "completed",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 14047,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "challengeAddress",
            "offset": 1,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 14049,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "defenderAddress",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 14051,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "challengerAddress",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 14053,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "defenderAssertionID",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 14055,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "challengerAssertionID",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(Staker)14038_storage": {
        "encoding": "inplace",
        "label": "struct RollupBase.Staker",
        "members": [
          {
            "astId": 14029,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "isStaked",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 14031,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "amountStaked",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 14033,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "assertionID",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 14035,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "operator",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 14037,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "currentChallenge",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(Zombie)14043_storage": {
        "encoding": "inplace",
        "label": "struct RollupBase.Zombie",
        "members": [
          {
            "astId": 14040,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "stakerAddress",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 14042,
            "contract": "contracts/L1/fraud-proof/Rollup.sol:Rollup",
            "label": "lastAssertionID",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}