{
  "language": "Solidity",
  "sources": {
    "contracts/L1/delegation/Delegation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"./DelegationStorage.sol\";\nimport \"./DelegationSlasher.sol\";\nimport \"./WhiteListBase.sol\";\n/**\n * @title The primary delegation contract.\n * @notice  This is the contract for delegation. The main functionalities of this contract are\n * - for enabling any staker to register as a delegate and specify the delegation terms it has agreed to\n * - for enabling anyone to register as an operator\n * - for a registered staker to delegate its stake to the operator of its agreed upon delegation terms contract\n * - for a staker to undelegate its assets\n * - for anyone to challenge a staker's claim to have fulfilled all its obligation before undelegation\n */\nabstract contract Delegation is Initializable, OwnableUpgradeable, PausableUpgradeable, WhiteList, DelegationStorage {\n    /// @notice Simple permission for functions that are only callable by the InvestmentManager contract.\n    modifier onlyDelegationManager() {\n        require(msg.sender == address(delegationManager), \"onlyDelegationManager\");\n        _;\n    }\n\n    // INITIALIZING FUNCTIONS\n    constructor(IDelegationManager _delegationManager)\n        DelegationStorage(_delegationManager)\n    {\n        _disableInitializers();\n    }\n\n    /// @dev Emitted when a low-level call to `delegationTerms.onDelegationReceived` fails, returning `returnData`\n    event OnDelegationReceivedCallFailure(IDelegationCallback indexed delegationTerms, bytes32 returnData);\n\n    /// @dev Emitted when a low-level call to `delegationTerms.onDelegationWithdrawn` fails, returning `returnData`\n    event OnDelegationWithdrawnCallFailure(IDelegationCallback indexed delegationTerms, bytes32 returnData);\n\n    event RegisterOperator(address delegationCallback, address register);\n\n    event DelegateTo(address delegatior, address operator);\n\n    event DecreaseDelegatedShares(address delegatedShare, address operator, uint256 share);\n\n    event IncreaseDelegatedShares(address delegatedShare, address operator, uint256 share);\n\n    function initialize(address initialOwner)\n        external\n        initializer\n    {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, bytes(\"Mantle\"), block.chainid, address(this)));\n        _transferOwnership(initialOwner);\n    }\n\n    // PERMISSION FUNCTIONS\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // EXTERNAL FUNCTIONS\n    /**\n     * @notice This will be called by an operator to register itself as an operator that stakers can choose to delegate to.\n     * @param dt is the `DelegationTerms` contract that the operator has for those who delegate to them.\n     * @dev An operator can set `dt` equal to their own address (or another EOA address), in the event that they want to split payments\n     * in a more 'trustful' manner.\n     * @dev In the present design, once set, there is no way for an operator to ever modify the address of their DelegationTerms contract.\n     */\n    function registerAsOperator(IDelegationCallback dt) external whitelistOnly(msg.sender) {\n        require(\n            address(delegationCallback[msg.sender]) == address(0),\n            \"Delegation.registerAsOperator: Delegate has already registered\"\n        );\n        // store the address of the delegation contract that the operator is providing.\n        delegationCallback[msg.sender] = dt;\n        _delegate(msg.sender, msg.sender);\n        emit RegisterOperator(address(dt),msg.sender);\n    }\n\n    /**\n     *  @notice This will be called by a staker to delegate its assets to some operator.\n     *  @param operator is the operator to whom staker (msg.sender) is delegating its assets\n     */\n    function delegateTo(address operator) external whenNotPaused {\n        _delegate(msg.sender, operator);\n    }\n\n    /**\n     * @notice Delegates from `staker` to `operator`.\n     * @dev requires that r, vs are a valid ECSDA signature from `staker` indicating their intention for this action\n     */\n    function delegateToSignature(address staker, address operator, uint256 expiry, bytes32 r, bytes32 vs)\n        external\n        whenNotPaused\n    {\n        require(expiry == 0 || expiry >= block.timestamp, \"delegation signature expired\");\n        // calculate struct hash, then increment `staker`'s nonce\n        // EIP-712 standard\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, staker, operator, nonces[staker]++, expiry));\n        bytes32 digestHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, structHash));\n        //check validity of signature\n\n        address recoveredAddress = ECDSA.recover(digestHash, r, vs);\n\n        require(recoveredAddress == staker, \"Delegation.delegateToBySignature: sig not from staker\");\n        _delegate(staker, operator);\n    }\n\n    /**\n     * @notice Undelegates `staker` from the operator who they are delegated to.\n     * @notice Callable only by the InvestmentManager\n     * @dev Should only ever be called in the event that the `staker` has no active deposits.\n     */\n    function undelegate(address staker) external onlyDelegationManager {\n        delegationStatus[staker] = DelegationStatus.UNDELEGATED;\n        delegatedTo[staker] = address(0);\n    }\n\n    /**\n     * @notice Increases the `staker`'s delegated shares in `strategy` by `shares, typically called when the staker has further deposits\n     * @dev Callable only by the InvestmentManager\n     */\n    function increaseDelegatedShares(address staker, IDelegationShare delegationShare, uint256 shares)\n        external\n        onlyDelegationManager\n    {\n        //if the staker is delegated to an operator\n        if (isDelegated(staker)) {\n            address operator = delegatedTo[staker];\n\n            // add strategy shares to delegate's shares\n            operatorShares[operator][delegationShare] += shares;\n\n            //Calls into operator's delegationTerms contract to update weights of individual staker\n            IDelegationShare[] memory investorDelegations = new IDelegationShare[](1);\n            uint256[] memory investorShares = new uint[](1);\n            investorDelegations[0] = delegationShare;\n            investorShares[0] = shares;\n\n            // call into hook in delegationCallback contract\n            IDelegationCallback dt = delegationCallback[operator];\n            _delegationReceivedHook(dt, staker, operator, investorDelegations, investorShares);\n            emit IncreaseDelegatedShares(address(delegationShare), operator, shares);\n        }\n    }\n\n    /**\n     * @notice Decreases the `staker`'s delegated shares in `strategy` by `shares, typically called when the staker withdraws\n     * @dev Callable only by the InvestmentManager\n     */\n    function decreaseDelegatedShares(address staker, IDelegationShare delegationShare, uint256 shares)\n        external\n        onlyDelegationManager\n    {\n        //if the staker is delegated to an operator\n        if (isDelegated(staker)) {\n            address operator = delegatedTo[staker];\n\n            // subtract strategy shares from delegate's shares\n            operatorShares[operator][delegationShare] -= shares;\n\n            //Calls into operator's delegationCallback contract to update weights of individual staker\n            IDelegationShare[] memory investorDelegationShares = new IDelegationShare[](1);\n            uint256[] memory investorShares = new uint[](1);\n            investorDelegationShares[0] = delegationShare;\n            investorShares[0] = shares;\n\n            // call into hook in delegationCallback contract\n            IDelegationCallback dt = delegationCallback[operator];\n            _delegationWithdrawnHook(dt, staker, operator, investorDelegationShares, investorShares);\n            emit DecreaseDelegatedShares(address(delegationShare), operator, shares);\n        }\n    }\n\n    /// @notice Version of `decreaseDelegatedShares` that accepts an array of inputs.\n    function decreaseDelegatedShares(\n        address staker,\n        IDelegationShare[] calldata strategies,\n        uint256[] calldata shares\n    )\n        external\n        onlyDelegationManager\n    {\n        if (isDelegated(staker)) {\n            address operator = delegatedTo[staker];\n\n            // subtract strategy shares from delegate's shares\n            uint256 stratsLength = strategies.length;\n            for (uint256 i = 0; i < stratsLength;) {\n                operatorShares[operator][strategies[i]] -= shares[i];\n                emit DecreaseDelegatedShares(address(strategies[i]), operator, shares[i]);\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // call into hook in delegationCallback contract\n            IDelegationCallback dt = delegationCallback[operator];\n            _delegationWithdrawnHook(dt, staker, operator, strategies, shares);\n        }\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /**\n     * @notice Makes a low-level call to `dt.onDelegationReceived(staker, strategies, shares)`, ignoring reverts and with a gas budget\n     * equal to `LOW_LEVEL_GAS_BUDGET` (a constant defined in this contract).\n     * @dev *If* the low-level call fails, then this function emits the event `OnDelegationReceivedCallFailure(dt, returnData)`, where\n     * `returnData` is *only the first 32 bytes* returned by the call to `dt`.\n     */\n    function _delegationReceivedHook(\n        IDelegationCallback dt,\n        address staker,\n        address operator,\n        IDelegationShare[] memory delegationShares,\n        uint256[] memory shares\n    )\n        internal\n    {\n        /**\n         * We use low-level call functionality here to ensure that an operator cannot maliciously make this function fail in order to prevent undelegation.\n         * In particular, in-line assembly is also used to prevent the copying of uncapped return data which is also a potential DoS vector.\n         */\n        // format calldata\n        (bool success, bytes memory returnData) = address(dt).call{gas: LOW_LEVEL_GAS_BUDGET}(\n            abi.encodeWithSelector(IDelegationCallback.onDelegationReceived.selector, staker, operator, delegationShares, shares)\n        );\n\n        // if the call fails, we emit a special event rather than reverting\n        if (!success) {\n            emit OnDelegationReceivedCallFailure(dt, returnData[0]);\n        }\n    }\n\n    /**\n     * @notice Makes a low-level call to `dt.onDelegationWithdrawn(staker, strategies, shares)`, ignoring reverts and with a gas budget\n     * equal to `LOW_LEVEL_GAS_BUDGET` (a constant defined in this contract).\n     * @dev *If* the low-level call fails, then this function emits the event `OnDelegationReceivedCallFailure(dt, returnData)`, where\n     * `returnData` is *only the first 32 bytes* returned by the call to `dt`.\n     */\n    function _delegationWithdrawnHook(\n        IDelegationCallback dt,\n        address staker,\n        address operator,\n        IDelegationShare[] memory delegationShares,\n        uint256[] memory shares\n    )\n        internal\n    {\n        /**\n         * We use low-level call functionality here to ensure that an operator cannot maliciously make this function fail in order to prevent undelegation.\n         * In particular, in-line assembly is also used to prevent the copying of uncapped return data which is also a potential DoS vector.\n         */\n\n        (bool success, bytes memory returnData) = address(dt).call{gas: LOW_LEVEL_GAS_BUDGET}(\n            abi.encodeWithSelector(IDelegationCallback.onDelegationWithdrawn.selector, staker, operator, delegationShares, shares)\n        );\n\n        // if the call fails, we emit a special event rather than reverting\n        if (!success) {\n            emit OnDelegationWithdrawnCallFailure(dt, returnData[0]);\n        }\n    }\n\n    /**\n     * @notice Internal function implementing the delegation *from* `staker` *to* `operator`.\n     * @param staker The address to delegate *from* -- this address is delegating control of its own assets.\n     * @param operator The address to delegate *to* -- this address is being given power to place the `staker`'s assets at risk on services\n     * @dev Ensures that the operator has registered as a delegate (`address(dt) != address(0)`), verifies that `staker` is not already\n     * delegated, and records the new delegation.\n     */\n    function _delegate(address staker, address operator) internal {\n\n        IDelegationCallback dt = delegationCallback[operator];\n        require(\n            address(dt) != address(0), \"Delegation._delegate: operator has not yet registered as a delegate\"\n        );\n        require(isNotDelegated(staker), \"Delegation._delegate: staker has existing delegation\");\n\n        // checks that operator has not been frozen\n        IDelegationSlasher slasher = delegationManager.delegationSlasher();\n        require(!slasher.isFrozen(operator), \"Delegation._delegate: cannot delegate to a frozen operator\");\n        // record delegation relation between the staker and operator\n        delegatedTo[staker] = operator;\n\n        // record that the staker is delegated\n        delegationStatus[staker] = DelegationStatus.DELEGATED;\n        // retrieve list of strategies and their shares from investment manager\n        (IDelegationShare[] memory delegationShares, uint256[] memory shares) = delegationManager.getDeposits(staker);\n\n        // add strategy shares to delegate's shares\n        uint256 delegationLength = delegationShares.length;\n        for (uint256 i = 0; i < delegationLength;) {\n            // update the share amounts for each of the operator's strategies\n            operatorShares[operator][delegationShares[i]] += shares[i];\n            unchecked {\n                ++i;\n            }\n        }\n        // call into hook in delegationCallback contract\n        _delegationReceivedHook(dt, staker, operator, delegationShares, shares);\n        emit DelegateTo(staker, operator);\n    }\n\n    // VIEW FUNCTIONS\n\n    /// @notice Returns 'true' if `staker` *is* actively delegated, and 'false' otherwise.\n    function isDelegated(address staker) public view returns (bool) {\n        return (delegationStatus[staker] == DelegationStatus.DELEGATED);\n    }\n\n    /// @notice Returns 'true' if `staker` is *not* actively delegated, and 'false' otherwise.\n    function isNotDelegated(address staker) public view returns (bool) {\n        return (delegationStatus[staker] == DelegationStatus.UNDELEGATED);\n    }\n\n    /// @notice Returns if an operator can be delegated to, i.e. it has called `registerAsOperator`.\n    function isOperator(address operator) external view returns (bool) {\n        return (address(delegationCallback[operator]) != address(0));\n    }\n}\n"
    },
    "contracts/L1/delegation/DelegationStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./interfaces/IDelegationManager.sol\";\nimport \"./interfaces/IDelegationCallback.sol\";\nimport \"./interfaces/IDelegation.sol\";\n\n/**\n * @title Storage variables for the `Delegation` contract.\n * @author Layr Labs, Inc.\n * @notice This storage contract is separate from the logic to simplify the upgrade process.\n */\nabstract contract DelegationStorage is IDelegation {\n    /// @notice Gas budget provided in calls to DelegationTerms contracts\n    uint256 internal constant LOW_LEVEL_GAS_BUDGET = 1e5;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegator,address operator,uint256 nonce,uint256 expiry)\");\n\n    /// @notice EIP-712 Domain separator\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice The InvestmentManager contract\n    IDelegationManager public immutable delegationManager;\n\n    // operator => investment strategy => total number of shares delegated to them\n    mapping(address => mapping(IDelegationShare => uint256)) public operatorShares;\n\n    // operator => delegation terms contract\n    mapping(address => IDelegationCallback) public delegationCallback;\n\n    // staker => operator\n    mapping(address => address) public delegatedTo;\n\n    // staker => whether they are delegated or not\n    mapping(address => IDelegation.DelegationStatus) public delegationStatus;\n\n    // delegator => number of signed delegation nonce (used in delegateToBySignature)\n    mapping(address => uint256) public nonces;\n\n    constructor(IDelegationManager _investmentManager) {\n        delegationManager = _investmentManager;\n    }\n}\n"
    },
    "contracts/L1/delegation/DelegationSlasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"./interfaces/IDelegationSlasher.sol\";\nimport \"./interfaces/IDelegation.sol\";\nimport \"./interfaces/IDelegationManager.sol\";\n\n/**\n * @title The primary 'slashing' contract.\n * @notice This contract specifies details on slashing. The functionalities are:\n * - adding contracts who have permission to perform slashing,\n * - revoking permission for slashing from specified contracts,\n * - calling investManager to do actual slashing.\n */\nabstract contract DelegationSlasher is Initializable, OwnableUpgradeable, PausableUpgradeable, IDelegationSlasher {\n    // ,DSTest\n    /// @notice The central InvestmentManager contract\n    IDelegationManager public immutable investmentManager;\n    /// @notice The Delegation contract\n    IDelegation public immutable delegation;\n    // contract address => whether or not the contract is allowed to slash any staker (or operator)\n    mapping(address => bool) public globallyPermissionedContracts;\n    // user => contract => the time before which the contract is allowed to slash the user\n    mapping(address => mapping(address => uint32)) public bondedUntil;\n    // staker => if their funds are 'frozen' and potentially subject to slashing or not\n    mapping(address => bool) internal frozenStatus;\n\n    uint32 internal constant MAX_BONDED_UNTIL = type(uint32).max;\n\n    event GloballyPermissionedContractAdded(address indexed contractAdded);\n    event GloballyPermissionedContractRemoved(address indexed contractRemoved);\n    event OptedIntoSlashing(address indexed operator, address indexed contractAddress);\n    event SlashingAbilityRevoked(address indexed operator, address indexed contractAddress, uint32 unbondedAfter);\n    event OperatorSlashed(address indexed slashedOperator, address indexed slashingContract);\n    event FrozenStatusReset(address indexed previouslySlashedAddress);\n\n    constructor(IDelegationManager _investmentManager, IDelegation _delegation) {\n        investmentManager = _investmentManager;\n        delegation = _delegation;\n        _disableInitializers();\n    }\n\n    // EXTERNAL FUNCTIONS\n    function initialize(\n        address initialOwner\n    ) external initializer {\n        _transferOwnership(initialOwner);\n        // add InvestmentManager & Delegation to list of permissioned contracts\n        _addGloballyPermissionedContract(address(investmentManager));\n        _addGloballyPermissionedContract(address(delegation));\n    }\n\n    /**\n     * @notice Gives the `contractAddress` permission to slash the funds of the caller.\n     * @dev Typically, this function must be called prior to registering for a middleware.\n     */\n    function allowToSlash(address contractAddress) external {\n        _optIntoSlashing(msg.sender, contractAddress);\n    }\n\n    /*\n     TODO: we still need to figure out how/when to appropriately call this function\n     perhaps a registry can safely call this function after an operator has been deregistered for a very safe amount of time (like a month)\n    */\n    /// @notice Called by a contract to revoke its ability to slash `operator`, once `unbondedAfter` is reached.\n    function revokeSlashingAbility(address operator, uint32 unbondedAfter) external {\n        _revokeSlashingAbility(operator, msg.sender, unbondedAfter);\n    }\n\n    /**\n     * @notice Used for 'slashing' a certain operator.\n     * @param toBeFrozen The operator to be frozen.\n     * @dev Technically the operator is 'frozen' (hence the name of this function), and then subject to slashing pending a decision by a human-in-the-loop.\n     * @dev The operator must have previously given the caller (which should be a contract) the ability to slash them, through a call to `allowToSlash`.\n     */\n    function freezeOperator(address toBeFrozen) external whenNotPaused {\n        require(\n            canSlash(toBeFrozen, msg.sender),\n            \"Slasher.freezeOperator: msg.sender does not have permission to slash this operator\"\n        );\n        _freezeOperator(toBeFrozen, msg.sender);\n    }\n\n    /**\n     * @notice Used to give global slashing permission to `contracts`.\n     * @dev Callable only by the contract owner (i.e. governance).\n     */\n    function addGloballyPermissionedContracts(address[] calldata contracts) external onlyOwner {\n        for (uint256 i = 0; i < contracts.length;) {\n            _addGloballyPermissionedContract(contracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Used to revoke global slashing permission from `contracts`.\n     * @dev Callable only by the contract owner (i.e. governance).\n     */\n    function removeGloballyPermissionedContracts(address[] calldata contracts) external onlyOwner {\n        for (uint256 i = 0; i < contracts.length;) {\n            _removeGloballyPermissionedContract(contracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Removes the 'frozen' status from each of the `frozenAddresses`\n     * @dev Callable only by the contract owner (i.e. governance).\n     */\n    function resetFrozenStatus(address[] calldata frozenAddresses) external onlyOwner {\n        for (uint256 i = 0; i < frozenAddresses.length;) {\n            _resetFrozenStatus(frozenAddresses[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // INTERNAL FUNCTIONS\n    function _optIntoSlashing(address operator, address contractAddress) internal {\n        //allow the contract to slash anytime before a time VERY far in the future\n        bondedUntil[operator][contractAddress] = MAX_BONDED_UNTIL;\n        emit OptedIntoSlashing(operator, contractAddress);\n    }\n\n    function _revokeSlashingAbility(address operator, address contractAddress, uint32 unbondedAfter) internal {\n        if (bondedUntil[operator][contractAddress] == MAX_BONDED_UNTIL) {\n            //contractAddress can now only slash operator before unbondedAfter\n            bondedUntil[operator][contractAddress] = unbondedAfter;\n            emit SlashingAbilityRevoked(operator, contractAddress, unbondedAfter);\n        }\n    }\n\n    function _addGloballyPermissionedContract(address contractToAdd) internal {\n        if (!globallyPermissionedContracts[contractToAdd]) {\n            globallyPermissionedContracts[contractToAdd] = true;\n            emit GloballyPermissionedContractAdded(contractToAdd);\n        }\n    }\n\n    function _removeGloballyPermissionedContract(address contractToRemove) internal {\n        if (globallyPermissionedContracts[contractToRemove]) {\n            globallyPermissionedContracts[contractToRemove] = false;\n            emit GloballyPermissionedContractRemoved(contractToRemove);\n        }\n    }\n\n    function _freezeOperator(address toBeFrozen, address slashingContract) internal {\n        if (!frozenStatus[toBeFrozen]) {\n            frozenStatus[toBeFrozen] = true;\n            emit OperatorSlashed(toBeFrozen, slashingContract);\n        }\n    }\n\n    function _resetFrozenStatus(address previouslySlashedAddress) internal {\n        if (frozenStatus[previouslySlashedAddress]) {\n            frozenStatus[previouslySlashedAddress] = false;\n            emit FrozenStatusReset(previouslySlashedAddress);\n        }\n    }\n\n    // VIEW FUNCTIONS\n    /**\n     * @notice Used to determine whether `staker` is actively 'frozen'. If a staker is frozen, then they are potentially subject to\n     * slashing of their funds, and cannot cannot deposit or withdraw from the investmentManager until the slashing process is completed\n     * and the staker's status is reset (to 'unfrozen').\n     * @return Returns 'true' if `staker` themselves has their status set to frozen, OR if the staker is delegated\n     * to an operator who has their status set to frozen. Otherwise returns 'false'.\n     */\n    function isFrozen(address staker) external view returns (bool) {\n        if (frozenStatus[staker]) {\n            return true;\n        } else if (delegation.isDelegated(staker)) {\n            address operatorAddress = delegation.delegatedTo(staker);\n            return (frozenStatus[operatorAddress]);\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Returns true if `slashingContract` is currently allowed to slash `toBeSlashed`.\n    function canSlash(address toBeSlashed, address slashingContract) public view returns (bool) {\n        if (globallyPermissionedContracts[slashingContract]) {\n            return true;\n        } else if (block.timestamp < bondedUntil[toBeSlashed][slashingContract]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "contracts/L1/delegation/WhiteListBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract WhiteList is OwnableUpgradeable {\n    modifier whitelistOnly(address checkAddr) {\n        if (!whitelist[checkAddr]) {\n            revert(\"NOT_IN_WHITELIST\");\n        }\n        _;\n    }\n\n    mapping(address => bool) public whitelist;\n\n    /**\n     * @notice Add to whitelist\n     */\n    function addToWhitelist(address[] calldata toAddAddresses) external onlyOwner {\n        for (uint i = 0; i < toAddAddresses.length; i++) {\n            whitelist[toAddAddresses[i]] = true;\n        }\n    }\n\n    /**\n     * @notice Remove from whitelist\n     */\n    function removeFromWhitelist(address[] calldata toRemoveAddresses) external onlyOwner {\n        for (uint i = 0; i < toRemoveAddresses.length; i++) {\n            delete whitelist[toRemoveAddresses[i]];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/L1/delegation/interfaces/IDelegationManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./IDelegationShare.sol\";\nimport \"./IDelegationSlasher.sol\";\nimport \"./IDelegation.sol\";\n\n/**\n * @title Interface for the primary entrypoint for funds.\n * @author Layr Labs, Inc.\n * @notice See the `DelegationManager` contract itself for implementation details.\n */\ninterface IDelegationManager {\n    // used for storing details of queued withdrawals\n    struct WithdrawalStorage {\n        uint32 initTimestamp;\n        uint32 unlockTimestamp;\n        address withdrawer;\n    }\n\n    // packed struct for queued withdrawals\n    struct WithdrawerAndNonce {\n        address withdrawer;\n        uint96 nonce;\n    }\n\n    /**\n     * Struct type used to specify an existing queued withdrawal. Rather than storing the entire struct, only a hash is stored.\n     * In functions that operate on existing queued withdrawals -- e.g. `startQueuedWithdrawalWaitingPeriod` or `completeQueuedWithdrawal`,\n     * the data is resubmitted and the hash of the submitted data is computed by `calculateWithdrawalRoot` and checked against the\n     * stored hash in order to confirm the integrity of the submitted data.\n     */\n    struct QueuedWithdrawal {\n        IDelegationShare[] delegations;\n        IERC20[] tokens;\n        uint256[] shares;\n        address depositor;\n        WithdrawerAndNonce withdrawerAndNonce;\n        address delegatedAddress;\n    }\n\n    /**\n     * @notice Deposits `amount` of `token` into the specified `DelegationShare`, with the resultant shares credited to `depositor`\n     * @param delegationShare is the specified shares record where investment is to be made,\n     * @param token is the ERC20 token in which the investment is to be made,\n     * @param amount is the amount of token to be invested in the delegationShare by the depositor\n     */\n    function depositInto(IDelegationShare delegationShare, IERC20 token, uint256 amount)\n        external\n        returns (uint256);\n\n    /// @notice Returns the current shares of `user` in `delegationShare`\n    function investorDelegationShares(address user, IDelegationShare delegationShare) external view returns (uint256 shares);\n\n    /**\n     * @notice Get all details on the depositor's investments and corresponding shares\n     * @return (depositor's delegationShare record, shares in these DelegationShare contract)\n     */\n    function getDeposits(address depositor) external view returns (IDelegationShare[] memory, uint256[] memory);\n\n    /// @notice Simple getter function that returns `investorDelegations[staker].length`.\n    function investorDelegationLength(address staker) external view returns (uint256);\n\n    /**\n     * @notice Called by a staker to queue a withdraw in the given token and shareAmount from each of the respective given strategies.\n     * @dev Stakers will complete their withdrawal by calling the 'completeQueuedWithdrawal' function.\n     * User shares are decreased in this function, but the total number of shares in each delegation strategy remains the same.\n     * The total number of shares is decremented in the 'completeQueuedWithdrawal' function instead, which is where\n     * the funds are actually sent to the user through use of the delegation strategies' 'withdrawal' function. This ensures\n     * that the value per share reported by each strategy will remain consistent, and that the shares will continue\n     * to accrue gains during the enforced WITHDRAWAL_WAITING_PERIOD.\n     * @param delegationShareIndexes is a list of the indices in `investorDelegationShare[msg.sender]` that correspond to the delegation strategies\n     * for which `msg.sender` is withdrawing 100% of their shares\n     * @dev strategies are removed from `delegationShare` by swapping the last entry with the entry to be removed, then\n     * popping off the last entry in `delegationShares`. The simplest way to calculate the correct `delegationShareIndexes` to input\n     * is to order the strategies *for which `msg.sender` is withdrawing 100% of their shares* from highest index in\n     * `delegationShares` to lowest index\n     */\n    function queueWithdrawal(\n        uint256[] calldata delegationShareIndexes,\n        IDelegationShare[] calldata delegationShares,\n        IERC20[] calldata tokens,\n        uint256[] calldata shareAmounts,\n        WithdrawerAndNonce calldata withdrawerAndNonce,\n        bool undelegateIfPossible\n    )\n        external returns(bytes32);\n\n    function startQueuedWithdrawalWaitingPeriod(\n        bytes32 withdrawalRoot,\n        uint32 stakeInactiveAfter\n    ) external;\n\n    /**\n     * @notice Used to complete the specified `queuedWithdrawal`. The function caller must match `queuedWithdrawal.withdrawer`\n     * @param queuedWithdrawal The QueuedWithdrawal to complete.\n     * @param receiveAsTokens If true, the shares specified in the queued withdrawal will be withdrawn from the specified delegation strategies themselves\n     * and sent to the caller, through calls to `queuedWithdrawal.strategies[i].withdraw`. If false, then the shares in the specified delegation strategies\n     * will simply be transferred to the caller directly.\n     */\n    function completeQueuedWithdrawal(\n        QueuedWithdrawal calldata queuedWithdrawal,\n        bool receiveAsTokens\n    )\n        external;\n\n    /**\n     * @notice Slashes the shares of 'frozen' operator (or a staker delegated to one)\n     * @param slashedAddress is the frozen address that is having its shares slashes\n     * @param delegationShareIndexes is a list of the indices in `investorStrats[msg.sender]` that correspond to the strategies\n     * for which `msg.sender` is withdrawing 100% of their shares\n     * @param recipient The slashed funds are withdrawn as tokens to this address.\n     * @dev strategies are removed from `investorStrats` by swapping the last entry with the entry to be removed, then\n     * popping off the last entry in `investorStrats`. The simplest way to calculate the correct `strategyIndexes` to input\n     * is to order the strategies *for which `msg.sender` is withdrawing 100% of their shares* from highest index in\n     * `investorStrats` to lowest index\n     */\n    function slashShares(\n        address slashedAddress,\n        address recipient,\n        IDelegationShare[] calldata delegationShares,\n        IERC20[] calldata tokens,\n        uint256[] calldata delegationShareIndexes,\n        uint256[] calldata shareAmounts\n    )\n        external;\n\n    function slashQueuedWithdrawal(\n        address recipient,\n        QueuedWithdrawal calldata queuedWithdrawal\n    )\n        external;\n\n    /**\n     * @notice Used to check if a queued withdrawal can be completed. Returns 'true' if the withdrawal can be immediately\n     * completed, and 'false' otherwise.\n     * @dev This function will revert if the specified `queuedWithdrawal` does not exist\n     */\n    function canCompleteQueuedWithdrawal(\n        QueuedWithdrawal calldata queuedWithdrawal\n    )\n        external\n        returns (bool);\n\n    /// @notice Returns the keccak256 hash of `queuedWithdrawal`.\n    function calculateWithdrawalRoot(\n        QueuedWithdrawal memory queuedWithdrawal\n    )\n        external\n        pure\n        returns (bytes32);\n\n    /// @notice Returns the single, central Delegation contract\n    function delegation() external view returns (IDelegation);\n\n    /// @notice Returns the single, central DelegationSlasher contract\n    function delegationSlasher() external view returns (IDelegationSlasher);\n}\n"
    },
    "contracts/L1/delegation/interfaces/IDelegationCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./IDelegationShare.sol\";\n\n/**\n * @title Abstract interface for a contract that helps structure the delegation relationship.\n * @notice The gas budget provided to this contract in calls from contracts is limited.\n */\n//TODO: discuss if we can structure the inputs of these functions better\ninterface IDelegationCallback {\n    function payForService(IERC20 token, uint256 amount) external payable;\n\n    function onDelegationReceived(\n        address delegator,\n        address operator,\n        IDelegationShare[] memory delegationShares,\n        uint256[] memory investorShares\n    ) external;\n\n    function onDelegationWithdrawn(\n        address delegator,\n        address operator,\n        IDelegationShare[] memory delegationShares,\n        uint256[] memory investorShares\n    ) external;\n}\n"
    },
    "contracts/L1/delegation/interfaces/IDelegation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./IDelegationCallback.sol\";\n\n/**\n * @title Interface for the primary delegation contract.\n * @notice See the `Delegation` contract itself for implementation details.\n */\ninterface IDelegation {\n    enum DelegationStatus {\n        UNDELEGATED,\n        DELEGATED\n    }\n\n    /**\n     * @notice This will be called by an operator to register itself as an operator that stakers can choose to delegate to.\n     * @param dt is the `DelegationTerms` contract that the operator has for those who delegate to them.\n     * @dev An operator can set `dt` equal to their own address (or another EOA address), in the event that they want to split payments\n     * in a more 'trustful' manner.\n     * @dev In the present design, once set, there is no way for an operator to ever modify the address of their DelegationTerms contract.\n     */\n    function registerAsOperator(IDelegationCallback dt) external;\n\n    /**\n     *  @notice This will be called by a staker to delegate its assets to some operator.\n     *  @param operator is the operator to whom staker (msg.sender) is delegating its assets\n     */\n    function delegateTo(address operator) external;\n\n    /**\n     * @notice Delegates from `staker` to `operator`.\n     * @dev requires that r, vs are a valid ECSDA signature from `staker` indicating their intention for this action\n     */\n    function delegateToSignature(address staker, address operator, uint256 expiry, bytes32 r, bytes32 vs) external;\n\n    /**\n     * @notice Undelegates `staker` from the operator who they are delegated to.\n     * @notice Callable only by the InvestmentManager\n     * @dev Should only ever be called in the event that the `staker` has no active deposits.\n     */\n    function undelegate(address staker) external;\n\n    /// @notice returns the address of the operator that `staker` is delegated to.\n    function delegatedTo(address staker) external view returns (address);\n\n    /// @notice returns the delegationCallback of the `operator`, which may mediate their interactions with stakers who delegate to them.\n    function delegationCallback(address operator) external view returns (IDelegationCallback);\n\n    /// @notice returns the total number of shares in `DelegationShare` that are delegated to `operator`.\n    function operatorShares(address operator, IDelegationShare delegationShare) external view returns (uint256);\n\n    /// @notice Returns 'true' if `staker` *is* actively delegated, and 'false' otherwise.\n    function isDelegated(address staker) external view returns (bool);\n\n    /// @notice Returns 'true' if `staker` is *not* actively delegated, and 'false' otherwise.\n    function isNotDelegated(address staker) external returns (bool);\n\n    /// @notice Returns if an operator can be delegated to, i.e. it has called `registerAsOperator`.\n    function isOperator(address operator) external view returns (bool);\n\n    /**\n     * @notice Increases the `staker`'s delegated shares in `delegationShare` by `shares`, typically called when the staker has further deposits.\n     * @dev Callable only by the DelegationManager\n     */\n    function increaseDelegatedShares(address staker, IDelegationShare delegationShare, uint256 shares) external;\n\n    /**\n     * @notice Decreases the `staker`'s delegated shares in `delegationShare` by `shares, typically called when the staker withdraws\n     * @dev Callable only by the DelegationManager\n     */\n    function decreaseDelegatedShares(address staker, IDelegationShare delegationShare, uint256 shares) external;\n\n    /// @notice Version of `decreaseDelegatedShares` that accepts an array of inputs.\n    function decreaseDelegatedShares(\n        address staker,\n        IDelegationShare[] calldata delegationShares,\n        uint256[] calldata shares\n    ) external;\n}\n"
    },
    "contracts/L1/delegation/interfaces/IDelegationShare.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Minimal interface for an `IDelegationShares` contract.\n * @notice Custom `DelegationShares` implementations may expand extensively on this interface.\n */\ninterface IDelegationShare {\n    /**\n     * @notice Used to deposit tokens into this DelegationShares\n     * @param token is the ERC20 token being deposited\n     * @param amount is the amount of token being deposited\n     * @dev This function is only callable by the delegationManager contract. It is invoked inside of the delegationManager's\n     * `depositInto` function, and individual share balances are recorded in the delegationManager as well.\n     * @return newShares is the number of new shares issued at the current exchange ratio.\n     */\n    function deposit(address depositor, IERC20 token, uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Used to withdraw tokens from this DelegationLedger, to the `depositor`'s address\n     * @param token is the ERC20 token being transferred out\n     * @param amountShares is the amount of shares being withdrawn\n     * @dev This function is only callable by the delegationManager contract. It is invoked inside of the delegationManager's\n     * other functions, and individual share balances are recorded in the delegationManager as well.\n     */\n    function withdraw(address depositor, IERC20 token, uint256 amountShares) external;\n\n    /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @dev Implementation for these functions in particular may vary signifcantly for different strategies\n     */\n    function sharesToUnderlying(uint256 amountShares) external returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this ledger.\n     * @notice In contrast to `underlyingToSharesView`, this function **may** make state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into ledger shares\n     * @dev Implementation for these functions in particular may vary signifcantly for different ledgers\n     */\n    function underlyingToShares(uint256 amountUnderlying) external view returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this ledger. In contrast to `userUnderlyingView`, this function **may** make state modifications\n     */\n    function userUnderlying(address user) external returns (uint256);\n\n     /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this ledger.\n     * @notice In contrast to `sharesToUnderlying`, this function guarantees no state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @dev Implementation for these functions in particular may vary signifcantly for different ledgers\n     */\n    function sharesToUnderlyingView(uint256 amountShares) external view returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this ledger.\n     * @notice In contrast to `underlyingToShares`, this function guarantees no state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into ledger shares\n     * @dev Implementation for these functions in particular may vary signifcantly for different ledgers\n     */\n    function underlyingToSharesView(uint256 amountUnderlying) external view returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this ledger. In contrast to `userUnderlying`, this function guarantees no state modifications\n     */\n    function userUnderlyingView(address user) external view returns (uint256);\n\n    /// @notice The underyling token for shares in this DelegationShares\n    function underlyingToken() external view returns (IERC20);\n\n    /// @notice The total number of extant shares in thie InvestmentStrategy\n    function totalShares() external view returns (uint256);\n\n    /// @notice Returns either a brief string explaining the strategy's goal & purpose, or a link to metadata that explains in more detail.\n    function explanation() external view returns (string memory);\n}\n"
    },
    "contracts/L1/delegation/interfaces/IDelegationSlasher.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n/**\n * @title Interface for the primary 'slashing' contract for EigenLayr.\n * @author Layr Labs, Inc.\n * @notice See the `Slasher` contract itself for implementation details.\n */\ninterface IDelegationSlasher {\n    /**\n     * @notice Gives the `contractAddress` permission to slash the funds of the caller.\n     * @dev Typically, this function must be called prior to registering for a middleware.\n     */\n    function allowToSlash(address contractAddress) external;\n\n    /// @notice Called by a contract to revoke its ability to slash `operator`, once `unbondedAfter` is reached.\n    function revokeSlashingAbility(address operator, uint32 unbondedAfter) external;\n\n    /**\n     * @notice Used for 'slashing' a certain operator.\n     * @param toBeFrozen The operator to be frozen.\n     * @dev Technically the operator is 'frozen' (hence the name of this function), and then subject to slashing pending a decision by a human-in-the-loop.\n     * @dev The operator must have previously given the caller (which should be a contract) the ability to slash them, through a call to `allowToSlash`.\n     */\n    function freezeOperator(address toBeFrozen) external;\n\n    /**\n     * @notice Used to determine whether `staker` is actively 'frozen'. If a staker is frozen, then they are potentially subject to\n     * slashing of their funds, and cannot cannot deposit or withdraw from the investmentManager until the slashing process is completed\n     * and the staker's status is reset (to 'unfrozen').\n     * @return Returns 'true' if `staker` themselves has their status set to frozen, OR if the staker is delegated\n     * to an operator who has their status set to frozen. Otherwise returns 'false'.\n     */\n    function isFrozen(address staker) external view returns (bool);\n\n    /// @notice Returns true if `slashingContract` is currently allowed to slash `toBeSlashed`.\n    function canSlash(address toBeSlashed, address slashingContract) external view returns (bool);\n\n    /// @notice Returns the UTC timestamp until which `slashingContract` is allowed to slash the `operator`.\n    function bondedUntil(address operator, address slashingContract) external view returns (uint32);\n\n    /**\n     * @notice Removes the 'frozen' status from each of the `frozenAddresses`\n     * @dev Callable only by the contract owner (i.e. governance).\n     */\n    function resetFrozenStatus(address[] calldata frozenAddresses) external;\n\n    /**\n     * @notice Used to give global slashing permission to `contracts`.\n     * @dev Callable only by the contract owner (i.e. governance).\n     */\n    function addGloballyPermissionedContracts(address[] calldata contracts) external;\n\n    /**\n     * @notice Used to revoke global slashing permission from `contracts`.\n     * @dev Callable only by the contract owner (i.e. governance).\n     */\n    function removeGloballyPermissionedContracts(address[] calldata contracts) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/L1/tss/delegation/TssDelegation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../../delegation/Delegation.sol\";\nimport \"../../delegation/WhiteListBase.sol\";\n\n\n/**\n * @title The primary delegation contract.\n * @notice  This is the contract for delegation. The main functionalities of this contract are\n * - for enabling any staker to register as a delegate and specify the delegation terms it has agreed to\n * - for enabling anyone to register as an operator\n * - for a registered staker to delegate its stake to the operator of its agreed upon delegation terms contract\n * - for a staker to undelegate its assets\n * - for anyone to challenge a staker's claim to have fulfilled all its obligation before undelegation\n */\ncontract TssDelegation is Delegation {\n\n\n    address public stakingSlash;\n\n\n\n\n    // INITIALIZING FUNCTIONS\n    constructor(IDelegationManager _delegationManager)\n    Delegation(_delegationManager)\n    {\n        _disableInitializers();\n    }\n\n\n    function initializeT(\n        address _stakingSlashing,\n        address initialOwner\n    ) external initializer {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, bytes(\"Mantle\"), block.chainid, address(this)));\n        stakingSlash = _stakingSlashing;\n         _transferOwnership(initialOwner);\n    }\n\n    modifier onlyStakingSlash() {\n        require(msg.sender == stakingSlash, \"contract call is not staking slashing\");\n        _;\n    }\n\n    function setStakingSlash(address _address) public onlyOwner {\n        stakingSlash = _address;\n    }\n\n    function registerAsOperator(IDelegationCallback dt, address sender) external whitelistOnly(sender) onlyStakingSlash {\n\n        require(\n            address(delegationCallback[sender]) == address(0),\n            \"Delegation.registerAsOperator: Delegate has already registered\"\n        );\n        // store the address of the delegation contract that the operator is providing.\n        delegationCallback[sender] = dt;\n        _delegate(sender, sender);\n        emit RegisterOperator(address(dt), sender);\n    }\n\n    function delegateTo(address operator, address staker) external onlyStakingSlash whenNotPaused {\n        _delegate(staker, operator);\n    }\n\n\n}\n"
    },
    "contracts/L1/tss/TssStakingSlashing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {DelegationShareBase} from \"../delegation/DelegationShareBase.sol\";\nimport {DelegationCallbackBase} from \"../delegation/DelegationCallbackBase.sol\";\nimport {IDelegationManager} from \"../delegation/interfaces/IDelegationManager.sol\";\nimport {IDelegationShare} from \"../delegation/interfaces/IDelegation.sol\";\nimport {IDelegation} from \"../delegation/interfaces/IDelegation.sol\";\nimport {CrossDomainEnabled} from \"../../libraries/bridge/CrossDomainEnabled.sol\";\nimport {ITssRewardContract} from \"../../L2/predeploys/iTssRewardContract.sol\";\nimport {TssDelegationManager} from \"./delegation/TssDelegationManager.sol\";\nimport {TssDelegation} from \"./delegation/TssDelegation.sol\";\nimport {WhiteList} from \"../delegation/WhiteListBase.sol\";\nimport {Lib_Address} from \"../../libraries/utils/Lib_Address.sol\";\n\nimport \"./ITssGroupManager.sol\";\nimport \"./ITssStakingSlashing.sol\";\n\ncontract TssStakingSlashing is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IStakingSlashing,\n    DelegationShareBase,\n    DelegationCallbackBase,\n    CrossDomainEnabled\n{\n    enum SlashType {\n        uptime,\n        animus\n    }\n\n    struct SlashMsg {\n        uint256 batchIndex;\n        address jailNode;\n        address[] tssNodes;\n        SlashType slashType;\n    }\n    // tss group contract address\n    address public tssGroupContract;\n    //tss delegation manager address\n    address public tssDelegationManagerContract;\n    //tss delegation address\n    address public tssDelegationContract;\n    // storage operator infos (key:staker address)\n    mapping(address => bytes) public operators;\n\n    // slashing parameter settings\n    // record the quit request\n    address[] public quitRequestList;\n    // slashing amount of type uptime and animus (0:uptime, 1:animus)\n    uint256[2] public slashAmount;\n    // record the slash operate (map[batchIndex] -> (map[staker] -> slashed))\n    mapping(uint256 => mapping(address => bool)) slashRecord;\n    //EOA address\n    address public regulatoryAccount;\n    //msg sender => withdraw event\n    mapping(address => bytes32) public withdrawalRoots;\n    //msg sender => withdrawal\n    mapping(address => IDelegationManager.QueuedWithdrawal) public withdrawals;\n    //operator => stakers\n    mapping(address => address[]) public stakers;\n    //staker => operator\n    mapping(address => address) public delegators;\n    //operator => claimer\n    mapping(address => address) public operatorClaimers;\n    //claimer => operator\n    mapping(address => address) public claimerOperators;\n    bool public isSetParam;\n    address public tssManager;\n\n\n    /**\n     * @notice slash tssnode\n     * @param 0 slashed address\n     * @param 1 slash type\n     */\n    event Slashing(address, SlashType);\n\n    event WithdrawQueue(address,uint256);\n\n    constructor()  CrossDomainEnabled(address(0)) {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes the contract setting and the deployer as the initial owner\n     * @param _mantleToken mantle token contract address\n     * @param _tssGroupContract address tss group manager contract address\n     */\n    function initialize(address _mantleToken,\n        address _tssGroupContract,\n        address _delegationManager,\n        address _delegation,\n        address _l1messenger,\n        address _regulatoryAccount,\n        address _tssManager\n        ) public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        underlyingToken = IERC20(_mantleToken);\n        tssGroupContract = _tssGroupContract;\n        tssDelegationManagerContract = _delegationManager;\n        tssDelegationContract = _delegation;\n        //initialize delegation\n        delegationManager = IDelegationManager(_delegationManager);\n        delegation = IDelegation(_delegation);\n        messenger = _l1messenger;\n        regulatoryAccount = _regulatoryAccount;\n        tssManager = _tssManager;\n    }\n\n    /**\n     * @notice change the mantle token and tssGroup contract address\n     * @param _token the erc20 mantle token contract address\n     */\n    function setTokenAddress(address _token) public onlyOwner {\n        require(_token != address(0),\"Invalid address\");\n        underlyingToken = IERC20(_token);\n    }\n\n    function setTssGroupAddress(address _tssGroup) public onlyOwner{\n        require(_tssGroup != address(0),\"Invalid address\");\n        tssGroupContract = _tssGroup;\n    }\n\n    function setRegulatoryAccount(address _account) public onlyOwner {\n        require(_account != address(0),\"Invalid address\");\n        regulatoryAccount = _account;\n    }\n\n    function setTssManager(address _tssManager) public onlyOwner {\n        require(_tssManager != address(0),\"Invalid address\");\n        tssManager = _tssManager;\n    }\n\n    function setClaimer(\n        address _operator,\n        address _claimer\n    ) external {\n        require(msg.sender == _operator, \"msg sender is diff with operator address\");\n        require(delegation.isOperator(msg.sender), \"msg sender is not registered operator\");\n        require(claimerOperators[_claimer] == address(0), \"the claimer has been used\");\n        if (operatorClaimers[_operator] != address(0)) {\n            delete claimerOperators[operatorClaimers[_operator]];\n        }\n        operatorClaimers[_operator] = _claimer;\n        claimerOperators[_claimer] = _operator;\n\n        bytes memory message = abi.encodeWithSelector(\n            ITssRewardContract.setClaimer.selector,\n            _operator,\n            _claimer\n        );\n        // send call data into L2, hardcode address\n        sendCrossDomainMessage(\n            address(0x4200000000000000000000000000000000000020),\n            2000000,\n            message\n        );\n    }\n\n    /**\n     * @notice set the slashing params (0 -> uptime , 1 -> animus)\n     * @param _slashAmount the amount to be deducted for each type\n     */\n    function setSlashingParams(uint256[2] calldata _slashAmount)\n        public\n        onlyOwner\n    {\n        require(_slashAmount[1] > _slashAmount[0], \"invalid param slashAmount, animus <= uptime\");\n\n        for (uint256 i = 0; i < 2; i++) {\n            require(_slashAmount[i] > 0, \"invalid amount\");\n            slashAmount[i] = _slashAmount[i];\n        }\n        isSetParam = true;\n    }\n\n    /**\n     * @notice set the slashing params (0 -> uptime, 1 -> animus)\n     */\n    function getSlashingParams() public view returns (uint256[2] memory) {\n        return slashAmount;\n    }\n\n    /**\n     * @notice send quit request for the next election\n     */\n    function quitRequest() public nonReentrant {\n\n        require(delegation.operatorShares(msg.sender, this) > 0, \"do not have deposit\");\n        // when not in consensus period\n        require(\n            ITssGroupManager(tssGroupContract).memberExistInActive(operators[msg.sender]) ||\n                ITssGroupManager(tssGroupContract).memberExistActive(operators[msg.sender]),\n            \"not at the inactive group or active group\"\n        );\n        // is active member\n        for (uint256 i = 0; i < quitRequestList.length; i++) {\n            require(quitRequestList[i] != msg.sender, \"already in quitRequestList\");\n        }\n        quitRequestList.push(msg.sender);\n    }\n\n    /**\n     * @notice return the quit list\n     */\n    function getQuitRequestList() public view returns (address[] memory) {\n        return quitRequestList;\n    }\n\n    /**\n     * @notice clear the quit list\n     */\n    function clearQuitRequestList() public onlyOwner {\n        delete quitRequestList;\n    }\n\n    /**\n     * @notice verify the slash message then slash\n     * @param _messageBytes the message that abi encode by type SlashMsg\n     * @param _sig the signature of the hash keccak256(_messageBytes)\n     */\n    function slashing(bytes calldata _messageBytes, bytes calldata _sig) public nonReentrant {\n        require(tssManager == msg.sender,\"TssStakingSlashing: msg.sender is not tssManager\");\n        SlashMsg memory message = abi.decode(_messageBytes, (SlashMsg));\n        // verify tss member state not at jailed status\n        require(!isJailed(message.jailNode), \"the node already jailed\");\n\n        // have not slash before\n        require(!slashRecord[message.batchIndex][message.jailNode], \"already slashed\");\n        slashRecord[message.batchIndex][message.jailNode] = true;\n\n        require(\n            ITssGroupManager(tssGroupContract).verifySign(keccak256(_messageBytes), _sig),\n            \"signer not tss group pub key\"\n        );\n\n        // slash tokens\n        slash(message);\n        emit Slashing(message.jailNode, message.slashType);\n    }\n\n    /**\n     * @notice slash the staker and distribute rewards to voters\n     * @param message the message about the slash infos\n     */\n    function slash(SlashMsg memory message) internal {\n        // slashing params check\n        require(isSetParam,\"have not set the slash amount\");\n        bytes memory jailNodePubKey = operators[message.jailNode];\n        if (message.slashType == SlashType.uptime) {\n            // jail and transfer deposits\n            ITssGroupManager(tssGroupContract).memberJail(jailNodePubKey);\n            transformDeposit(message.jailNode, 0);\n        } else if (message.slashType == SlashType.animus) {\n            // remove the member and transfer deposits\n            ITssGroupManager(tssGroupContract).memberJail(jailNodePubKey);\n            transformDeposit(message.jailNode, 1);\n        } else {\n            revert(\"err type for slashing\");\n        }\n\n    }\n\n    /**\n     * @notice distribute rewards to voters\n     * @param deduction address of the punished\n     * @param slashType the type to punished\n     */\n    function transformDeposit(\n        address deduction,\n        uint256 slashType\n    ) internal {\n        uint256 deductedAmountShare;\n\n        uint256 totalBalance = _tokenBalance();\n\n        require(\n            (delegation.operatorShares(deduction, this) * totalBalance) / totalShares >= slashAmount[slashType],\n            \"do not have enought shares\"\n        );\n        // record total penalty\n        deductedAmountShare = (slashAmount[slashType] * totalShares) / totalBalance;\n\n        uint256 operatorShare = delegation.operatorShares(deduction, this);\n\n        IDelegationShare[] memory delegationShares = new IDelegationShare[](1);\n        delegationShares[0] = this;\n\n        uint256[] memory delegationShareIndexes = new uint256[](1);\n        delegationShareIndexes[0] = 0;\n\n\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = underlyingToken;\n\n        address[] memory stakerS = stakers[deduction];\n        for (uint256 i = 0; i < stakerS.length; i++){\n            uint256 share = shares(stakerS[i]);\n            uint256[] memory shareAmounts = new uint256[](1);\n            shareAmounts[0] = deductedAmountShare * share / operatorShare;\n            TssDelegationManager(tssDelegationManagerContract).slashShares(stakerS[i], regulatoryAccount, delegationShares,tokens, delegationShareIndexes, shareAmounts);\n        }\n\n    }\n\n    /**\n     * @notice set tss node status unjail\n     */\n    function unJail() public {\n        // slashing params check\n        require(isSetParam, \"have not set the slash amount\");\n        require(isJailed(msg.sender), \"An unjailed user doesn't need to call this method\");\n\n        uint256 totalBalance = _tokenBalance();\n\n        require((delegation.operatorShares(msg.sender, this) * totalBalance) / totalShares >= slashAmount[1], \"Insufficient balance\");\n        ITssGroupManager(tssGroupContract).memberUnJail(operators[msg.sender]);\n    }\n\n\n    /**\n     * @notice get the slash record\n     * @param batchIndex the index of batch\n     * @param user address of the staker\n     */\n    function getSlashRecord(uint256 batchIndex, address user) public view returns (bool) {\n        return slashRecord[batchIndex][user];\n    }\n\n    /**\n     * @notice check the tssnode status\n     * @param user address of the staker\n     */\n    function isJailed(address user) public returns (bool) {\n        ITssGroupManager.TssMember memory tssMember = ITssGroupManager(tssGroupContract)\n            .getTssMember(operators[user]);\n        require(tssMember.publicKey.length == 64, \"tss member not exist\");\n        return tssMember.status == ITssGroupManager.MemberStatus.jail;\n    }\n\n    function isCanOperator(address _addr) public returns (bool) {\n        return TssDelegationManager(tssDelegationManagerContract).isCanOperator(_addr, this);\n    }\n\n    function deposit(uint256 amount) public returns (uint256) {\n       uint256 shares = TssDelegationManager(tssDelegationManagerContract).depositInto(this, underlyingToken, amount, msg.sender);\n       return shares;\n    }\n\n    function withdraw() external {\n        require(delegation.isDelegated(msg.sender),\"not delegator\");\n\n        require(\n            withdrawalRoots[msg.sender] == bytes32(0),\n            \"msg sender already request withdraws\"\n        );\n\n        uint256[] memory delegationIndexes = new uint256[](1);\n        delegationIndexes[0] = 0;\n        IDelegationShare[] memory delegationShares = new IDelegationShare[](1);\n        delegationShares[0] = this;\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = underlyingToken;\n        uint256[] memory sharesA = new uint256[](1);\n        sharesA[0] = shares(msg.sender);\n        uint256 nonce = TssDelegationManager(tssDelegationManagerContract).getWithdrawNonce(msg.sender);\n        IDelegationManager.WithdrawerAndNonce memory withdrawerAndNonce = IDelegationManager.WithdrawerAndNonce({\n            withdrawer: msg.sender,\n            nonce: SafeCast.toUint96(nonce)\n        });\n        address operator = delegation.delegatedTo(msg.sender);\n\n        IDelegationManager.QueuedWithdrawal memory queuedWithdrawal = IDelegationManager.QueuedWithdrawal({\n            delegations: delegationShares,\n            tokens: tokens,\n            shares: sharesA,\n            depositor: msg.sender,\n            withdrawerAndNonce: withdrawerAndNonce,\n            delegatedAddress: operator\n        });\n        withdrawals[msg.sender] = queuedWithdrawal;\n        bytes32 withdrawRoot = TssDelegationManager(tssDelegationManagerContract).queueWithdrawal(msg.sender,delegationIndexes,delegationShares,tokens,sharesA,withdrawerAndNonce);\n        withdrawalRoots[msg.sender] = withdrawRoot;\n        emit WithdrawQueue(msg.sender, sharesA[0]);\n    }\n\n    function startWithdraw() external {\n        require(\n            withdrawalRoots[msg.sender] != bytes32(0),\n            \"msg sender must request withdraw first\"\n        );\n        bytes32 withdrawRoot = withdrawalRoots[msg.sender];\n        TssDelegationManager(tssDelegationManagerContract).startQueuedWithdrawalWaitingPeriod(withdrawRoot,msg.sender,0);\n    }\n\n    function canCompleteQueuedWithdrawal() external returns (bool) {\n\n        require(\n            withdrawalRoots[msg.sender] != bytes32(0),\n            \"msg sender did not request withdraws\"\n        );\n        IDelegationManager.QueuedWithdrawal memory queuedWithdrawal = withdrawals[msg.sender];\n        return delegationManager.canCompleteQueuedWithdrawal(queuedWithdrawal);\n    }\n\n    function completeWithdraw() external {\n\n        require(\n            withdrawalRoots[msg.sender] != bytes32(0),\n            \"msg sender did not request withdraws\"\n        );\n        IDelegationManager.QueuedWithdrawal memory queuedWithdrawal = withdrawals[msg.sender];\n        TssDelegationManager(tssDelegationManagerContract).completeQueuedWithdrawal(msg.sender, queuedWithdrawal, true);\n        delete withdrawalRoots[msg.sender];\n        delete withdrawals[msg.sender];\n    }\n\n    function registerAsOperator(bytes calldata _pubKey) external {\n        require(msg.sender == Lib_Address.publicKeyToAddress(_pubKey), \"public key not match\");\n        TssDelegation(tssDelegationContract).registerAsOperator(this, msg.sender);\n        operators[msg.sender] = _pubKey;\n    }\n\n    function delegateTo(address _operator) external {\n        TssDelegation(tssDelegationContract).delegateTo(_operator, msg.sender);\n    }\n\n\n    function onDelegationReceived(\n        address delegator,\n        address operator,\n        IDelegationShare[] memory delegationShares,\n        uint256[] memory investorShares\n    )external override onlyDelegation {\n        uint256 delegationLength = delegationShares.length;\n        require(delegationLength == 1,\"delegation only for tss\");\n        require(investorShares.length == 1,\"delegation share only for tss\");\n        require(address(delegationShares[0]) == address(this),\"must use current contract\");\n        if (delegators[delegator] == address(0)) {\n            delegators[delegator] = operator;\n            stakers[operator].push(delegator);\n        }\n    }\n\n    function onDelegationWithdrawn(\n        address delegator,\n        address operator,\n        IDelegationShare[] memory delegationShares,\n        uint256[] memory investorShares\n    ) external override onlyDelegation {\n        uint256 delegationLength = delegationShares.length;\n        require(delegationLength == 1,\"delegation only for tss\");\n        require(investorShares.length == 1,\"delegation share only for tss\");\n        require(address(delegationShares[0]) == address(this),\"must use current contract\");\n        if (TssDelegationManager(tssDelegationManagerContract).getDelegationShares(delegator, delegationShares[0]) == investorShares[0]){\n            address[] memory staker = stakers[operator];\n            for (uint256 j = 0; j < staker.length; j++) {\n                if (staker[j] == delegator) {\n                    stakers[operator][j] = stakers[operator][staker.length -1];\n                    stakers[operator].pop();\n                    delete delegators[delegator];\n                }\n            }\n        }\n    }\n\n}\n"
    },
    "contracts/L1/delegation/DelegationShareBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"./interfaces/IDelegationManager.sol\";\n\n/**\n * @title Base implementation of `IDelegationShare` interface, designed to be inherited from by more complex strategies.\n * @author Layr Labs, Inc.\n * @notice Simple, basic, \"do-nothing\" DelegationShare that holds a single underlying token and returns it on withdrawals.\n * Implements minimal versions of the IDelegationShare functions, this contract is designed to be inherited by\n * more complex delegation contracts, which can then override its functions as necessary.\n */\nabstract contract DelegationShareBase is Initializable, PausableUpgradeable, IDelegationShare {\n    using SafeERC20 for IERC20;\n\n    /// @notice DelegationManager contract\n    IDelegationManager public delegationManager;\n\n    /// @notice The underyling token for shares in this DelegationShare\n    IERC20 public underlyingToken;\n\n    /// @notice The total number of extant shares in the DelegationShare\n    uint256 public totalShares;\n\n    event Deposit(address depositor, address token, uint256 amount);\n\n    event Withdraw(address depositor, address token, uint256 amount);\n\n    /// @notice Simply checks that the `msg.sender` is the `DelegationManager`, which is an address stored immutably at construction.\n    modifier onlyDelegationManager() {\n        require(msg.sender == address(delegationManager), \"DelegationShareBase.onlyDelegationManager\");\n        _;\n    }\n\n    /**\n     * @notice Used to deposit tokens into this DelegationShare\n     * @param token is the ERC20 token being deposited\n     * @param amount is the amount of token being deposited\n     * @dev This function is only callable by the DelegationManager contract. It is invoked inside of the delegationManager's\n     * `depositIntoStrategy` function, and individual share balances are recorded in the delegationManager as well.\n     * @return newShares is the number of new shares issued at the current exchange ratio.\n     */\n    function deposit(address depositor, IERC20 token, uint256 amount)\n        external\n        virtual\n        override\n        whenNotPaused\n        onlyDelegationManager\n        returns (uint256 newShares)\n    {\n        require(token == underlyingToken, \"DelegationShareBase.deposit: Can only deposit underlyingToken\");\n        // be ware of lines below, if min amount is too small there will be a share calculation exploit problem\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSignature(\"decimals()\")\n        );\n        require(success, \"underlyingToken have no method with decimals\");\n        uint256 decimals = uint256(bytes32(data));\n        require(amount >= 1*10**decimals, \"amount must gt 1 unit\");\n\n        /**\n         * @notice calculation of newShares *mirrors* `underlyingToShares(amount)`, but is different since the balance of `underlyingToken`\n         * has already been increased due to the `delegationManager` transferring tokens to this delegation contract prior to calling this function\n         */\n        uint256 priorTokenBalance = _tokenBalance() - amount;\n        if (priorTokenBalance == 0 || totalShares == 0) {\n            newShares = amount;\n        } else {\n            newShares = (amount * totalShares) / priorTokenBalance;\n        }\n\n        totalShares += newShares;\n        emit Deposit(depositor, address(token), amount);\n        return newShares;\n    }\n\n    /**\n     * @notice Used to withdraw tokens from this DelegationShare, to the `depositor`'s address\n     * @param token is the ERC20 token being transferred out\n     * @param amountShares is the amount of shares being withdrawn\n     * @dev This function is only callable by the delegationManager contract. It is invoked inside of the delegationManager's\n     * other functions, and individual share balances are recorded in the delegationManager as well.\n     */\n    function withdraw(address depositor, IERC20 token, uint256 amountShares)\n        external\n        virtual\n        override\n        whenNotPaused\n        onlyDelegationManager\n    {\n        require(token == underlyingToken, \"DelegationShareBase.withdraw: Can only withdraw the strategy token\");\n        require(\n            amountShares <= totalShares,\n            \"DelegationShareBase.withdraw: amountShares must be less than or equal to totalShares\"\n        );\n        // copy `totalShares` value prior to decrease\n        uint256 priorTotalShares = totalShares;\n        // Decrease `totalShares` to reflect withdrawal. Unchecked arithmetic since we just checked this above.\n        unchecked {\n            totalShares -= amountShares;\n        }\n        /**\n         * @notice calculation of amountToSend *mirrors* `sharesToUnderlying(amountShares)`, but is different since the `totalShares` has already\n         * been decremented\n         */\n        uint256 amountToSend;\n        if (priorTotalShares == amountShares) {\n            amountToSend = _tokenBalance();\n        } else {\n            amountToSend = (_tokenBalance() * amountShares) / priorTotalShares;\n        }\n        underlyingToken.safeTransfer(depositor, amountToSend);\n        emit Withdraw(depositor, address(token), amountToSend);\n    }\n\n    /**\n     * @notice Currently returns a brief string explaining the strategy's goal & purpose, but for more complex\n     * strategies, may be a link to metadata that explains in more detail.\n     */\n    function explanation() external pure virtual override returns (string memory) {\n        // return \"Base DelegationShare implementation to inherit from for more complex implementations\";\n        return \"Mantle token DelegationShare implementation for submodules as an example\";\n    }\n\n    /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlying`, this function guarantees no state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @dev Implementation for these functions in particular may vary signifcantly for different strategies\n     */\n    function sharesToUnderlyingView(uint256 amountShares) public view virtual override returns (uint256) {\n        if (totalShares == 0) {\n            return amountShares;\n        } else {\n            return (_tokenBalance() * amountShares) / totalShares;\n        }\n    }\n\n    /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @dev Implementation for these functions in particular may vary signifcantly for different strategies\n     */\n    function sharesToUnderlying(uint256 amountShares) public view virtual override returns (uint256) {\n        return sharesToUnderlyingView(amountShares);\n    }\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToShares`, this function guarantees no state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @dev Implementation for these functions in particular may vary signifcantly for different strategies\n     */\n    function underlyingToSharesView(uint256 amountUnderlying) public view virtual returns (uint256) {\n        uint256 tokenBalance = _tokenBalance();\n        if (tokenBalance == 0 || totalShares == 0) {\n            return amountUnderlying;\n        } else {\n            return (amountUnderlying * totalShares) / tokenBalance;\n        }\n    }\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToSharesView`, this function **may** make state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @dev Implementation for these functions in particular may vary signifcantly for different strategies\n     */\n    function underlyingToShares(uint256 amountUnderlying) external view virtual returns (uint256) {\n        return underlyingToSharesView(amountUnderlying);\n    }\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications\n     */\n    function userUnderlyingView(address user) external view virtual returns (uint256) {\n        return sharesToUnderlyingView(shares(user));\n    }\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications\n     */\n    function userUnderlying(address user) external virtual returns (uint256) {\n        return sharesToUnderlying(shares(user));\n    }\n\n    /**\n     * @notice convenience function for fetching the current total shares of `user` in this strategy, by\n     * querying the `delegationManager` contract\n     */\n    function shares(address user) public view virtual returns (uint256) {\n        return IDelegationManager(delegationManager).investorDelegationShares(user, IDelegationShare(address(this)));\n    }\n\n    /// @notice Internal function used to fetch this contract's current balance of `underlyingToken`.\n    // slither-disable-next-line dead-code\n    function _tokenBalance() internal view virtual returns (uint256) {\n        return underlyingToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/L1/delegation/DelegationCallbackBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IDelegationCallback.sol\";\nimport \"./interfaces/IDelegation.sol\";\n\n/**\n * @title Base implementation of `IInvestmentStrategy` interface, designed to be inherited from by more complex strategies.\n * @notice Simple, basic, \"do-nothing\" InvestmentStrategy that holds a single underlying token and returns it on withdrawals.\n * Implements minimal versions of the IInvestmentStrategy functions, this contract is designed to be inherited by\n * more complex investment strategies, which can then override its functions as necessary.\n */\nabstract contract DelegationCallbackBase is Initializable, PausableUpgradeable, IDelegationCallback {\n    /// @notice DelegationManager contract\n    IDelegation public delegation;\n\n    /// @notice Simply checks that the `msg.sender` is the `DelegationManager`, which is an address stored immutably at construction.\n    modifier onlyDelegation() {\n        require(msg.sender == address(delegation), \"DelegationShareBase.onlyDelegationManager\");\n        _;\n    }\n\n    function payForService(IERC20 token, uint256 amount) external payable {}\n\n    function onDelegationWithdrawn(\n        address delegator,\n        IDelegationShare[] memory investorDelegationShares,\n        uint256[] memory investorShares\n    ) external {}\n\n    function onDelegationReceived(\n        address delegator,\n        IDelegationShare[] memory investorDelegationShares,\n        uint256[] memory investorShares\n    ) external {}\n}\n"
    },
    "contracts/libraries/bridge/CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"./ICrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainEnabled\n * @dev Helper contract for contracts performing cross-domain communications\n *\n * Compiler used: defined by inheriting contract\n */\ncontract CrossDomainEnabled {\n    /*************\n     * Variables *\n     *************/\n\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public messenger;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\n     */\n    constructor(address _messenger) {\n        messenger = _messenger;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Enforces that the modified function is only callable by a specific cross-domain account.\n     * @param _sourceDomainAccount The only account on the originating domain which is\n     *  authenticated to call this function.\n     */\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\n        require(\n            msg.sender == address(getCrossDomainMessenger()),\n            \"BVM_XCHAIN: messenger contract unauthenticated\"\n        );\n\n        require(\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\n            \"BVM_XCHAIN: wrong sender of cross-domain message\"\n        );\n\n        _;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\n     * needs to override.\n     * @return The address of the cross-domain messenger contract which should be used.\n     */\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\n        return ICrossDomainMessenger(messenger);\n    }\n\n    /**q\n     * Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _message The data to send to the target (usually calldata to a function with\n     *  `onlyFromCrossDomainAccount()`)\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        uint32 _gasLimit,\n        bytes memory _message\n    ) internal {\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\n    }\n}\n"
    },
    "contracts/L2/predeploys/iTssRewardContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title ITssRewardContract\n */\n\ninterface ITssRewardContract {\n    /**********\n     * Events *\n     **********/\n\n    event DistributeTssReward(\n        uint256 lastBatchTime,\n        uint256 batchTime,\n        uint256 amount,\n        address[] tssMembers\n    );\n\n    event DistributeTssRewardByBlock(\n        uint256   blockStartHeight,\n        uint32     length,\n        uint256    amount,\n        address[] tssMembers\n    );\n\n    event Claim(\n        address owner,\n        uint256 amount\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev Query total undistributed balance.\n     * @return Amount of undistributed rewards.\n     */\n    function queryReward() external view returns (uint256);\n\n    /**\n     * @dev Auto distribute reward to tss members.\n     * @param _blockStartHeight L2 rollup batch block start height.\n     * @param _length Rollup batch length.\n     * @param _batchTime rollup batch time.\n     * @param _tssMembers Tss member address array.\n     */\n    function claimReward(uint256 _blockStartHeight, uint32 _length, uint256 _batchTime, address[] calldata _tssMembers) external;\n\n    /**\n     * @dev clear contract(canonical).\n     */\n    function withdraw() external;\n\n    /**\n     * @dev Claim reward and withdraw\n     */\n    function claim() external;\n\n    /**\n     * @dev default claimer == staker, if staker is multi-signature address,must set claimer\n     * @param _staker the address of staker\n     * @param _claimer the address for staker to claim reward\n     */\n    function setClaimer(address _staker, address _claimer) external;\n\n    /**\n     * @dev Initiate a request to claim\n     */\n    function requestClaim() external returns (bool);\n\n    /**\n     * @dev Query the remaining time required to claim\n     */\n    function queryClaimTime() external returns (uint256);\n\n    function setSccAddr(address sccAddr) external;\n\n    function setStakeSlashAddr(address ssAddr) external;\n\n    function setSendAmountPerYear(uint256) external;\n\n    function setWaitingTime(uint256) external;\n\n}\n"
    },
    "contracts/L1/tss/delegation/TssDelegationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../../delegation/DelegationManager.sol\";\nimport \"../ITssGroupManager.sol\";\nimport \"../TssStakingSlashing.sol\";\n\n\n/**\n * @title The primary entry- and exit-point for funds into and out.\n * @notice This contract is for managing investments in different strategies. The main\n * functionalities are:\n * - adding and removing investment strategies that any delegator can invest into\n * - enabling deposit of assets into specified investment delegation(s)\n * - enabling removal of assets from specified investment delegation(s)\n * - recording deposit of ETH into settlement layer\n * - recording deposit for securing\n * - slashing of assets for permissioned strategies\n */\ncontract TssDelegationManager is DelegationManager {\n\n\n    address public stakingSlash;\n    address public tssGroupManager;\n\n    uint256 public minStakeAmount;\n\n\n    /**\n     * @param _delegation The delegation contract.\n     * @param _delegationSlasher The primary slashing contract.\n     */\n    constructor(IDelegation _delegation, IDelegationSlasher _delegationSlasher)\n    DelegationManager(_delegation, _delegationSlasher)\n    {\n        _disableInitializers();\n    }\n\n    function initializeT(\n        address _stakingSlashing,\n        address _tssGroupManager,\n        uint256 _minStakeAmount,\n        address initialOwner\n    ) public initializer {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, bytes(\"Mantle\"), block.chainid, address(this)));\n        _transferOwnership(initialOwner);\n        stakingSlash = _stakingSlashing;\n        tssGroupManager = _tssGroupManager;\n        minStakeAmount = _minStakeAmount;\n    }\n\n\n    modifier onlyStakingSlash() {\n        require(msg.sender == stakingSlash, \"contract call is not staking slashing\");\n        _;\n    }\n\n    function setStakingSlash(address _address) public onlyOwner {\n        stakingSlash = _address;\n    }\n\n    function setMinStakeAmount(uint256 _amount) public onlyOwner {\n        minStakeAmount = _amount;\n    }\n\n    function setTssGroupManager(address _addr) public onlyOwner {\n        tssGroupManager = _addr;\n    }\n\n    /**\n     * @notice Slashes the shares of a 'frozen' operator (or a staker delegated to one)\n     * @param slashedAddress is the frozen address that is having its shares slashed\n     * @param delegationIndexes is a list of the indices in `investorStrats[msg.sender]` that correspond to the strategies\n     * for which `msg.sender` is withdrawing 100% of their shares\n     * @param recipient The slashed funds are withdrawn as tokens to this address.\n     * @dev delegationShares are removed from `investorStrats` by swapping the last entry with the entry to be removed, then\n     * popping off the last entry in `investorStrats`. The simplest way to calculate the correct `delegationIndexes` to input\n     * is to order the strategies *for which `msg.sender` is withdrawing 100% of their shares* from highest index in\n     * `investorStrats` to lowest index\n     */\n    function slashShares(\n        address slashedAddress,\n        address recipient,\n        IDelegationShare[] calldata delegationShares,\n        IERC20[] calldata tokens,\n        uint256[] calldata delegationIndexes,\n        uint256[] calldata shareAmounts\n    )\n        external\n        override\n        whenNotPaused\n        onlyStakingSlash\n        nonReentrant\n    {\n\n        uint256 delegationIndex;\n        uint256 strategiesLength = delegationShares.length;\n        for (uint256 i = 0; i < strategiesLength;) {\n            // the internal function will return 'true' in the event the delegation contract was\n            // removed from the slashedAddress's array of strategies -- i.e. investorStrats[slashedAddress]\n            if (_removeShares(slashedAddress, delegationIndexes[delegationIndex], delegationShares[i], shareAmounts[i])) {\n                unchecked {\n                    ++delegationIndex;\n                }\n            }\n\n            // withdraw the shares and send funds to the recipient\n            delegationShares[i].withdraw(recipient, tokens[i], shareAmounts[i]);\n\n            // increment the loop\n            unchecked {\n                ++i;\n            }\n        }\n\n        // modify delegated shares accordingly, if applicable\n        delegation.decreaseDelegatedShares(slashedAddress, delegationShares, shareAmounts);\n    }\n\n    function queueWithdrawal(\n        uint256[] calldata delegationIndexes,\n        IDelegationShare[] calldata delegationShares,\n        IERC20[] calldata tokens,\n        uint256[] calldata shares,\n        WithdrawerAndNonce calldata withdrawerAndNonce,\n        bool undelegateIfPossible\n    )\n    external\n    virtual\n    override\n    whenNotPaused\n    onlyNotFrozen(msg.sender)\n    nonReentrant\n    returns (bytes32)\n    {\n        revert(\"TssDelegationManager: queueWithdrawal is disabled \");\n    }\n\n\n    function isCanOperator(address _addr, IDelegationShare delegationShare) external returns (bool)  {\n        if (delegation.isOperator(_addr)) {\n            uint256 share = delegation.operatorShares(_addr, delegationShare);\n            uint256 balance = delegationShare.sharesToUnderlying(share);\n            if (balance > minStakeAmount) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function depositInto(IDelegationShare delegationShare, IERC20 token, uint256 amount, address sender)\n    external\n    onlyNotFrozen(sender)\n    nonReentrant\n    whitelistOnly(address(delegationShare))\n    onlyStakingSlash\n    returns (uint256 shares)\n    {\n        shares = _depositInto(sender, delegationShare, token, amount);\n    }\n\n    function queueWithdrawal(\n        address sender,\n        uint256[] calldata delegationIndexes,\n        IDelegationShare[] calldata delegationShares,\n        IERC20[] calldata tokens,\n        uint256[] calldata shares,\n        WithdrawerAndNonce calldata withdrawerAndNonce\n    )\n    external\n    whenNotPaused\n    onlyNotFrozen(sender)\n    onlyStakingSlash\n    nonReentrant\n    returns (bytes32)\n    {\n        require(\n            withdrawerAndNonce.nonce == numWithdrawalsQueued[sender],\n            \"InvestmentManager.queueWithdrawal: provided nonce incorrect\"\n        );\n        require(delegationShares.length == 1, \"only tss delegation share\");\n        require(shares.length == 1,\"only tss delegation share\");\n        // increment the numWithdrawalsQueued of the sender\n        unchecked {\n            ++numWithdrawalsQueued[sender];\n        }\n        address operator = delegation.delegatedTo(sender);\n\n        _checkMinStakeAmount(sender, delegationShares[0], shares[0]);\n\n        // modify delegated shares accordingly, if applicable\n        delegation.decreaseDelegatedShares(sender, delegationShares, shares);\n\n        // the internal function will return 'true' in the event the delegation contrat was\n        // removed from the depositor's array of strategies -- i.e. investorStrats[depositor]\n        _removeShares(sender, delegationIndexes[0], delegationShares[0], shares[0]);\n\n        // copy arguments into struct and pull delegation info\n        QueuedWithdrawal memory queuedWithdrawal = QueuedWithdrawal({\n            delegations: delegationShares,\n            tokens: tokens,\n            shares: shares,\n            depositor: sender,\n            withdrawerAndNonce: withdrawerAndNonce,\n            delegatedAddress: operator\n        });\n\n        // calculate the withdrawal root\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n\n        //update storage in mapping of queued withdrawals\n        queuedWithdrawals[withdrawalRoot] = WithdrawalStorage({\n            /**\n             * @dev We add `REASONABLE_STAKES_UPDATE_PERIOD` to the current time here to account for the fact that it may take some time for\n             * the operator's stake to be updated on all the middlewares. New tasks created between now at this 'initTimestamp' may still\n             * subject the `msg.sender` to slashing!\n             */\n            initTimestamp: uint32(block.timestamp + REASONABLE_STAKES_UPDATE_PERIOD),\n            withdrawer: withdrawerAndNonce.withdrawer,\n            unlockTimestamp: QUEUED_WITHDRAWAL_INITIALIZED_VALUE\n        });\n\n        address staker = sender;\n        // If the `msg.sender` has withdrawn all of their funds in this transaction, then they can choose to also undelegate\n        /**\n         * Checking that `investorStrats[msg.sender].length == 0` is not strictly necessary here, but prevents reverting very late in logic,\n         * in the case that 'undelegate' is set to true but the `msg.sender` still has active deposits.\n         */\n        if (investorDelegations[staker].length == 0) {\n            _undelegate(staker);\n        }\n\n        emit WithdrawalQueued(staker, withdrawerAndNonce.withdrawer, operator, withdrawalRoot);\n\n        return withdrawalRoot;\n    }\n\n\n    function startQueuedWithdrawalWaitingPeriod(bytes32 withdrawalRoot, address sender, uint32 stakeInactiveAfter) external onlyStakingSlash {\n        require(\n            queuedWithdrawals[withdrawalRoot].unlockTimestamp == QUEUED_WITHDRAWAL_INITIALIZED_VALUE,\n            \"InvestmentManager.startQueuedWithdrawalWaitingPeriod: Withdrawal stake inactive claim has already been made\"\n        );\n        require(\n            queuedWithdrawals[withdrawalRoot].withdrawer == sender,\n            \"InvestmentManager.startQueuedWithdrawalWaitingPeriod: Sender is not the withdrawer\"\n        );\n        require(\n            block.timestamp > queuedWithdrawals[withdrawalRoot].initTimestamp,\n            \"InvestmentManager.startQueuedWithdrawalWaitingPeriod: Stake may still be subject to slashing based on new tasks. Wait to set stakeInactiveAfter.\"\n        );\n        //they can only unlock after a withdrawal waiting period or after they are claiming their stake is inactive\n        queuedWithdrawals[withdrawalRoot].unlockTimestamp = max((uint32(block.timestamp) + WITHDRAWAL_WAITING_PERIOD), stakeInactiveAfter);\n    }\n\n    function completeQueuedWithdrawal(address sender, QueuedWithdrawal calldata queuedWithdrawal, bool receiveAsTokens)\n        external\n        whenNotPaused\n        // check that the address that the staker *was delegated to*  at the time that they queued the withdrawal  is not frozen\n        onlyNotFrozen(queuedWithdrawal.delegatedAddress)\n        nonReentrant\n        onlyStakingSlash\n    {\n        // find the withdrawalRoot\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n        // copy storage to memory\n        WithdrawalStorage memory withdrawalStorageCopy = queuedWithdrawals[withdrawalRoot];\n\n        // verify that the queued withdrawal actually exists\n        require(\n            withdrawalStorageCopy.unlockTimestamp != 0,\n            \"InvestmentManager.completeQueuedWithdrawal: withdrawal does not exist\"\n        );\n\n        require(\n            uint32(block.timestamp) >= withdrawalStorageCopy.unlockTimestamp\n                || (queuedWithdrawal.delegatedAddress == address(0)),\n            \"InvestmentManager.completeQueuedWithdrawal: withdrawal waiting period has not yet passed and depositor was delegated when withdrawal initiated\"\n        );\n\n        // TODO: add testing coverage for this\n        require(\n            sender == queuedWithdrawal.withdrawerAndNonce.withdrawer,\n            \"InvestmentManager.completeQueuedWithdrawal: only specified withdrawer can complete a queued withdrawal\"\n        );\n\n        // reset the storage slot in mapping of queued withdrawals\n        delete queuedWithdrawals[withdrawalRoot];\n\n        // store length for gas savings\n        uint256 strategiesLength = queuedWithdrawal.delegations.length;\n        // if the withdrawer has flagged to receive the funds as tokens, withdraw from strategies\n        if (receiveAsTokens) {\n            // actually withdraw the funds\n            for (uint256 i = 0; i < strategiesLength;) {\n                // tell the delegation to send the appropriate amount of funds to the depositor\n                queuedWithdrawal.delegations[i].withdraw(\n                    withdrawalStorageCopy.withdrawer, queuedWithdrawal.tokens[i], queuedWithdrawal.shares[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            // else increase their shares\n            for (uint256 i = 0; i < strategiesLength;) {\n                _addShares(withdrawalStorageCopy.withdrawer, queuedWithdrawal.delegations[i], queuedWithdrawal.shares[i]);\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        emit WithdrawalCompleted(queuedWithdrawal.depositor, withdrawalStorageCopy.withdrawer, withdrawalRoot);\n    }\n\n    function getWithdrawNonce(address staker) external view onlyStakingSlash returns (uint256) {\n        return numWithdrawalsQueued[staker];\n    }\n\n    function getDelegationShares(address staker,IDelegationShare delegationShare) external view onlyStakingSlash returns (uint256) {\n        return investorDelegationShares[staker][delegationShare];\n    }\n\n    function _checkMinStakeAmount(address sender,IDelegationShare delegationShare, uint256 shares) internal {\n        address operator = delegation.delegatedTo(sender);\n        // check if the operator is still mpc node, if the remaining shares meet the mini requirement\n        if (delegation.isDelegated(sender)){\n            if (ITssGroupManager(tssGroupManager).memberExistActive(operator)){\n                require(!TssStakingSlashing(stakingSlash).isJailed(operator),\"the operator is not in jail status\");\n                uint256 rest= delegation.operatorShares(operator, delegationShare) - shares;\n                uint256 balance = delegationShare.sharesToUnderlying(rest);\n                if (ITssGroupManager(tssGroupManager).isTssGroupUnJailMembers(operator)) {\n                    require(balance > minStakeAmount,\"unable withdraw due to operator's rest shares smaller than mini requirement\");\n                }\n            }\n        }\n    }\n\n\n}\n\n"
    },
    "contracts/libraries/utils/Lib_Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_Address\n * @dev This library for convert bytes publicKey to address\n */\nlibrary Lib_Address {\n\n    function publicKeyToAddress(bytes memory publicKey) internal pure returns (address) {\n        require(publicKey.length == 64, \"public key length must 64 bytes\");\n        return address(uint160(uint256(keccak256(publicKey))));\n    }\n}\n"
    },
    "contracts/L1/tss/ITssGroupManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\ninterface ITssGroupManager {\n    enum MemberStatus {\n        unJail,\n        jail\n    }\n\n    struct TssMember {\n        bytes         publicKey;\n        address       nodeAddress;\n        MemberStatus  status;\n    }\n\n    function setTssGroupMember(uint256 _threshold, bytes[] memory _batchPublicKey) external;\n    function setGroupPublicKey(bytes memory _publicKey, bytes memory _groupPublicKey) external;\n    function getTssGroupInfo() external returns (uint256, uint256, bytes memory, bytes[] memory);\n    function getTssInactiveGroupInfo() external returns (uint256, uint256, bytes[] memory);\n    function memberJail(bytes memory _publicKey) external;\n    function memberUnJail(bytes memory _publicKey) external;\n    function removeMember(bytes memory _publicKey) external;\n    function getTssGroupUnJailMembers() external returns (address[] memory);\n    function getTssGroupMembers() external returns (bytes[] memory);\n    function getTssMember(bytes memory _publicKey) external returns (TssMember memory);\n    function memberExistActive(bytes memory _publicKey) external returns (bool);\n    function memberExistInActive(bytes memory _publicKey) external returns (bool);\n    function inActiveIsEmpty() external returns (bool);\n    function verifySign(bytes32 _message, bytes memory _sig) external returns (bool);\n    function isTssGroupUnJailMembers(address _addr) external returns (bool);\n    function memberExistActive(address _addr) external returns (bool);\n}\n"
    },
    "contracts/L1/tss/ITssStakingSlashing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\ninterface IStakingSlashing {\n\n    // tx\n    function setTokenAddress(address) external;\n    function setTssGroupAddress(address) external;\n    function setRegulatoryAccount(address) external;\n    function setClaimer(address, address) external;\n    function setSlashingParams(uint256[2] calldata) external;\n    function setTssManager(address) external;\n    function quitRequest() external;\n    function clearQuitRequestList() external;\n    function slashing(bytes calldata, bytes calldata) external;\n    function unJail() external;\n\n    // query\n    function getSlashingParams() external view returns (uint256[2] memory);\n    function getQuitRequestList() external view returns (address[] memory);\n    function getSlashRecord(uint256, address) external view returns (bool);\n    function isJailed(address) external returns (bool);\n    function isCanOperator(address) external returns (bool);\n\n    //fund\n    function deposit(uint256 amount) external returns (uint256);\n    function withdraw() external;\n    function completeWithdraw() external;\n    function startWithdraw() external;\n    function canCompleteQueuedWithdrawal() external returns (bool);\n\n    //delegation\n    function registerAsOperator(bytes calldata) external;\n    function delegateTo(address) external;\n\n\n\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "contracts/L1/delegation/DelegationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"./interfaces/IDelegation.sol\";\nimport \"./DelegationManagerStorage.sol\";\nimport \"./WhiteListBase.sol\";\n/**\n * @title The primary entry- and exit-point for funds into and out.\n * @author Layr Labs, Inc.\n * @notice This contract is for managing investments in different strategies. The main\n * functionalities are:\n * - adding and removing investment strategies that any delegator can invest into\n * - enabling deposit of assets into specified investment delegation(s)\n * - enabling removal of assets from specified investment delegation(s)\n * - recording deposit of ETH into settlement layer\n * - recording deposit for securing\n * - slashing of assets for permissioned strategies\n */\nabstract contract DelegationManager is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DelegationManagerStorage,\n    WhiteList\n{\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Value to which `initTimestamp` and `unlockTimestamp` to is set to indicate a withdrawal is queued/initialized,\n     * but has not yet had its waiting period triggered\n     */\n    uint32 internal constant QUEUED_WITHDRAWAL_INITIALIZED_VALUE = type(uint32).max;\n\n    /**\n     * @notice Emitted when a new withdrawal is queued by `depositor`.\n     * @param depositor Is the staker who is withdrawing funds.\n     * @param withdrawer Is the party specified by `staker` who will be able to complete the queued withdrawal and receive the withdrawn funds.\n     * @param delegatedAddress Is the party who the `staker` was delegated to at the time of creating the queued withdrawal\n     * @param withdrawalRoot Is a hash of the input data for the withdrawal.\n     */\n    event WithdrawalQueued(\n        address indexed depositor, address indexed withdrawer, address indexed delegatedAddress, bytes32 withdrawalRoot\n    );\n\n    /// @notice Emitted when a queued withdrawal is completed\n    event WithdrawalCompleted(address indexed depositor, address indexed withdrawer, bytes32 withdrawalRoot);\n\n    modifier onlyNotFrozen(address staker) {\n        require(\n            !delegationSlasher.isFrozen(staker),\n            \"DelegationManager.onlyNotFrozen: staker has been frozen and may be subject to slashing\"\n        );\n        _;\n    }\n\n    modifier onlyFrozen(address staker) {\n        require(delegationSlasher.isFrozen(staker), \"DelegationManager.onlyFrozen: staker has not been frozen\");\n        _;\n    }\n\n    /**\n     * @param _delegation The delegation contract.\n     * @param _delegationSlasher The primary slashing contract.\n     */\n    constructor(IDelegation _delegation, IDelegationSlasher _delegationSlasher)\n        DelegationManagerStorage(_delegation, _delegationSlasher)\n    {\n        _disableInitializers();\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /**\n     * @notice Initializes the investment manager contract. Sets the `pauserRegistry` (currently **not** modifiable after being set),\n     * and transfers contract ownership to the specified `initialOwner`.\n     * @param initialOwner Ownership of this contract is transferred to this address.\n     */\n    function initialize(address initialOwner)\n        external\n        initializer\n    {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, bytes(\"Mantle\"), block.chainid, address(this)));\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @notice Deposits `amount` of `token` into the specified `delegationShare`, with the resultant shares credited to `depositor`\n     * @param delegationShare is the specified delegation contract where investment is to be made,\n     * @param token is the denomination in which the investment is to be made,\n     * @param amount is the amount of token to be invested in the delegation contract by the depositor\n     * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\n     * @dev Cannot be called by an address that is 'frozen' (this function will revert if the `msg.sender` is frozen).\n     */\n    function depositInto(IDelegationShare delegationShare, IERC20 token, uint256 amount)\n        external\n        onlyNotFrozen(msg.sender)\n        nonReentrant\n        whitelistOnly(address(delegationShare))\n        returns (uint256 shares)\n    {\n        shares = _depositInto(msg.sender, delegationShare, token, amount);\n    }\n\n    /**\n     * @notice Called by a staker to undelegate entirely. The staker must first withdraw all of their existing deposits\n     * (through use of the `queueWithdrawal` function), or else otherwise have never deposited prior to delegating.\n     */\n    function undelegate() external {\n        _undelegate(msg.sender);\n    }\n\n    /**\n     * @notice Called by a staker to queue a withdraw in the given token and shareAmount from each of the respective given strategies.\n     * @dev Stakers will complete their withdrawal by calling the 'completeQueuedWithdrawal' function.\n     * User shares are decreased in this function, but the total number of shares in each delegation contract remains the same.\n     * The total number of shares is decremented in the 'completeQueuedWithdrawal' function instead, which is where\n     * the funds are actually sent to the user through use of the strategies' 'withdrawal' function. This ensures\n     * that the value per share reported by each delegation contract will remain consistent, and that the shares will continue\n     * to accrue gains during the enforced WITHDRAWAL_WAITING_PERIOD.\n     * @param delegationIndexes is a list of the indices in `investorStrats[msg.sender]` that correspond to the strategies\n     * for which `msg.sender` is withdrawing 100% of their shares\n     * @dev strategies are removed from `investorStrats` by swapping the last entry with the entry to be removed, then\n     * popping off the last entry in `investorStrats`. The simplest way to calculate the correct `delegationIndexes` to input\n     * is to order the strategies *for which `msg.sender` is withdrawing 100% of their shares* from highest index in\n     * `investorStrats` to lowest index\n     */\n    function queueWithdrawal(\n        uint256[] calldata delegationIndexes,\n        IDelegationShare[] calldata delegationShares,\n        IERC20[] calldata tokens,\n        uint256[] calldata shares,\n        WithdrawerAndNonce calldata withdrawerAndNonce,\n        bool undelegateIfPossible\n    )\n        external\n        virtual\n        whenNotPaused\n        onlyNotFrozen(msg.sender)\n        nonReentrant\n        returns (bytes32)\n    {\n        require(\n            withdrawerAndNonce.nonce == numWithdrawalsQueued[msg.sender],\n            \"DelegationManager.queueWithdrawal: provided nonce incorrect\"\n        );\n        // increment the numWithdrawalsQueued of the sender\n        unchecked {\n            ++numWithdrawalsQueued[msg.sender];\n        }\n\n        uint256 delegationIndex;\n\n        // modify delegated shares accordingly, if applicable\n        delegation.decreaseDelegatedShares(msg.sender, delegationShares, shares);\n\n        for (uint256 i = 0; i < delegationShares.length;) {\n            // the internal function will return 'true' in the event the delegation contrat was\n            // removed from the depositor's array of strategies -- i.e. investorStrats[depositor]\n            if (_removeShares(msg.sender, delegationIndexes[delegationIndex], delegationShares[i], shares[i])) {\n                unchecked {\n                    ++delegationIndex;\n                }\n            }\n\n            //increment the loop\n            unchecked {\n                ++i;\n            }\n        }\n\n        // fetch the address that the `msg.sender` is delegated to\n        address delegatedAddress = delegation.delegatedTo(msg.sender);\n\n        // copy arguments into struct and pull delegation info\n        QueuedWithdrawal memory queuedWithdrawal = QueuedWithdrawal({\n            delegations: delegationShares,\n            tokens: tokens,\n            shares: shares,\n            depositor: msg.sender,\n            withdrawerAndNonce: withdrawerAndNonce,\n            delegatedAddress: delegatedAddress\n        });\n\n        // calculate the withdrawal root\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n\n        //update storage in mapping of queued withdrawals\n        queuedWithdrawals[withdrawalRoot] = WithdrawalStorage({\n            /**\n             * @dev We add `REASONABLE_STAKES_UPDATE_PERIOD` to the current time here to account for the fact that it may take some time for\n             * the operator's stake to be updated on all the middlewares. New tasks created between now at this 'initTimestamp' may still\n             * subject the `msg.sender` to slashing!\n             */\n            initTimestamp: uint32(block.timestamp + REASONABLE_STAKES_UPDATE_PERIOD),\n            withdrawer: withdrawerAndNonce.withdrawer,\n            unlockTimestamp: QUEUED_WITHDRAWAL_INITIALIZED_VALUE\n        });\n\n        // If the `msg.sender` has withdrawn all of their funds in this transaction, then they can choose to also undelegate\n        /**\n         * Checking that `investorStrats[msg.sender].length == 0` is not strictly necessary here, but prevents reverting very late in logic,\n         * in the case that 'undelegate' is set to true but the `msg.sender` still has active deposits.\n         */\n        if (undelegateIfPossible && investorDelegations[msg.sender].length == 0) {\n            _undelegate(msg.sender);\n        }\n\n        emit WithdrawalQueued(msg.sender, withdrawerAndNonce.withdrawer, delegatedAddress, withdrawalRoot);\n\n        return withdrawalRoot;\n    }\n\n    /*\n    *\n    * @notice The withdrawal flow is:\n    * - Depositor starts a queued withdrawal, setting the receiver of the withdrawn funds as withdrawer\n    * - Withdrawer then waits for the queued withdrawal tx to be included in the chain, and then sets the stakeInactiveAfter. This cannot\n    *   be set when starting the queued withdrawal, as it is there may be transactions the increase the tasks upon which the stake is active\n    *   that get mined before the withdrawal.\n    * - The withdrawer completes the queued withdrawal after the stake is inactive or a withdrawal fraud proof period has passed,\n    *   whichever is longer. They specify whether they would like the withdrawal in shares or in tokens.\n    */\n    function startQueuedWithdrawalWaitingPeriod(bytes32 withdrawalRoot, uint32 stakeInactiveAfter) external virtual {\n        require(\n            queuedWithdrawals[withdrawalRoot].unlockTimestamp == QUEUED_WITHDRAWAL_INITIALIZED_VALUE,\n            \"DelegationManager.startQueuedWithdrawalWaitingPeriod: Withdrawal stake inactive claim has already been made\"\n        );\n        require(\n            queuedWithdrawals[withdrawalRoot].withdrawer == msg.sender,\n            \"DelegationManager.startQueuedWithdrawalWaitingPeriod: Sender is not the withdrawer\"\n        );\n        require(\n            block.timestamp > queuedWithdrawals[withdrawalRoot].initTimestamp,\n            \"DelegationManager.startQueuedWithdrawalWaitingPeriod: Stake may still be subject to slashing based on new tasks. Wait to set stakeInactiveAfter.\"\n        );\n        //they can only unlock after a withdrawal waiting period or after they are claiming their stake is inactive\n        queuedWithdrawals[withdrawalRoot].unlockTimestamp = max((uint32(block.timestamp) + WITHDRAWAL_WAITING_PERIOD), stakeInactiveAfter);\n    }\n\n    /**\n     * @notice Used to complete the specified `queuedWithdrawal`. The function caller must match `queuedWithdrawal.withdrawer`\n     * @param queuedWithdrawal The QueuedWithdrawal to complete.\n     * @param receiveAsTokens If true, the shares specified in the queued withdrawal will be withdrawn from the specified strategies themselves\n     * and sent to the caller, through calls to `queuedWithdrawal.delegations[i].withdraw`. If false, then the shares in the specified strategies\n     * will simply be transferred to the caller directly.\n     */\n    function completeQueuedWithdrawal(QueuedWithdrawal calldata queuedWithdrawal, bool receiveAsTokens)\n        external\n        whenNotPaused\n        // check that the address that the staker *was delegated to*  at the time that they queued the withdrawal  is not frozen\n        onlyNotFrozen(queuedWithdrawal.delegatedAddress)\n        nonReentrant\n    {\n        // find the withdrawalRoot\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n        // copy storage to memory\n        WithdrawalStorage memory withdrawalStorageCopy = queuedWithdrawals[withdrawalRoot];\n\n        // verify that the queued withdrawal actually exists\n        require(\n            withdrawalStorageCopy.unlockTimestamp != 0,\n            \"DelegationManager.completeQueuedWithdrawal: withdrawal does not exist\"\n        );\n\n        require(\n            uint32(block.timestamp) >= withdrawalStorageCopy.unlockTimestamp\n                || (queuedWithdrawal.delegatedAddress == address(0)),\n            \"DelegationManager.completeQueuedWithdrawal: withdrawal waiting period has not yet passed and depositor was delegated when withdrawal initiated\"\n        );\n\n        // TODO: add testing coverage for this\n        require(\n            msg.sender == queuedWithdrawal.withdrawerAndNonce.withdrawer,\n            \"DelegationManager.completeQueuedWithdrawal: only specified withdrawer can complete a queued withdrawal\"\n        );\n\n        // reset the storage slot in mapping of queued withdrawals\n        delete queuedWithdrawals[withdrawalRoot];\n\n        // store length for gas savings\n        uint256 strategiesLength = queuedWithdrawal.delegations.length;\n        // if the withdrawer has flagged to receive the funds as tokens, withdraw from strategies\n        if (receiveAsTokens) {\n            // actually withdraw the funds\n            for (uint256 i = 0; i < strategiesLength;) {\n                // tell the delegation to send the appropriate amount of funds to the depositor\n                queuedWithdrawal.delegations[i].withdraw(\n                    withdrawalStorageCopy.withdrawer, queuedWithdrawal.tokens[i], queuedWithdrawal.shares[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            // else increase their shares\n            for (uint256 i = 0; i < strategiesLength;) {\n                _addShares(withdrawalStorageCopy.withdrawer, queuedWithdrawal.delegations[i], queuedWithdrawal.shares[i]);\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        emit WithdrawalCompleted(queuedWithdrawal.depositor, withdrawalStorageCopy.withdrawer, withdrawalRoot);\n    }\n\n    /**\n     * @notice Slashes the shares of a 'frozen' operator (or a staker delegated to one)\n     * @param slashedAddress is the frozen address that is having its shares slashed\n     * @param delegationIndexes is a list of the indices in `investorStrats[msg.sender]` that correspond to the strategies\n     * for which `msg.sender` is withdrawing 100% of their shares\n     * @param recipient The slashed funds are withdrawn as tokens to this address.\n     * @dev delegationShares are removed from `investorStrats` by swapping the last entry with the entry to be removed, then\n     * popping off the last entry in `investorStrats`. The simplest way to calculate the correct `delegationIndexes` to input\n     * is to order the strategies *for which `msg.sender` is withdrawing 100% of their shares* from highest index in\n     * `investorStrats` to lowest index\n     */\n    function slashShares(\n        address slashedAddress,\n        address recipient,\n        IDelegationShare[] calldata delegationShares,\n        IERC20[] calldata tokens,\n        uint256[] calldata delegationIndexes,\n        uint256[] calldata shareAmounts\n    )\n        external\n        virtual\n        whenNotPaused\n        onlyOwner\n        onlyFrozen(slashedAddress)\n        nonReentrant\n    {\n        uint256 delegationIndex;\n        uint256 strategiesLength = delegationShares.length;\n        for (uint256 i = 0; i < strategiesLength;) {\n            // the internal function will return 'true' in the event the delegation contract was\n            // removed from the slashedAddress's array of strategies -- i.e. investorStrats[slashedAddress]\n            if (_removeShares(slashedAddress, delegationIndexes[delegationIndex], delegationShares[i], shareAmounts[i])) {\n                unchecked {\n                    ++delegationIndex;\n                }\n            }\n\n            // withdraw the shares and send funds to the recipient\n            delegationShares[i].withdraw(recipient, tokens[i], shareAmounts[i]);\n\n            // increment the loop\n            unchecked {\n                ++i;\n            }\n        }\n\n        // modify delegated shares accordingly, if applicable\n        delegation.decreaseDelegatedShares(slashedAddress, delegationShares, shareAmounts);\n    }\n\n    /**\n     * @notice Slashes an existing queued withdrawal that was created by a 'frozen' operator (or a staker delegated to one)\n     * @param recipient The funds in the slashed withdrawal are withdrawn as tokens to this address.\n     */\n    function slashQueuedWithdrawal(address recipient, QueuedWithdrawal calldata queuedWithdrawal)\n        external\n        whenNotPaused\n        onlyOwner\n        nonReentrant\n    {\n        // find the withdrawalRoot\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n\n        // verify that the queued withdrawal actually exists\n        require(\n            queuedWithdrawals[withdrawalRoot].unlockTimestamp != 0,\n            \"DelegationManager.slashQueuedWithdrawal: withdrawal does not exist\"\n        );\n\n        // verify that *either* the queued withdrawal has been successfully challenged, *or* the `depositor` has been frozen\n        require(\n            queuedWithdrawals[withdrawalRoot].withdrawer == address(0) || delegationSlasher.isFrozen(queuedWithdrawal.depositor),\n            \"DelegationManager.slashQueuedWithdrawal: withdrawal has not been successfully challenged or depositor is not frozen\"\n        );\n\n        // reset the storage slot in mapping of queued withdrawals\n        delete queuedWithdrawals[withdrawalRoot];\n\n        uint256 strategiesLength = queuedWithdrawal.delegations.length;\n        for (uint256 i = 0; i < strategiesLength;) {\n            // tell the delegation contract to send the appropriate amount of funds to the recipient\n            queuedWithdrawal.delegations[i].withdraw(recipient, queuedWithdrawal.tokens[i], queuedWithdrawal.shares[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /**\n     * @notice This function adds `shares` for a given `delegationShare` to the `depositor` and runs through the necessary update logic.\n     * @dev In particular, this function calls `delegation.increaseDelegatedShares(depositor, delegationShare, shares)` to ensure that all\n     * delegated shares are tracked, increases the stored share amount in `investorStratShares[depositor][delegationShare]`, and adds `delegationShare`\n     * to the `depositor`'s list of strategies, if it is not in the list already.\n     */\n    function _addShares(address depositor, IDelegationShare delegationShare, uint256 shares) internal {\n        // sanity check on `shares` input\n        require(shares != 0, \"DelegationManager._addShares: shares should not be zero!\");\n\n        // if they dont have existing shares of this delegation contract, add it to their strats\n        if (investorDelegationShares[depositor][delegationShare] == 0) {\n            require(\n                investorDelegations[depositor].length <= MAX_INVESTOR_DELEGATION_LENGTH,\n                \"DelegationManager._addShares: deposit would exceed MAX_INVESTOR_DELEGATION_LENGTH\"\n            );\n            investorDelegations[depositor].push(delegationShare);\n        }\n\n        // add the returned shares to their existing shares for this delegation contract\n        investorDelegationShares[depositor][delegationShare] += shares;\n\n        // if applicable, increase delegated shares accordingly\n        delegation.increaseDelegatedShares(depositor, delegationShare, shares);\n    }\n\n    /**\n     * @notice Internal function in which `amount` of ERC20 `token` is transferred from `msg.sender` to the InvestmentDelegation-type contract\n     * `delegationShare`, with the resulting shares credited to `depositor`.\n     * @return shares The amount of *new* shares in `delegationShare` that have been credited to the `depositor`.\n     */\n    function _depositInto(address depositor, IDelegationShare delegationShare, IERC20 token, uint256 amount)\n        internal\n        returns (uint256 shares)\n    {\n\n        // transfer tokens from the sender to the delegation contract\n        token.safeTransferFrom(depositor, address(delegationShare), amount);\n\n        // deposit the assets into the specified delegation contract and get the equivalent amount of shares in that delegation contract\n        shares = delegationShare.deposit(depositor, token, amount);\n\n        // add the returned shares to the depositor's existing shares for this delegation contract\n        _addShares(depositor, delegationShare, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Decreases the shares that `depositor` holds in `delegationShare` by `shareAmount`.\n     * @dev If the amount of shares represents all of the depositor`s shares in said delegation contract,\n     * then the delegation contract is removed from investorStrats[depositor] and 'true' is returned. Otherwise 'false' is returned.\n     */\n    function _removeShares(address depositor, uint256 delegationIndex, IDelegationShare delegationShare, uint256 shareAmount)\n        internal\n        returns (bool)\n    {\n        // sanity check on `shareAmount` input\n        require(shareAmount != 0, \"DelegationManager._removeShares: shareAmount should not be zero!\");\n\n        //check that the user has sufficient shares\n        uint256 userShares = investorDelegationShares[depositor][delegationShare];\n\n\n        require(shareAmount <= userShares, \"DelegationManager._removeShares: shareAmount too high\");\n        //unchecked arithmetic since we just checked this above\n        unchecked {\n            userShares = userShares - shareAmount;\n        }\n\n        // subtract the shares from the depositor's existing shares for this delegation contract\n        investorDelegationShares[depositor][delegationShare] = userShares;\n        // if no existing shares, remove is from this investors strats\n\n        if (userShares == 0) {\n            // remove the delegation contract from the depositor's dynamic array of strategies\n            _removeDelegationFromInvestorDelegations(depositor, delegationIndex, delegationShare);\n\n            // return true in the event that the delegation contract was removed from investorStrats[depositor]\n            return true;\n        }\n        // return false in the event that the delegation contract was *not* removed from investorStrats[depositor]\n        return false;\n    }\n\n    /**\n     * @notice Removes `delegationShare` from `depositor`'s dynamic array of strategies, i.e. from `investorStrats[depositor]`\n     * @dev the provided `delegationIndex` input is optimistically used to find the delegation contract quickly in the list. If the specified\n     * index is incorrect, then we revert to a brute-force search.\n     */\n    function _removeDelegationFromInvestorDelegations(address depositor, uint256 delegationIndex, IDelegationShare delegationShare) internal {\n        // if the delegation contract matches with the delegation contract index provided\n        if (investorDelegations[depositor][delegationIndex] == delegationShare) {\n            // replace the delegation contract with the last delegation contract in the list\n            investorDelegations[depositor][delegationIndex] =\n            investorDelegations[depositor][investorDelegations[depositor].length - 1];\n        } else {\n            //loop through all of the strategies, find the right one, then replace\n            uint256 delegationLength = investorDelegations[depositor].length;\n\n            for (uint256 j = 0; j < delegationLength;) {\n                if (investorDelegations[depositor][j] == delegationShare) {\n                    //replace the delegation contract with the last delegation contract in the list\n                    investorDelegations[depositor][j] = investorDelegations[depositor][investorDelegations[depositor].length - 1];\n                    break;\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n        }\n\n        // pop off the last entry in the list of strategies\n        investorDelegations[depositor].pop();\n    }\n\n    /**\n     * @notice If the `depositor` has no existing shares, then they can `undelegate` themselves.\n     * This allows people a \"hard reset\" in their relationship after withdrawing all of their stake.\n     */\n    function _undelegate(address depositor) internal {\n        require(investorDelegations[depositor].length == 0, \"InvestmentManager._undelegate: depositor has active deposits\");\n        delegation.undelegate(depositor);\n    }\n\n    function max(uint32 x, uint32 y) internal pure returns (uint32) {\n        return x > y ? x : y;\n    }\n\n    // VIEW FUNCTIONS\n\n    /**\n     * @notice Used to check if a queued withdrawal can be completed. Returns 'true' if the withdrawal can be immediately\n     * completed, and 'false' otherwise.\n     * @dev This function will revert if the specified `queuedWithdrawal` does not exist\n     */\n    function canCompleteQueuedWithdrawal(QueuedWithdrawal calldata queuedWithdrawal) external view returns (bool) {\n        // find the withdrawalRoot\n        bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n\n        // verify that the queued withdrawal actually exists\n        require(\n            queuedWithdrawals[withdrawalRoot].unlockTimestamp != 0,\n            \"DelegationManager.canCompleteQueuedWithdrawal: withdrawal does not exist\"\n        );\n\n        if (delegationSlasher.isFrozen(queuedWithdrawal.delegatedAddress)) {\n            return false;\n        }\n\n        return (\n            uint32(block.timestamp) >= queuedWithdrawals[withdrawalRoot].unlockTimestamp\n                || (queuedWithdrawal.delegatedAddress == address(0))\n        );\n    }\n\n    /**\n     * @notice Get all details on the depositor's investments and corresponding shares\n     * @return (depositor's strategies, shares in these strategies)\n     */\n    function getDeposits(address depositor) external view returns (IDelegationShare[] memory, uint256[] memory) {\n        uint256 delegationLength = investorDelegations[depositor].length;\n        uint256[] memory shares = new uint256[](delegationLength);\n\n        for (uint256 i = 0; i < delegationLength;) {\n            shares[i] = investorDelegationShares[depositor][investorDelegations[depositor][i]];\n            unchecked {\n                ++i;\n            }\n        }\n        return (investorDelegations[depositor], shares);\n    }\n\n    /// @notice Simple getter function that returns `investorStrats[staker].length`.\n    function investorDelegationLength(address staker) external view returns (uint256) {\n        return investorDelegations[staker].length;\n    }\n\n    /// @notice Returns the keccak256 hash of `queuedWithdrawal`.\n    function calculateWithdrawalRoot(QueuedWithdrawal memory queuedWithdrawal) public pure returns (bytes32) {\n        return (\n            keccak256(\n                abi.encode(\n                    queuedWithdrawal.delegations,\n                    queuedWithdrawal.tokens,\n                    queuedWithdrawal.shares,\n                    queuedWithdrawal.depositor,\n                    queuedWithdrawal.withdrawerAndNonce,\n                    queuedWithdrawal.delegatedAddress\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/L1/delegation/DelegationManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./interfaces/IDelegationManager.sol\";\nimport \"./interfaces/IDelegationShare.sol\";\nimport \"./interfaces/IDelegation.sol\";\nimport \"./interfaces/IDelegationSlasher.sol\";\n\n/**\n * @title Storage variables for the `InvestmentManager` contract.\n * @author Layr Labs, Inc.\n * @notice This storage contract is separate from the logic to simplify the upgrade process.\n */\nabstract contract DelegationManagerStorage is IDelegationManager {\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n    /// @notice The EIP-712 typehash for the deposit struct used by the contract\n    bytes32 public constant DEPOSIT_TYPEHASH =\n        keccak256(\"Deposit(address strategy,address token,uint256 amount,uint256 nonce,uint256 expiry)\");\n    /// @notice EIP-712 Domain separator\n    bytes32 public DOMAIN_SEPARATOR;\n    // staker => number of signed deposit nonce (used in depositIntoStrategyOnBehalfOf)\n    mapping(address => uint256) public nonces;\n    /**\n     * @notice When a staker undelegates or an operator deregisters, their stake can still be slashed based on tasks/services created\n     * within `REASONABLE_STAKES_UPDATE_PERIOD` of the present moment. In other words, this is the lag between undelegation/deregistration\n     * and the staker's/operator's funds no longer being slashable due to misbehavior *on a new task*.\n     */\n    uint256 public constant REASONABLE_STAKES_UPDATE_PERIOD = 30 seconds;\n\n    // fixed waiting period for withdrawals\n    // TODO: set this to a proper interval for production\n    uint32 public constant WITHDRAWAL_WAITING_PERIOD = 10 seconds;\n\n    // maximum length of dynamic arrays in `investorStrats` mapping, for sanity's sake\n    uint8 internal constant MAX_INVESTOR_DELEGATION_LENGTH = 32;\n\n    // delegation system contracts\n    IDelegation public immutable delegation;\n    IDelegationSlasher public immutable delegationSlasher;\n\n    // staker => IDelegationShare => number of shares which they currently hold\n    mapping(address => mapping(IDelegationShare => uint256)) public investorDelegationShares;\n    // staker => array of DelegationShare in which they have nonzero shares\n    mapping(address => IDelegationShare[]) public investorDelegations;\n    // hash of withdrawal inputs, aka 'withdrawalRoot' => timestamps & address related to the withdrawal\n    mapping(bytes32 => WithdrawalStorage) public queuedWithdrawals;\n    // staker => cumulative number of queued withdrawals they have ever initiated. only increments (doesn't decrement)\n    mapping(address => uint256) public numWithdrawalsQueued;\n\n    constructor(IDelegation _delegation, IDelegationSlasher _delegationSlasher) {\n        delegation = _delegation;\n        delegationSlasher = _delegationSlasher;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/libraries/eigenda/interfaces/IInvestmentStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Minimal interface for an `InvestmentStrategy` contract.\n * @author Layr Labs, Inc.\n * @notice Custom `InvestmentStrategy` implementations may expand extensively on this interface.\n */\ninterface IInvestmentStrategy {\n    /**\n     * @notice Used to deposit tokens into this InvestmentStrategy\n     * @param token is the ERC20 token being deposited\n     * @param amount is the amount of token being deposited\n     * @dev This function is only callable by the investmentManager contract. It is invoked inside of the investmentManager's\n     * `depositIntoStrategy` function, and individual share balances are recorded in the investmentManager as well.\n     * @return newShares is the number of new shares issued at the current exchange ratio.\n     */\n    function deposit(IERC20 token, uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Used to withdraw tokens from this InvestmentStrategy, to the `depositor`'s address\n     * @param token is the ERC20 token being transferred out\n     * @param amountShares is the amount of shares being withdrawn\n     * @dev This function is only callable by the investmentManager contract. It is invoked inside of the investmentManager's\n     * other functions, and individual share balances are recorded in the investmentManager as well.\n     */\n    function withdraw(address depositor, IERC20 token, uint256 amountShares) external;\n\n    /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @dev Implementation for these functions in particular may vary signifcantly for different strategies\n     */\n    function sharesToUnderlying(uint256 amountShares) external returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToSharesView`, this function **may** make state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @dev Implementation for these functions in particular may vary signifcantly for different strategies\n     */\n    function underlyingToShares(uint256 amountUnderlying) external view returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications\n     */\n    function userUnderlying(address user) external returns (uint256);\n\n     /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlying`, this function guarantees no state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @dev Implementation for these functions in particular may vary signifcantly for different strategies\n     */\n    function sharesToUnderlyingView(uint256 amountShares) external view returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToShares`, this function guarantees no state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @dev Implementation for these functions in particular may vary signifcantly for different strategies\n     */\n    function underlyingToSharesView(uint256 amountUnderlying) external view returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications\n     */\n    function userUnderlyingView(address user) external view returns (uint256);\n\n    /// @notice The underyling token for shares in this InvestmentStrategy\n    function underlyingToken() external view returns (IERC20);\n\n    /// @notice The total number of extant shares in thie InvestmentStrategy\n    function totalShares() external view returns (uint256);\n\n    /// @notice Returns either a brief string explaining the strategy's goal & purpose, or a link to metadata that explains in more detail.\n    function explanation() external view returns (string memory);\n}\n"
    },
    "contracts/libraries/eigenda/interfaces/IDelegationTerms.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./IInvestmentStrategy.sol\";\n\n/**\n * @title Abstract interface for a contract that helps structure the delegation relationship.\n * @author Layr Labs, Inc.\n * @notice The gas budget provided to this contract in calls from EigenLayr contracts is limited.\n */\n//TODO: discuss if we can structure the inputs of these functions better\ninterface IDelegationTerms {\n    function payForService(IERC20 token, uint256 amount) external payable;\n\n    function onDelegationWithdrawn(\n        address delegator,\n        IInvestmentStrategy[] memory investorStrats,\n        uint256[] memory investorShares\n    ) external;\n\n    // function onDelegationReceived(\n    //     address delegator,\n    //     uint256[] memory investorShares\n    // ) external;\n\n    function onDelegationReceived(\n        address delegator,\n        IInvestmentStrategy[] memory investorStrats,\n        uint256[] memory investorShares\n    ) external;\n}\n"
    },
    "contracts/libraries/eigenda/interfaces/IEigenLayrDelegation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./IDelegationTerms.sol\";\n\n/**\n * @title The interface for the primary delegation contract for EigenLayr.\n * @author Layr Labs, Inc.\n * @notice  This is the contract for delegation in EigenLayr. The main functionalities of this contract are\n * - enabling anyone to register as an operator in EigenLayr\n * - allowing new operators to provide a DelegationTerms-type contract, which may mediate their interactions with stakers who delegate to them\n * - enabling any staker to delegate its stake to the operator of its choice\n * - enabling a staker to undelegate its assets from an operator (performed as part of the withdrawal process, initiated through the InvestmentManager)\n */\ninterface IEigenLayrDelegation {\n\n    /**\n     * @notice This will be called by an operator to register itself as an operator that stakers can choose to delegate to.\n     * @param dt is the `DelegationTerms` contract that the operator has for those who delegate to them.\n     * @dev An operator can set `dt` equal to their own address (or another EOA address), in the event that they want to split payments\n     * in a more 'trustful' manner.\n     * @dev In the present design, once set, there is no way for an operator to ever modify the address of their DelegationTerms contract.\n     */\n    function registerAsOperator(IDelegationTerms dt) external;\n\n    /**\n     *  @notice This will be called by a staker to delegate its assets to some operator.\n     *  @param operator is the operator to whom staker (msg.sender) is delegating its assets\n     */\n    function delegateTo(address operator) external;\n\n    /**\n     * @notice Delegates from `staker` to `operator`.\n     * @dev requires that r, vs are a valid ECSDA signature from `staker` indicating their intention for this action\n     */\n    function delegateToBySignature(address staker, address operator, uint256 expiry, bytes32 r, bytes32 vs) external;\n\n    /**\n     * @notice Undelegates `staker` from the operator who they are delegated to.\n     * @notice Callable only by the InvestmentManager\n     * @dev Should only ever be called in the event that the `staker` has no active deposits in EigenLayer.\n     */\n    function undelegate(address staker) external;\n\n    /// @notice returns the address of the operator that `staker` is delegated to.\n    function delegatedTo(address staker) external view returns (address);\n\n    /// @notice returns the DelegationTerms of the `operator`, which may mediate their interactions with stakers who delegate to them.\n    function delegationTerms(address operator) external view returns (IDelegationTerms);\n\n    /// @notice returns the total number of shares in `strategy` that are delegated to `operator`.\n    function operatorShares(address operator, IInvestmentStrategy strategy) external view returns (uint256);\n\n    /**\n     * @notice Increases the `staker`'s delegated shares in `strategy` by `shares, typically called when the staker has further deposits into EigenLayr\n     * @dev Callable only by the InvestmentManager\n     */\n    function increaseDelegatedShares(address staker, IInvestmentStrategy strategy, uint256 shares) external;\n\n    /**\n     * @notice Decreases the `staker`'s delegated shares in each entry of `strategies` by its respective `shares[i]`, typically called when the staker withdraws from EigenLayr\n     * @dev Callable only by the InvestmentManager\n     */\n    function decreaseDelegatedShares(\n        address staker,\n        IInvestmentStrategy[] calldata strategies,\n        uint256[] calldata shares\n    ) external;\n\n    /// @notice Returns 'true' if `staker` *is* actively delegated, and 'false' otherwise.\n    function isDelegated(address staker) external view returns (bool);\n\n    /// @notice Returns 'true' if `staker` is *not* actively delegated, and 'false' otherwise.\n    function isNotDelegated(address staker) external returns (bool);\n\n    /// @notice Returns if an operator can be delegated to, i.e. it has called `registerAsOperator`.\n    function isOperator(address operator) external view returns (bool);\n}\n"
    },
    "contracts/libraries/eigenda/interfaces/IServiceManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IEigenLayrDelegation.sol\";\n\n/**\n * @title Interface for a `ServiceManager`-type contract.\n * @author Layr Labs, Inc.\n */\n// TODO: provide more functions for this spec\ninterface IServiceManager {\n    /// @notice Returns the current 'taskNumber' for the middleware\n    function taskNumber() external view returns (uint32);\n\n    /// @notice Permissioned function that causes the ServiceManager to freeze the operator on EigenLayer, through a call to the Slasher contract\n    function freezeOperator(address operator) external;\n\n    /// @notice Permissioned function to have the ServiceManager forward a call to the slasher, recording an initial stake update (on operator registration)\n    function recordFirstStakeUpdate(address operator, uint32 serveUntil) external;\n\n    /// @notice Permissioned function to have the ServiceManager forward a call to the slasher, recording a stake update\n    function recordStakeUpdate(address operator, uint32 updateBlock, uint32 serveUntil, uint256 prevElement) external;\n\n    /// @notice Permissioned function to have the ServiceManager forward a call to the slasher, recording a final stake update (on operator deregistration)\n    function recordLastStakeUpdateAndRevokeSlashingAbility(address operator, uint32 serveUntil) external;\n\n    /// @notice Collateral token used for placing collateral on challenges & payment commits\n    function collateralToken() external view returns (IERC20);\n\n    /// @notice The Delegation contract of EigenLayer.\n    function eigenLayrDelegation() external view returns (IEigenLayrDelegation);\n\n    /// @notice Returns the `latestTime` until which operators must serve.\n    function latestTime() external view returns (uint32);\n\n    function owner() external view returns (address);\n}"
    },
    "contracts/libraries/eigenda/interfaces/IDataLayrServiceManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IServiceManager.sol\";\nimport \"./IDelayedService.sol\";\nimport \"./IEigenLayrDelegation.sol\";\nimport \"./IDataLayrPaymentManager.sol\";\n\ninterface IDataLayrServiceManager is IServiceManager, IDelayedService {\n    //Relevant metadata for a given datastore\n    struct DataStoreMetadata {\n        bytes32 headerHash; // the hash of the header as defined in the contract\n        uint32 durationDataStoreId; // the id of the datastore relative to all other datastores of the same duration\n        uint32 globalDataStoreId; // the id of the datastore relative to all other datastores\n        uint32 referenceBlockNumber; // the block number from which the stakes were taken for the datastore\n        uint32 blockNumber; // the block number at the time of initialization\n        uint96 fee; // the amount of paymentToken paid for the datastore\n        address confirmer; // the address that is allowed to confirm the datastore\n        bytes32 signatoryRecordHash; // the hash of relavent signatory information for payments and fraud proofs\n    }\n\n    //Stores the data required to index a given datastore's metadata\n    struct DataStoreSearchData {\n        DataStoreMetadata metadata;\n        uint8 duration;\n        uint256 timestamp;\n        uint32 index;\n    }\n\n    struct SignatoryRecordMinusDataStoreId {\n        bytes32[] nonSignerPubkeyHashes;\n        uint256 signedStakeFirstQuorum;\n        uint256 signedStakeSecondQuorum;\n    }\n\n    struct DataStoresForDuration {\n        uint32 one_duration;\n        uint32 two_duration;\n        uint32 three_duration;\n        uint32 four_duration;\n        uint32 five_duration;\n        uint32 six_duration;\n        uint32 seven_duration;\n        uint32 dataStoreId;\n        uint32 latestTime;\n    }\n\n    struct DataStoreHashInputs {\n        bytes32 headerHash;\n        uint32 dataStoreId;\n        uint32 blockNumber;\n        uint256 fee;\n    }\n\n    /**\n     * @notice This function is used for\n     * - notifying via Ethereum that the disperser has asserted the data blob\n     * into DataLayr and is waiting to obtain quorum of DataLayr operators to sign,\n     * - asserting the metadata corresponding to the data asserted into DataLayr\n     * - escrow the service fees that DataLayr operators will receive from the disperser\n     * on account of their service.\n     *\n     * This function returns the index of the data blob in dataStoreIdsForDuration[duration][block.timestamp]\n     */\n    /**\n     * @param feePayer is the address that will be paying the fees for this datastore. check DataLayrPaymentManager for further details\n     * @param confirmer is the address that must confirm the datastore\n     * @param header is the summary of the data that is being asserted into DataLayr,\n     *  type DataStoreHeader struct {\n     *   KzgCommit      [64]byte\n     *   Degree         uint32\n     *   NumSys         uint32\n     *   NumPar         uint32\n     *   OrigDataSize   uint32\n     *   Disperser      [20]byte\n     *   LowDegreeProof [64]byte\n     *  }\n     * @param duration for which the data has to be stored by the DataLayr operators.\n     * This is a quantized parameter that describes how many factors of DURATION_SCALE\n     * does this data blob needs to be stored. The quantization process comes from ease of\n     * implementation in DataLayrBombVerifier.sol.\n     * @param blockNumber is the block number in Ethereum for which the confirmation will\n     * consult total + operator stake amounts.\n     * -- must not be more than 'BLOCK_STALE_MEASURE' (defined in DataLayr) blocks in past\n     * @return index The index in the array `dataStoreHashesForDurationAtTimestamp[duration][block.timestamp]` at which the DataStore's hash was stored.\n     */\n    function initDataStore(\n        address feePayer,\n        address confirmer,\n        uint8 duration,\n        uint32 blockNumber,\n        uint32 totalOperatorsIndex,\n        bytes calldata header\n    )\n        external\n        returns (uint32);\n\n    /**\n     * @notice This function is used for\n     * - disperser to notify that signatures on the message, comprising of hash( headerHash ),\n     * from quorum of DataLayr nodes have been obtained,\n     * - check that the aggregate signature is valid,\n     * - and check whether quorum has been achieved or not.\n     */\n    /**\n     * @param data Input to the `checkSignatures` function, which is of the format:\n     * <\n     * bytes32 msgHash,\n     * uint48 index of the totalStake corresponding to the dataStoreId in the 'totalStakeHistory' array of the BLSRegistry\n     * uint32 numberOfNonSigners,\n     * uint256[numberOfSigners][4] pubkeys of nonsigners,\n     * uint32 apkIndex,\n     * uint256[4] apk,\n     * uint256[2] sigma\n     * >\n     */\n    function confirmDataStore(bytes calldata data, DataStoreSearchData memory searchData) external;\n\n    /// @notice number of leaves in the root tree\n    function numPowersOfTau() external view returns (uint48);\n\n    /// @notice number of layers in the root tree\n    function log2NumPowersOfTau() external view returns (uint48);\n\n    /// @notice Unit of measure (in time) for the duration of DataStores\n    function DURATION_SCALE() external view returns (uint256);\n\n    /// @notice The longest allowed duation of a DataStore, measured in `DURATION_SCALE`\n    function MAX_DATASTORE_DURATION() external view returns (uint8);\n\n    /// @notice Returns the hash of the `index`th DataStore with the specified `duration` at the specified UTC `timestamp`.\n    function getDataStoreHashesForDurationAtTimestamp(uint8 duration, uint256 timestamp, uint32 index)\n        external\n        view\n        returns (bytes32);\n\n    /**\n     * @notice returns the number of data stores for the @param duration\n     */\n    function getNumDataStoresForDuration(uint8 duration) external view returns (uint32);\n\n    /// @notice Collateral token used for placing collateral on challenges & payment commits\n    function collateralToken() external view returns (IERC20);\n\n    /**\n     * @notice contract used for handling payment challenges\n     */\n    function dataLayrPaymentManager() external view returns (IDataLayrPaymentManager);\n\n    /**\n     * @notice Checks that the hash of the `index`th DataStore with the specified `duration` at the specified UTC `timestamp` matches the supplied `metadata`.\n     * Returns 'true' if the metadata matches the hash, and 'false' otherwise.\n     */\n   function verifyDataStoreMetadata(uint8 duration, uint256 timestamp, uint32 index, DataStoreMetadata memory metadata) external view returns (bool);\n}\n"
    },
    "contracts/libraries/eigenda/interfaces/IDelayedService.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n/**\n * @title Interface for a middleware / service that may look at past stake amounts.\n * @author Layr Labs, Inc.\n * @notice Specifically, this interface is designed for services that consult stake amounts up to `BLOCK_STALE_MEASURE`\n * blocks in the past. This may be necessary due to, e.g., network processing & communication delays, or to avoid race conditions\n * that could be present with coordinating aggregate operator signatures while service operators are registering & de-registering.\n * @dev To clarify edge cases, the middleware can look `BLOCK_STALE_MEASURE` blocks into the past, i.e. it may trust stakes from the interval\n * [block.number - BLOCK_STALE_MEASURE, block.number] (specifically, *inclusive* of the block that is `BLOCK_STALE_MEASURE` before the current one)\n */\ninterface IDelayedService {\n    /// @notice The maximum amount of blocks in the past that the service will consider stake amounts to still be 'valid'.\n    function BLOCK_STALE_MEASURE() external view returns(uint32);    \n}\n"
    },
    "contracts/libraries/eigenda/interfaces/IDataLayrPaymentManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./IPaymentManager.sol\";\nimport \"./IDataLayrServiceManager.sol\";\n\n/**\n * @title Minimal interface extension to `IPaymentManager`.\n * @author Layr Labs, Inc.\n * @notice Adds a single DataLayr-specific function to the base interface.\n */\ninterface IDataLayrPaymentManager is IPaymentManager {\n    /**\n     * @notice Used to perform the final step in a payment challenge, in which the 'trueAmount' is determined and the winner of the challenge is decided.\n     * This function is called by a party after the other party has bisected the challenged payments to a difference of one, i.e., further bisection\n     * is not possible. Once the payments can no longer be bisected, the function resolves the challenge by determining who is wrong.\n     * @param stakeHistoryIndex is used as an input to `registry.checkOperatorInactiveAtBlockNumber` -- see that function's documentation\n     */\n    function respondToPaymentChallengeFinal(\n        address operator,\n        uint256 stakeIndex,\n        uint48 nonSignerIndex,\n        bytes32[] memory nonSignerPubkeyHashes,\n        TotalStakes calldata totalStakesSigned,\n        IDataLayrServiceManager.DataStoreSearchData calldata searchData,\n        uint256 stakeHistoryIndex\n    ) external;\n}\n"
    },
    "contracts/libraries/eigenda/interfaces/IPaymentManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Interface for a `PaymentManager` contract.\n * @author Layr Labs, Inc.\n */\ninterface IPaymentManager {\n    enum DissectionType {\n        INVALID,\n        FIRST_HALF,\n        SECOND_HALF\n    }\n    enum PaymentStatus {\n        REDEEMED,\n        COMMITTED,\n        CHALLENGED\n    }\n    enum ChallengeStatus {\n        RESOLVED,\n        OPERATOR_TURN,\n        CHALLENGER_TURN,\n        OPERATOR_TURN_ONE_STEP,\n        CHALLENGER_TURN_ONE_STEP\n    }\n\n    /**\n     * @notice used for storing information on the most recent payment made to the operator\n     */\n    struct Payment {\n        // taskNumber starting from which payment is being claimed\n        uint32 fromTaskNumber;\n        // taskNumber until which payment is being claimed (exclusive)\n        uint32 toTaskNumber;\n        // recording when the payment will optimistically be confirmed; used for fraudproof period\n        uint32 confirmAt;\n        // payment for range [fromTaskNumber, toTaskNumber)\n        /// @dev max 1.3e36, keep in mind for token decimals\n        uint96 amount;\n        /**\n         * @notice The possible statuses are:\n         * - 0: REDEEMED,\n         * - 1: COMMITTED,\n         * - 2: CHALLENGED\n         */\n        PaymentStatus status;\n        uint256 collateral; //account for if collateral changed\n    }\n\n    /**\n     * @notice used for storing information on the payment challenge as part of the interactive process\n     */\n    struct PaymentChallenge {\n        // operator whose payment claim is being challenged,\n        address operator;\n        // the entity challenging with the fraudproof\n        address challenger;\n        // address of the service manager contract\n        address serviceManager;\n        // the TaskNumber from which payment has been computed\n        uint32 fromTaskNumber;\n        // the TaskNumber until which payment has been computed to\n        uint32 toTaskNumber;\n        // reward amount the challenger claims is for the first half of tasks\n        uint96 amount1;\n        // reward amount the challenger claims is for the second half of tasks\n        uint96 amount2;\n        // used for recording the time when challenge was created\n        uint32 settleAt; // when committed, used for fraudproof period\n        // indicates the status of the challenge\n        /**\n         * @notice The possible statuses are:\n         * - 0: RESOLVED,\n         * - 1: operator turn (dissection),\n         * - 2: challenger turn (dissection),\n         * - 3: operator turn (one step),\n         * - 4: challenger turn (one step)\n         */\n        ChallengeStatus status;\n    }\n\n    struct TotalStakes {\n        uint256 signedStakeFirstQuorum;\n        uint256 signedStakeSecondQuorum;\n    }\n\n    /**\n     * @notice deposit one-time fees by the `msg.sender` with this contract to pay for future tasks of this middleware\n     * @param onBehalfOf could be the `msg.sender` themselves, or a different address for whom `msg.sender` is depositing these future fees\n     * @param amount is amount of futures fees being deposited\n     */\n    function depositFutureFees(address onBehalfOf, uint256 amount) external;\n\n    /// @notice Allows the `allowed` address to spend up to `amount` of the `msg.sender`'s funds that have been deposited in this contract\n    function setAllowance(address allowed, uint256 amount) external;\n\n    /// @notice Used for deducting the fees from the payer to the middleware\n    function payFee(address initiator, address payer, uint256 feeAmount) external;\n\n    /**\n     * @notice Modifies the `paymentFraudproofCollateral` amount.\n     * @param _paymentFraudproofCollateral The new value for `paymentFraudproofCollateral` to take.\n     */\n    function setPaymentFraudproofCollateral(uint256 _paymentFraudproofCollateral) external;\n\n    /**\n     * @notice This is used by an operator to make a claim on the amount that they deserve for their service from their last payment until `toTaskNumber`\n     * @dev Once this payment is recorded, a fraud proof period commences during which a challenger can dispute the proposed payment.\n     */\n    function commitPayment(uint32 toTaskNumber, uint96 amount) external;\n\n    /**\n     * @notice Called by an operator to redeem a payment that they previously 'committed' to by calling `commitPayment`.\n     * @dev This function can only be called after the challenge window for the payment claim has completed.\n     */\n    function redeemPayment() external;\n\n    /**\n     * @notice This function is called by a fraud prover to challenge a payment, initiating an interactive-type fraudproof.\n     * @param operator is the operator against whose payment claim the fraudproof is being made\n     * @param amount1 is the reward amount the challenger in that round claims is for the first half of tasks\n     * @param amount2 is the reward amount the challenger in that round claims is for the second half of tasks\n     *\n     */\n    function initPaymentChallenge(address operator, uint96 amount1, uint96 amount2) external;\n\n    /**\n     * @notice Perform a single bisection step in an existing interactive payment challenge.\n     * @param operator The middleware operator who was challenged (used to look up challenge details)\n     * @param secondHalf If true, then the caller wishes to challenge the amount claimed as payment in the *second half* of the\n     * previous bisection step. If false then the *first half* is indicated instead.\n     * @param amount1 The amount that the caller asserts the operator is entitled to, for the first half *of the challenged half* of the previous bisection.\n     * @param amount2 The amount that the caller asserts the operator is entitled to, for the second half *of the challenged half* of the previous bisection.\n     */\n    function performChallengeBisectionStep(address operator, bool secondHalf, uint96 amount1, uint96 amount2)\n        external;\n\n    /// @notice resolve an existing PaymentChallenge for an operator\n    function resolveChallenge(address operator) external;\n\n    /**\n     * @notice Challenge window for submitting fraudproof in the case of an incorrect payment claim by a registered operator.\n     */\n    function paymentFraudproofInterval() external view returns (uint256);\n\n    /**\n     * @notice Specifies the payment that has to be made as a collateral for fraudproof during payment challenges.\n     */\n    function paymentFraudproofCollateral() external view returns (uint256);\n\n    /// @notice the ERC20 token that will be used by the disperser to pay the service fees to middleware nodes.\n    function paymentToken() external view returns (IERC20);\n\n    /// @notice Collateral token used for placing collateral on challenges & payment commits\n    function collateralToken() external view returns (IERC20);\n\n    /// @notice Returns the ChallengeStatus for the `operator`'s payment claim.\n    function getChallengeStatus(address operator) external view returns (ChallengeStatus);\n\n    /// @notice Returns the 'amount1' for the `operator`'s payment claim.\n    function getAmount1(address operator) external view returns (uint96);\n\n    /// @notice Returns the 'amount2' for the `operator`'s payment claim.\n    function getAmount2(address operator) external view returns (uint96);\n\n    /// @notice Returns the 'toTaskNumber' for the `operator`'s payment claim.\n    function getToTaskNumber(address operator) external view returns (uint48);\n\n    /// @notice Returns the 'fromTaskNumber' for the `operator`'s payment claim.\n    function getFromTaskNumber(address operator) external view returns (uint48);\n\n    /// @notice Returns the task number difference for the `operator`'s payment claim.\n    function getDiff(address operator) external view returns (uint48);\n\n    /// @notice Returns the active collateral of the `operator` placed on their payment claim.\n    function getPaymentCollateral(address) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/eigenda/DataStoreUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.9;\n\nimport \"./interfaces/IDataLayrServiceManager.sol\";\n\n/**\n * @title Library of functions shared across DataLayr.\n * @author Layr Labs, Inc.\n */\nlibrary DataStoreUtils {\n    uint16 public constant BIP_MULTIPLIER = 10000;\n\n    uint256 public constant BYTES_PER_COEFFICIENT = 31;\n    uint256 public constant BIT_SHIFT_degree = 224;\n    uint256 public constant BIT_SHIFT_numSys = 224;\n    uint256 public constant HEADER_OFFSET_degree = 64;\n    uint256 public constant HEADER_OFFSET_numSys = 68;\n\n\n    function getTotalBytes(bytes calldata header, uint32 totalChunks) internal pure returns(uint256) {\n        uint256 numCoefficients;\n        assembly {\n            //numCoefficients = totalChunks * (degree + 1)\n            //NOTE: degree + 1 is the number of coefficients\n            numCoefficients := mul(totalChunks, add(shr(BIT_SHIFT_degree, calldataload(add(header.offset, HEADER_OFFSET_degree))), 1))\n        }\n        return numCoefficients * BYTES_PER_COEFFICIENT;\n    }\n    /// @param header of the datastore that the coding ratio is being retrieved for\n    /// @param totalChunks the total number of chunks expected in this datastore\n    /// @return codingRatio of the datastore in basis points\n    function getCodingRatio(bytes calldata header, uint32 totalChunks) internal pure returns(uint16) {\n        uint32 codingRatio;\n        assembly {\n            //codingRatio = numSys\n            codingRatio := shr(BIT_SHIFT_numSys, calldataload(add(header.offset, HEADER_OFFSET_numSys)))\n            //codingRatio = numSys * BIP_MULTIPLIER / totalChunks\n            codingRatio := div(mul(codingRatio, BIP_MULTIPLIER), totalChunks)\n        }\n        return uint16(codingRatio);\n    }\n\n    function getDegree(bytes calldata header) internal pure returns (uint32) {\n        uint32 degree;\n        assembly {\n            degree := shr(BIT_SHIFT_degree, calldataload(add(header.offset, HEADER_OFFSET_degree)))\n        }\n        return degree;\n    }\n\n    /// @notice Finds the `signatoryRecordHash`, used for fraudproofs.\n    function computeSignatoryRecordHash(\n        uint32 globalDataStoreId,\n        bytes32[] memory nonSignerPubkeyHashes,\n        uint256 signedStakeFirstQuorum,\n        uint256 signedStakeSecondQuorum\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(globalDataStoreId, nonSignerPubkeyHashes, signedStakeFirstQuorum, signedStakeSecondQuorum)\n        );\n    }\n\n    /// @notice Computes the hash of a single DataStore's metadata.\n    function computeDataStoreHash(IDataLayrServiceManager.DataStoreMetadata memory metadata)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 dsHash = keccak256(\n            abi.encodePacked(\n                metadata.headerHash,\n                metadata.durationDataStoreId,\n                metadata.globalDataStoreId,\n                metadata.referenceBlockNumber,\n                metadata.blockNumber,\n                metadata.fee,\n                metadata.confirmer,\n                metadata.signatoryRecordHash\n            )\n        );\n        return dsHash;\n    }\n\n    /// @notice uses `abi.encodePacked` to encode a DataStore's metadata into a compressed format\n    function packDataStoreMetadata(IDataLayrServiceManager.DataStoreMetadata memory metadata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return (\n            abi.encodePacked(\n                metadata.headerHash,\n                metadata.durationDataStoreId,\n                metadata.globalDataStoreId,\n                metadata.referenceBlockNumber,\n                metadata.blockNumber,\n                metadata.fee,\n                metadata.confirmer,\n                metadata.signatoryRecordHash\n            )\n        );\n    }\n\n    /// @notice uses `abi.encodePacked` to encode a DataStore's searchData into a compressed format\n    function packDataStoreSearchData(IDataLayrServiceManager.DataStoreSearchData memory searchData)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return (\n            abi.encodePacked(\n                packDataStoreMetadata(searchData.metadata), searchData.duration, searchData.timestamp, searchData.index\n            )\n        );\n    }\n\n    // CONSTANTS -- commented out lines are due to inline assembly supporting *only* 'direct number constants' (for now, at least)\n    // OBJECT BIT LENGTHS\n    uint256 internal constant BIT_LENGTH_headerHash = 256;\n    uint256 internal constant BIT_LENGTH_durationDataStoreId = 32;\n    uint256 internal constant BIT_LENGTH_globalDataStoreId = 32;\n    uint256 internal constant BIT_LENGTH_referenceBlockNumber = 32;\n    uint256 internal constant BIT_LENGTH_blockNumber = 32;\n    uint256 internal constant BIT_LENGTH_fee = 96;\n    uint256 internal constant BIT_LENGTH_confirmer = 160;\n    uint256 internal constant BIT_LENGTH_signatoryRecordHash = 256;\n    uint256 internal constant BIT_LENGTH_duration = 8;\n    uint256 internal constant BIT_LENGTH_timestamp = 256;\n    uint256 internal constant BIT_LENGTH_index = 32;\n\n    // OBJECT BIT SHIFTS FOR READING FROM CALLDATA -- don't bother with using 'shr' if any of these is 0\n    // uint256 internal constant BIT_SHIFT_headerHash = 256 - BIT_LENGTH_headerHash;\n    // uint256 internal constant BIT_SHIFT_durationDataStoreId = 256 - BIT_LENGTH_durationDataStoreId;\n    // uint256 internal constant BIT_SHIFT_globalDataStoreId = 256 - BIT_LENGTH_globalDataStoreId;\n    // uint256 internal constant BIT_SHIFT_referenceBlockNumber = 256 - BIT_LENGTH_referenceBlockNumber;\n    // uint256 internal constant BIT_SHIFT_blockNumber = 256 - BIT_LENGTH_blockNumber;\n    // uint256 internal constant BIT_SHIFT_fee = 256 - BIT_LENGTH_fee;\n    // uint256 internal constant BIT_SHIFT_confirmer = 256 - BIT_LENGTH_confirmer;\n    // uint256 internal constant BIT_SHIFT_signatoryRecordHash = 256 - BIT_LENGTH_signatoryRecordHash;\n    // uint256 internal constant BIT_SHIFT_duration = 256 - BIT_LENGTH_duration;\n    // uint256 internal constant BIT_SHIFT_timestamp = 256 - BIT_LENGTH_timestamp;\n    // uint256 internal constant BIT_SHIFT_index = 256 - BIT_LENGTH_index;\n    uint256 internal constant BIT_SHIFT_headerHash = 0;\n    uint256 internal constant BIT_SHIFT_durationDataStoreId = 224;\n    uint256 internal constant BIT_SHIFT_globalDataStoreId = 224;\n    uint256 internal constant BIT_SHIFT_referenceBlockNumber = 224;\n    uint256 internal constant BIT_SHIFT_blockNumber = 224;\n    uint256 internal constant BIT_SHIFT_fee = 160;\n    uint256 internal constant BIT_SHIFT_confirmer = 96;\n    uint256 internal constant BIT_SHIFT_signatoryRecordHash = 0;\n    uint256 internal constant BIT_SHIFT_duration = 248;\n    uint256 internal constant BIT_SHIFT_timestamp = 0;\n    uint256 internal constant BIT_SHIFT_index = 224;\n\n    // CALLDATA OFFSETS IN BYTES -- adding 7 and dividing by 8 here is for rounding *up* the bit amounts to bytes amounts\n    // uint256 internal constant CALLDATA_OFFSET_headerHash = 0;\n    // uint256 internal constant CALLDATA_OFFSET_durationDataStoreId = ((BIT_LENGTH_headerHash + 7) / 8);\n    // uint256 internal constant CALLDATA_OFFSET_globalDataStoreId = CALLDATA_OFFSET_durationDataStoreId + ((BIT_LENGTH_durationDataStoreId + 7) / 8);\n    // uint256 internal constant CALLDATA_OFFSET_referenceBlockNumber = CALLDATA_OFFSET_globalDataStoreId + ((BIT_LENGTH_globalDataStoreId + 7) / 8);\n    // uint256 internal constant CALLDATA_OFFSET_blockNumber = CALLDATA_OFFSET_referenceBlockNumber + ((BIT_LENGTH_referenceBlockNumber + 7) / 8);\n    // uint256 internal constant CALLDATA_OFFSET_fee = CALLDATA_OFFSET_blockNumber + ((BIT_LENGTH_blockNumber + 7) / 8);\n    // uint256 internal constant CALLDATA_OFFSET_confirmer = CALLDATA_OFFSET_fee + ((BIT_LENGTH_fee + 7) / 8);\n    // uint256 internal constant CALLDATA_OFFSET_signatoryRecordHash = CALLDATA_OFFSET_confirmer + ((BIT_LENGTH_confirmer + 7) / 8);\n    // uint256 internal constant CALLDATA_OFFSET_duration = CALLDATA_OFFSET_signatoryRecordHash + ((BIT_LENGTH_signatoryRecordHash + 7) / 8);\n    // uint256 internal constant CALLDATA_OFFSET_timestamp = CALLDATA_OFFSET_duration + ((BIT_LENGTH_duration + 7) / 8);\n    // uint256 internal constant CALLDATA_OFFSET_index = CALLDATA_OFFSET_timestamp + ((BIT_LENGTH_timestamp + 7) / 8);\n    uint256 internal constant CALLDATA_OFFSET_headerHash = 0;\n    uint256 internal constant CALLDATA_OFFSET_durationDataStoreId = 32;\n    uint256 internal constant CALLDATA_OFFSET_globalDataStoreId = 36;\n    uint256 internal constant CALLDATA_OFFSET_referenceBlockNumber = 40;\n    uint256 internal constant CALLDATA_OFFSET_blockNumber = 44;\n    uint256 internal constant CALLDATA_OFFSET_fee = 48;\n    uint256 internal constant CALLDATA_OFFSET_confirmer = 60;\n    uint256 internal constant CALLDATA_OFFSET_signatoryRecordHash = 80;\n    uint256 internal constant CALLDATA_OFFSET_duration = 112;\n    uint256 internal constant CALLDATA_OFFSET_timestamp = 113;\n    uint256 internal constant CALLDATA_OFFSET_index = 145;\n\n    // MEMORY OFFSETS IN BYTES\n    uint256 internal constant MEMORY_OFFSET_headerHash = 0;\n    uint256 internal constant MEMORY_OFFSET_durationDataStoreId = 32;\n    uint256 internal constant MEMORY_OFFSET_globalDataStoreId = 64;\n    uint256 internal constant MEMORY_OFFSET_referenceBlockNumber = 96;\n    uint256 internal constant MEMORY_OFFSET_blockNumber = 128;\n    uint256 internal constant MEMORY_OFFSET_fee = 160;\n    uint256 internal constant MEMORY_OFFSET_confirmer = 192;\n    uint256 internal constant MEMORY_OFFSET_signatoryRecordHash = 224;\n    /**\n    *  Here MEMORY_OFFSET_duration is only 32 despite metadata struct being much longer\n    *  than 32 bytes.  I'm unsure why the memory-offsets work this way, but they do. See usage below.\n    */\n    uint256 internal constant MEMORY_OFFSET_duration = 32;\n    uint256 internal constant MEMORY_OFFSET_timestamp = 64;\n    uint256 internal constant MEMORY_OFFSET_index = 96;\n\n    /**\n     * @notice Unpacks the packed metadata of a DataStore into a metadata struct.\n     * @param packedMetadata should be in the same form as the output of `packDataStoreMetadata`\n     */\n    function unpackDataStoreMetadata(bytes calldata packedMetadata)\n        internal\n        pure\n        returns (IDataLayrServiceManager.DataStoreMetadata memory metadata)\n    {\n        uint256 pointer;\n        assembly {\n            // fetch offset of `packedMetadata` input in calldata\n            pointer := packedMetadata.offset\n            mstore(\n                // store in the headerHash memory location in `metadata`\n                metadata,\n                // read the headerHash from its calldata position in `packedMetadata`\n                calldataload(pointer)\n            )\n            mstore(\n                // store in the durationDataStoreId memory location in `metadata`\n                add(metadata, MEMORY_OFFSET_durationDataStoreId),\n                // read the durationDataStoreId from its calldata position in `packedMetadata`\n                shr(BIT_SHIFT_durationDataStoreId, calldataload(add(pointer, CALLDATA_OFFSET_durationDataStoreId)))\n            )\n            mstore(\n                // store in the globalDataStoreId memory location in `metadata`\n                add(metadata, MEMORY_OFFSET_globalDataStoreId),\n                // read the globalDataStoreId from its calldata position in `packedMetadata`\n                shr(BIT_SHIFT_globalDataStoreId, calldataload(add(pointer, CALLDATA_OFFSET_globalDataStoreId)))\n            )\n            mstore(\n                // store in the blockNumber memory location in `metadata`\n                add(metadata, MEMORY_OFFSET_referenceBlockNumber),\n                // read the blockNumber from its calldata position in `packedMetadata`\n                shr(BIT_SHIFT_blockNumber, calldataload(add(pointer, CALLDATA_OFFSET_referenceBlockNumber)))\n            )\n            mstore(\n                // store in the blockNumber memory location in `metadata`\n                add(metadata, MEMORY_OFFSET_blockNumber),\n                // read the blockNumber from its calldata position in `packedMetadata`\n                shr(BIT_SHIFT_blockNumber, calldataload(add(pointer, CALLDATA_OFFSET_blockNumber)))\n            )\n            mstore(\n                // store in the fee memory location in `metadata`\n                add(metadata, MEMORY_OFFSET_fee),\n                // read the fee from its calldata position in `packedMetadata`\n                shr(BIT_SHIFT_fee, calldataload(add(pointer, CALLDATA_OFFSET_fee)))\n            )\n            mstore(\n                // store in the confirmer memory location in `metadata`\n                add(metadata, MEMORY_OFFSET_confirmer),\n                // read the confirmer from its calldata position in `packedMetadata`\n                shr(BIT_SHIFT_confirmer, calldataload(add(pointer, CALLDATA_OFFSET_confirmer)))\n            )\n            mstore(\n                // store in the signatoryRecordHash memory location in `metadata`\n                add(metadata, MEMORY_OFFSET_signatoryRecordHash),\n                // read the signatoryRecordHash from its calldata position in `packedMetadata`\n                calldataload(add(pointer, CALLDATA_OFFSET_signatoryRecordHash))\n            )\n        }\n        return metadata;\n    }\n\n    /**\n     * @notice Unpacks the packed searchData of a DataStore into a searchData struct.\n     * @param packedSearchData should be in the same form as the output of `packDataStoreSearchData`\n     */\n    function unpackDataStoreSearchData(bytes calldata packedSearchData)\n        internal\n        pure\n        returns (IDataLayrServiceManager.DataStoreSearchData memory searchData)\n    {\n        searchData.metadata = (unpackDataStoreMetadata(packedSearchData));\n        uint256 pointer;\n        assembly {\n            // fetch offset of `packedSearchData` input in calldata\n            pointer := packedSearchData.offset\n            mstore(\n                // store in the duration memory location of `searchData`\n                add(searchData, MEMORY_OFFSET_duration),\n                // read the duration from its calldata position in `packedSearchData`\n                shr(BIT_SHIFT_duration, calldataload(add(pointer, CALLDATA_OFFSET_duration)))\n            )\n            mstore(\n                // store in the timestamp memory location of `searchData`\n                add(searchData, MEMORY_OFFSET_timestamp),\n                // read the timestamp from its calldata position in `packedSearchData`\n                calldataload(add(pointer, CALLDATA_OFFSET_timestamp))\n            )\n            mstore(\n                // store in the index memory location of `searchData`\n                add(searchData, MEMORY_OFFSET_index),\n                // read the index from its calldata position in `packedSearchData`\n                shr(BIT_SHIFT_index, calldataload(add(pointer, CALLDATA_OFFSET_index)))\n            )\n        }\n        return searchData;\n    }\n}\n"
    },
    "contracts/da/BVM_EigenDataLayrChain.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport { DataLayrDisclosureLogic } from \"../libraries/eigenda/DataLayrDisclosureLogic.sol\";\nimport { IDataLayrServiceManager } from \"../libraries/eigenda/interfaces/IDataLayrServiceManager.sol\";\nimport { BN254 } from \"../libraries/eigenda/BN254.sol\";\nimport { DataStoreUtils } from \"../libraries/eigenda/DataStoreUtils.sol\";\nimport { Parser } from \"../libraries/eigenda/Parse.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n\ncontract BVM_EigenDataLayrChain is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, Parser {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    enum RollupStoreStatus {\n        UNCOMMITTED,\n        COMMITTED,\n        REVERTED\n    }\n\n    struct DisclosureProofs {\n        bytes header;\n        uint32 firstChunkNumber;\n        bytes[] polys;\n        DataLayrDisclosureLogic.MultiRevealProof[] multiRevealProofs;\n        BN254.G2Point polyEquivalenceProof;\n    }\n\n    address public sequencer;\n    address public dataManageAddress;\n    uint256 public BLOCK_STALE_MEASURE;\n    uint256 public l2StoredBlockNumber;\n    uint256 public l2ConfirmedBlockNumber;\n    uint256 public fraudProofPeriod;\n    uint256 public rollupBatchIndex;\n\n    bytes public constant FRAUD_STRING = '--This is a bad string. Nobody says this string.--';\n    uint256 internal constant DATA_STORE_INITIALIZED_BUT_NOT_CONFIRMED = type(uint256).max;\n\n    struct RollupStore {\n        uint32 originDataStoreId;\n        uint32 dataStoreId;\n        uint32 confirmAt;\n        RollupStoreStatus status;\n    }\n\n    struct BatchRollupBlock {\n        uint256 startL2BlockNumber;\n        uint256 endBL2BlockNumber;\n        bool    isReRollup;\n    }\n\n    mapping(uint256 => RollupStore) public rollupBatchIndexRollupStores;\n    mapping(uint32 => BatchRollupBlock) public dataStoreIdToL2RollUpBlock;\n    mapping(uint32 => uint256) public dataStoreIdToRollupStoreNumber;\n    mapping(address => bool) private fraudProofWhitelist;\n\n    address public reSubmitterAddress;\n    uint256 public reRollupIndex;\n    mapping(uint256 => uint256) public reRollupBatchIndex;\n\n    event RollupStoreInitialized(uint32 dataStoreId, uint256 stratL2BlockNumber, uint256 endL2BlockNumber);\n    event RollupStoreConfirmed(uint256 rollupBatchIndex, uint32 dataStoreId, uint256 stratL2BlockNumber, uint256 endL2BlockNumber);\n    event RollupStoreReverted(uint256 rollupBatchIndex, uint32 dataStoreId, uint256 stratL2BlockNumber, uint256 endL2BlockNumber);\n    event ReRollupBatchData(uint256 reRollupIndex, uint256 rollupBatchIndex, uint256 stratL2BlockNumber, uint256 endL2BlockNumber);\n    event SequencerAddressUpdated(address oldSequencerAddress, address newSequencerAddress);\n    event FraudProofPeriodUpdated(uint256 oldFraudProofPeriod, uint256 newFraudProofPeriod);\n    event ReSubmitterAddressUpdated(address oldReSubmitterAddress, address newReSubmitterAddress);\n    event RollupBatchIndexUpdated(uint256 oldRollupBatchIndex, uint256 newRollupBatchIndex);\n    event L2ConfirmedBlockNumberUpdated(uint256 oldL2ConfirmedBlockNumber, uint256 newL2ConfirmedBlockNumber);\n    event DataLayrManagerAddressUpdated(address oldDataLayrManagerAddress, address newDataLayrManagerAddress);\n    event ResetRollupBatchData(uint256 rollupBatchIndex, uint256 l2StoredBlockNumber, uint256 l2ConfirmedBlockNumber);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _sequencer, address _dataManageAddress, address _reSubmitterAddress, uint256 _block_stale_measure, uint256 _fraudProofPeriod, uint256 _l2SubmittedBlockNumber) public initializer {\n        require(_sequencer != address(0), \"initialize: can't set zero address to _sequencer address\");\n        require(_dataManageAddress != address(0), \"initialize: can't set zero address to _dataManageAddress\");\n        require(_reSubmitterAddress != address(0), \"initialize: can't set zero address to _reSubmitterAddress\");\n        require(_fraudProofPeriod >= 3600, \"initialize: _fraudProofPeriod must be no less than one hour\");\n        require(_fraudProofPeriod <= 25200, \"initialize: _fraudProofPeriod must be no more than seven hour\");\n        __Ownable_init();\n        sequencer = _sequencer;\n        dataManageAddress = _dataManageAddress;\n        reSubmitterAddress = _reSubmitterAddress;\n        BLOCK_STALE_MEASURE = _block_stale_measure;\n        fraudProofPeriod = _fraudProofPeriod;\n        l2StoredBlockNumber = _l2SubmittedBlockNumber;\n        l2ConfirmedBlockNumber = _l2SubmittedBlockNumber;\n    }\n\n    modifier onlySequencer() {\n        require(msg.sender == sequencer, \"Only the sequencer can do this action\");\n        _;\n    }\n\n    /**\n     * @notice Returns the block number of the latest stored L2.\n     * @return Latest stored L2 block number.\n     */\n    function getL2StoredBlockNumber() public view returns (uint256) {\n        return l2StoredBlockNumber;\n    }\n\n    /**\n     * @notice Returns the block number of the latest stored L2.\n     * @return Latest stored L2 block number.\n     */\n    function getL2ConfirmedBlockNumber() public view returns (uint256) {\n        return l2ConfirmedBlockNumber;\n    }\n\n    /**\n     * @notice Returns the rollup store by l2 block number\n     * @return RollupStore.\n     */\n    function getRollupStoreByRollupBatchIndex(uint256 _rollupBatchIndex) public view returns (RollupStore memory) {\n        return rollupBatchIndexRollupStores[_rollupBatchIndex];\n    }\n\n    /**\n    * @notice Returns the l2 block number by store id\n     * @return BatchRollupBlock.\n     */\n    function getL2RollUpBlockByDataStoreId(uint32 _dataStoreId) public view returns (BatchRollupBlock memory) {\n        return dataStoreIdToL2RollUpBlock[_dataStoreId];\n    }\n\n    /**\n    * @notice set fraud proof address\n    * @param _address for fraud proof\n    */\n    function setFraudProofAddress(address _address) external onlySequencer {\n        require(_address != address(0), \"setFraudProofAddress: address is the zero address\");\n        fraudProofWhitelist[_address] = true;\n    }\n\n    /**\n    * @notice remove fraud proof address\n    * @param _address for fraud proof\n    */\n    function removeFraudProofAddress(address _address) external onlySequencer {\n        require(_address != address(0), \"removeFraudProofAddress: removeFraudProofAddress: address is the zero address\");\n        delete fraudProofWhitelist[_address];\n    }\n\n    /**\n    * @notice update fraud proof period\n    * @param _fraudProofPeriod fraud proof period\n    */\n    function updateFraudProofPeriod(uint256 _fraudProofPeriod) external onlySequencer {\n        // MantleDa data validity period is at least one hour\n        require(_fraudProofPeriod >= 3600, \"updateFraudProofPeriod: _fraudProofPeriod need more than one hour\");\n        // MantleDa data validity max period seven hour\n        require(_fraudProofPeriod <= 25200, \"updateFraudProofPeriod: _fraudProofPeriod need less than seven hour\");\n        uint256 oldFraudProofPeriod = fraudProofPeriod;\n        fraudProofPeriod = _fraudProofPeriod;\n        emit FraudProofPeriodUpdated(oldFraudProofPeriod, fraudProofPeriod);\n    }\n\n    /**\n    * @notice update dlsm address\n    * @param _dataManageAddress dlsm address\n    */\n    function updateDataLayrManagerAddress(address _dataManageAddress) external onlySequencer {\n        require(_dataManageAddress != address(0), \"updateDataLayrManagerAddress: _dataManageAddress is the zero address\");\n        address oldDataManageAddress = dataManageAddress;\n        dataManageAddress = _dataManageAddress;\n        emit DataLayrManagerAddressUpdated(oldDataManageAddress, dataManageAddress);\n    }\n\n    /**\n    * @notice update l2 latest store block number\n    * @param _l2StoredBlockNumber l2 latest block number\n    */\n    function updateL2StoredBlockNumber(uint256 _l2StoredBlockNumber) external onlySequencer {\n        uint256 oldL2StoredBlockNumber = l2StoredBlockNumber;\n        l2StoredBlockNumber = _l2StoredBlockNumber;\n        emit L2ConfirmedBlockNumberUpdated(oldL2StoredBlockNumber, l2StoredBlockNumber);\n    }\n\n    /**\n    * @notice update l2 latest confirm block number\n    * @param _l2ConfirmedBlockNumber l2 latest block number\n    */\n    function updateL2ConfirmedBlockNumber(uint256 _l2ConfirmedBlockNumber) external onlySequencer {\n        l2ConfirmedBlockNumber = _l2ConfirmedBlockNumber;\n    }\n\n    /**\n    * @notice update sequencer address\n    * @param _sequencer update sequencer address\n    */\n    function updateSequencerAddress(address _sequencer) external onlyOwner {\n        require(_sequencer != address(0), \"updateSequencerAddress: _sequencer is the zero address\");\n        address oldSequencer = sequencer;\n        sequencer = _sequencer;\n        emit SequencerAddressUpdated(oldSequencer, sequencer);\n    }\n\n    function updateReSubmitterAddress(address _reSubmitterAddress) external onlySequencer {\n        require(_reSubmitterAddress != address(0), \"updateReSubmitterAddress: _reSubmitterAddress is the zero address\");\n        address oldReSubmitterAddress = reSubmitterAddress;\n        reSubmitterAddress = _reSubmitterAddress;\n        emit ReSubmitterAddressUpdated(oldReSubmitterAddress, reSubmitterAddress);\n    }\n\n    /**\n    * @notice update rollup batch index\n    * @param _rollupBatchIndex update rollup batch index\n    */\n    function updateRollupBatchIndex(uint256 _rollupBatchIndex) external onlySequencer {\n        uint256 oldRollupBatchIndex = rollupBatchIndex;\n        rollupBatchIndex = _rollupBatchIndex;\n        emit RollupBatchIndexUpdated(oldRollupBatchIndex, rollupBatchIndex);\n    }\n\n    /**\n    * @notice reset batch rollup batch data\n    * @param _rollupBatchIndex update rollup index\n    */\n    function resetRollupBatchData(uint256 _rollupBatchIndex, uint256 _l2StoredBlockNumber, uint256 _l2ConfirmedBlockNumber) external onlySequencer {\n        for (uint256 i = _rollupBatchIndex; i < rollupBatchIndex; i++) {\n            delete rollupBatchIndexRollupStores[i];\n        }\n        rollupBatchIndex = _rollupBatchIndex;\n        l2StoredBlockNumber = _l2StoredBlockNumber;\n        l2ConfirmedBlockNumber = _l2ConfirmedBlockNumber;\n        emit ResetRollupBatchData(_rollupBatchIndex, _l2StoredBlockNumber, _l2ConfirmedBlockNumber);\n    }\n\n    /**\n    * @notice submit re-rollup batch index\n    * @param batchIndex need re-rollup batch index\n    */\n    function submitReRollUpInfo(\n        uint256 batchIndex\n    ) external {\n        require(msg.sender == reSubmitterAddress, \"submitReRollUpInfo: Only the re submitter can submit re rollup data\");\n        RollupStore memory rStore = rollupBatchIndexRollupStores[batchIndex];\n        if (rStore.dataStoreId > 0) {\n            reRollupBatchIndex[reRollupIndex] = batchIndex;\n            emit ReRollupBatchData(\n                reRollupIndex++,\n                batchIndex,\n                dataStoreIdToL2RollUpBlock[rStore.dataStoreId].startL2BlockNumber,\n                dataStoreIdToL2RollUpBlock[rStore.dataStoreId].endBL2BlockNumber\n            );\n        }\n    }\n\n    /**\n     * @notice Called by the (staked) sequencer to pay for a datastore and post some metadata (in the `header` parameter) about it on chain.\n     * Since the sequencer must encode the data before they post the header on chain, they must use a *snapshot* of the number and stakes of DataLayr operators\n     * from a previous block number, specified by the `blockNumber` input.\n     * @param header of data to be stored\n     * @param duration is the duration to store the datastore for\n     * @param blockNumber is the previous block number which was used to encode the data for storage\n     * @param totalOperatorsIndex is index in the totalOperators array of DataLayr referring to what the total number of operators was at `blockNumber`\n     * @dev The specified `blockNumber `must be less than `BLOCK_STALE_MEASURE` blocks in the past.\n     */\n    function storeData(\n        bytes calldata header,\n        uint8 duration,\n        uint32 blockNumber,\n        uint256 startL2Block,\n        uint256 endL2Block,\n        uint32 totalOperatorsIndex,\n        bool   isReRollup\n    ) external onlySequencer {\n        require(endL2Block > startL2Block, \"storeData: endL2Block must more than startL2Block\");\n        require(block.number - blockNumber < BLOCK_STALE_MEASURE, \"storeData: stakes taken from too long ago\");\n        uint32 dataStoreId = IDataLayrServiceManager(dataManageAddress).taskNumber();\n        IDataLayrServiceManager(dataManageAddress).initDataStore(\n            msg.sender,\n            address(this),\n            duration,\n            blockNumber,\n            totalOperatorsIndex,\n            header\n        );\n        dataStoreIdToL2RollUpBlock[dataStoreId] = BatchRollupBlock({\n            startL2BlockNumber: startL2Block,\n            endBL2BlockNumber: endL2Block,\n            isReRollup: isReRollup\n        });\n        dataStoreIdToRollupStoreNumber[dataStoreId] = DATA_STORE_INITIALIZED_BUT_NOT_CONFIRMED;\n        if (!isReRollup) {\n            l2StoredBlockNumber = endL2Block;\n        }\n        emit RollupStoreInitialized(dataStoreId, startL2Block, endL2Block);\n    }\n\n    /**\n     * @notice After the `storeData `transaction is included in a block and doesnt revert, the sequencer will disperse the data to the DataLayr nodes off chain\n     * and get their signatures that they have stored the data. Now, the sequencer has to post the signature on chain and get it verified.\n     * @param data Input of the header information for a dataStore and signatures for confirming the dataStore -- used as input to the `confirmDataStore` function\n     * of the DataLayrServiceManager -- see the DataLayr docs for more info on this.\n     * @param searchData Data used to specify the dataStore being confirmed. Must be provided so other contracts can properly look up the dataStore.\n     * @dev Only dataStores created through this contract can be confirmed by calling this function.\n     */\n    function confirmData(\n        bytes calldata data,\n        IDataLayrServiceManager.DataStoreSearchData memory searchData,\n        uint256 startL2Block,\n        uint256 endL2Block,\n        uint32 originDataStoreId,\n        uint256 reConfirmedBatchIndex,\n        bool isReRollup\n    ) external onlySequencer {\n        require(endL2Block > startL2Block, \"confirmData: endL2Block must more than startL2Block\");\n        BatchRollupBlock memory batchRollupBlock = dataStoreIdToL2RollUpBlock[searchData.metadata.globalDataStoreId];\n        require(batchRollupBlock.startL2BlockNumber == startL2Block &&\n            batchRollupBlock.endBL2BlockNumber == endL2Block &&\n            batchRollupBlock.isReRollup == isReRollup,\n            \"confirmData: Data store either was not initialized by the rollup contract, or is already confirmed\"\n        );\n        require(\n            dataStoreIdToRollupStoreNumber[searchData.metadata.globalDataStoreId] == DATA_STORE_INITIALIZED_BUT_NOT_CONFIRMED,\n            \"confirmData: Data store either was not initialized by the rollup contract, or is already confirmed\"\n        );\n        IDataLayrServiceManager(dataManageAddress).confirmDataStore(data, searchData);\n        if (!isReRollup) {\n            rollupBatchIndexRollupStores[rollupBatchIndex] = RollupStore({\n                originDataStoreId: searchData.metadata.globalDataStoreId,\n                dataStoreId: searchData.metadata.globalDataStoreId,\n                confirmAt: uint32(block.timestamp + fraudProofPeriod),\n                status: RollupStoreStatus.COMMITTED\n            });\n            l2ConfirmedBlockNumber = endL2Block;\n            dataStoreIdToRollupStoreNumber[searchData.metadata.globalDataStoreId] = rollupBatchIndex;\n            emit RollupStoreConfirmed(uint32(rollupBatchIndex++), searchData.metadata.globalDataStoreId, startL2Block, endL2Block);\n        } else {\n            rollupBatchIndexRollupStores[reConfirmedBatchIndex] = RollupStore({\n                originDataStoreId: originDataStoreId,\n                dataStoreId: searchData.metadata.globalDataStoreId,\n                confirmAt: uint32(block.timestamp + fraudProofPeriod),\n                status: RollupStoreStatus.COMMITTED\n            });\n            dataStoreIdToRollupStoreNumber[searchData.metadata.globalDataStoreId] = reConfirmedBatchIndex;\n            emit RollupStoreConfirmed(reConfirmedBatchIndex, searchData.metadata.globalDataStoreId, startL2Block, endL2Block);\n        }\n    }\n\n    /**\n  * @notice Called by a challenger (this could be anyone -- \"challenger\" is not a permissioned role) to prove that fraud has occurred.\n     * First, a subset of data included in a dataStore that was initiated by the sequencer is proven, and then the presence of fraud in the data is checked.\n     * For the sake of this example, \"fraud occurring\" means that the sequencer included the forbidden `FRAUD_STRING` in a dataStore that they initiated.\n     * In pratical use, \"fraud occurring\" might mean including data that specifies an invalid transaction or invalid state transition.\n     * @param fraudulentStoreNumber The rollup l2Block to prove fraud on\n     * @param startIndex The index to begin reading the proven data from\n     * @param searchData Data used to specify the dataStore being fraud-proven. Must be provided so other contracts can properly look up the dataStore.\n     * @param disclosureProofs Non-interactive polynomial proofs that prove that the specific data of interest was part of the dataStore in question.\n     * @dev This function is only callable if:\n     * -the sequencer is staked,\n     * -the dataStore in question has been confirmed, and\n     * -the fraudproof period for the dataStore has not yet passed.\n     */\n    function proveFraud(\n        uint256 fraudulentStoreNumber,\n        uint256 startIndex,\n        IDataLayrServiceManager.DataStoreSearchData memory searchData,\n        DisclosureProofs calldata disclosureProofs\n    ) external {\n        require(fraudProofWhitelist[msg.sender], \"proveFraud: Only fraud proof white list can challenge data\");\n        RollupStore memory rollupStore = rollupBatchIndexRollupStores[fraudulentStoreNumber];\n        require(rollupStore.status == RollupStoreStatus.COMMITTED && rollupStore.confirmAt > block.timestamp, \"RollupStore must be committed and unconfirmed\");\n        require(\n            IDataLayrServiceManager(dataManageAddress).getDataStoreHashesForDurationAtTimestamp(\n                searchData.duration,\n                searchData.timestamp,\n                searchData.index\n            ) == DataStoreUtils.computeDataStoreHash(searchData.metadata),\n            \"proveFraud: metadata preimage is incorrect\"\n        );\n        require(searchData.metadata.globalDataStoreId == rollupStore.dataStoreId, \"seachData's datastore id is not consistent with given rollup store\");\n        require(searchData.metadata.headerHash == keccak256(disclosureProofs.header), \"disclosure proofs headerhash preimage is incorrect\");\n        require(DataLayrDisclosureLogic.batchNonInteractivePolynomialProofs(\n            disclosureProofs.header,\n            disclosureProofs.firstChunkNumber,\n            disclosureProofs.polys,\n            disclosureProofs.multiRevealProofs,\n            disclosureProofs.polyEquivalenceProof\n        ), \"disclosure proofs are invalid\");\n        uint32 numSys = DataLayrDisclosureLogic.getNumSysFromHeader(disclosureProofs.header);\n        require(disclosureProofs.firstChunkNumber + disclosureProofs.polys.length <= numSys, \"Can only prove data from the systematic chunks\");\n        bytes memory provenString = parse(disclosureProofs.polys, startIndex, FRAUD_STRING.length);\n        require(provenString.length == FRAUD_STRING.length, \"Parsing error, proven string is different length than fraud string\");\n        require(keccak256(provenString) == keccak256(FRAUD_STRING), \"proven string != fraud string\");\n        rollupBatchIndexRollupStores[fraudulentStoreNumber].status = RollupStoreStatus.REVERTED;\n        emit RollupStoreReverted(\n            fraudulentStoreNumber,\n            searchData.metadata.globalDataStoreId,\n            dataStoreIdToL2RollUpBlock[searchData.metadata.globalDataStoreId].startL2BlockNumber,\n            dataStoreIdToL2RollUpBlock[searchData.metadata.globalDataStoreId].endBL2BlockNumber\n        );\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/libraries/eigenda/DataLayrDisclosureLogic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./Merkle.sol\";\nimport \"./BN254.sol\";\nimport \"./interfaces/IDataLayrServiceManager.sol\";\n\nlibrary DataLayrDisclosureLogic {\n    uint256 constant MODULUS =\n    21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    struct MultiRevealProof {\n        BN254.G1Point interpolationPoly;\n        BN254.G1Point revealProof;\n        BN254.G2Point zeroPoly;\n        bytes zeroPolyProof;\n    }\n\n    struct DataStoreKZGMetadata {\n        BN254.G1Point c;\n        uint48 degree;\n        uint32 numSys;\n        uint32 numPar;\n    }\n\n    function getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader(\n    // bytes calldata header\n        bytes calldata header\n    ) internal pure returns (DataStoreKZGMetadata memory) {\n        // return x, y coordinate of overall data poly commitment\n        // then return degree of multireveal polynomial\n        BN254.G1Point memory point;\n        uint48 degree;\n        uint32 numSys;\n        uint32 numPar;\n        uint256 pointer;\n\n        assembly {\n            pointer := header.offset\n            mstore(point, calldataload(pointer))\n            mstore(add(point, 0x20), calldataload(add(pointer, 32)))\n        //TODO: PUT THE LOW DEGREENESS PROOF HERE\n            degree := shr(224, calldataload(add(pointer, 64)))\n\n            numSys := shr(224, calldataload(add(pointer, 68)))\n            numPar := shr(224, calldataload(add(pointer, 72)))\n        }\n\n        return\n        DataStoreKZGMetadata({\n        c: point,\n        degree: degree,\n        numSys: numSys,\n        numPar: numPar\n        });\n    }\n\n    function getNumSysFromHeader(\n    // bytes calldata header\n        bytes calldata header\n    ) internal pure returns (uint32) {\n        uint32 numSys;\n\n        assembly {\n            numSys := shr(224, calldataload(add(header.offset, 68)))\n        }\n\n        return numSys;\n    }\n\n    function getLeadingCosetIndexFromHighestRootOfUnity(\n        uint32 i,\n        uint32 numSys,\n        uint32 numPar\n    ) internal pure returns (uint32) {\n        uint32 numNode = numSys + numPar;\n        uint32 numSysE = uint32(nextPowerOf2(numSys));\n        uint32 ratio = numNode / numSys + (numNode % numSys == 0 ? 0 : 1);\n        uint32 numNodeE = uint32(nextPowerOf2(numSysE * ratio));\n\n        if (i < numSys) {\n            return\n            (reverseBitsLimited(uint32(numNodeE), uint32(i)) * 256) /\n            numNodeE;\n        } else if (i < numNodeE - (numSysE - numSys)) {\n            return\n            (reverseBitsLimited(\n                uint32(numNodeE),\n                uint32((i - numSys) + numSysE)\n            ) * 256) / numNodeE;\n        } else {\n            revert(\"Cannot create number of frame higher than possible\");\n        }\n    }\n\n    function reverseBitsLimited(uint32 length, uint32 value)\n    internal\n    pure\n    returns (uint32)\n    {\n        uint32 unusedBitLen = 32 - uint32(log2(length));\n        return reverseBits(value) >> unusedBitLen;\n    }\n\n    function reverseBits(uint32 value) internal pure returns (uint32) {\n        uint256 reversed = 0;\n        for (uint i = 0; i < 32; i++) {\n            uint256 mask = 1 << i;\n            if (value & mask != 0) {\n                reversed |= (1 << (31 - i));\n            }\n        }\n        return uint32(reversed);\n    }\n\n    //takes the log base 2 of n and returns it\n    function log2(uint256 n) internal pure returns (uint256) {\n        require(n > 0, \"Log must be defined\");\n        uint256 log = 0;\n        while (n >> log != 1) {\n            log++;\n        }\n        return log;\n    }\n\n    //finds the next power of 2 greater than n and returns it\n    function nextPowerOf2(uint256 n) internal pure returns (uint256) {\n        uint256 res = 1;\n        while (1 << res < n) {\n            res++;\n        }\n        res = 1 << res;\n        return res;\n    }\n\n    // gets the merkle root of a tree where all the leaves are the hashes of the zero/vanishing polynomials of the given multireveal\n    // degree at different roots of unity. We are assuming a max of 512 datalayr nodes  right now, so, for merkle root for \"degree\"\n    // will be of the tree where the leaves are the hashes of the G2 kzg commitments to the following polynomials:\n    // l = degree (for brevity)\n    // w^(512*l) = 1\n    // (s^l - 1), (s^l - w^l), (s^l - w^2l), (s^l - w^3l), (s^l - w^4l), ...\n    // we have precomputed these values and return them directly because it's cheap. currently we\n    // tolerate up to degree 2^10, which means up to (31 bytes/point)(1024 points/dln)(256 dln) = 8 MB in a datastore\n    function getZeroPolyMerkleRoot(uint256 degree)\n    internal\n    pure\n    returns (bytes32)\n    {\n        uint256 log = log2(degree);\n\n        if (log == 0) {\n            return\n            0xe82cea94884b1b895ea0742840a3b19249a723810fd1b04d8564d675b0a416f1;\n        } else if (log == 1) {\n            return\n            0x4843774a80fc8385b31024f5bd18b42e62de439206ab9468d42d826796d41f67;\n        } else if (log == 2) {\n            return\n            0x092d3e5f87f5293e7ab0cc2ca6b0b5e4adb5e0011656544915f7cea34e69e5ab;\n        } else if (log == 3) {\n            return\n            0x494b208540ec8624fbbb3f2c64ffccdaf6253f8f4e50c0d93922d88195b07755;\n        } else if (log == 4) {\n            return\n            0xfdb44b84a82893cfa0e37a97f09ffc4298ad5e62be1bea1d03320ae836213d22;\n        } else if (log == 5) {\n            return\n            0x3f50cb08231d2a76853ba9dbb20dad45a1b75c57cdaff6223bfe069752cff3d4;\n        } else if (log == 6) {\n            return\n            0xbb39eebd8138eefd5802a49d571e65b3e0d4e32277c28fbf5fbca66e7fb04310;\n        } else if (log == 7) {\n            return\n            0xf0a39b513e11fa80cbecbf352f69310eddd5cd03148768e0e9542bd600b133ec;\n        } else if (log == 8) {\n            return\n            0x038cca2238865414efb752cc004fffec9e6069b709f495249cdf36efbd5952f6;\n        } else if (log == 9) {\n            return\n            0x2a26b054ed559dd255d8ac9060ebf6b95b768d87de767f8174ad2f9a4e48dd01;\n        } else if (log == 10) {\n            return\n            0x1fe180d0bc4ff7c69fefa595b3b5f3c284535a280f6fdcf69b20770d1e20e1fc;\n        } else if (log == 11) {\n            return\n            0x60e34ad57c61cd6fdd8177437c30e4a30334e63d7683989570cf27020efc8201;\n        } else if (log == 12) {\n            return\n            0xeda2417e770ddbe88f083acf06b6794dfb76301314a32bd0697440d76f6cd9cc;\n        } else if (log == 13) {\n            return\n            0x8cbe9b8cf92ce70e3bec8e1e72a0f85569017a7e43c3db50e4a5badb8dea7ce8;\n        } else {\n            revert(\"Log not in valid range\");\n        }\n    }\n\n    // opens up kzg commitment c(x) at r and makes sure c(r) = s. proof (pi) is in G2 to allow for calculation of Z in G1\n    function openPolynomialAtPoint(\n        BN254.G1Point memory c,\n        BN254.G2Point calldata pi,\n        uint256 r,\n        uint256 s\n    ) internal view returns (bool) {\n        //we use and overwrite z as temporary storage\n        //g1 = (1, 2)\n        BN254.G1Point memory g1Gen = BN254.G1Point({X: 1, Y: 2});\n        //calculate -g1*r = -[r]_1\n        BN254.G1Point memory z = BN254.scalar_mul(BN254.negate(g1Gen), r);\n\n        //add [x]_1 - [r]_1 = Z and store in first 2 slots of input\n        //CRITIC TODO: SWITCH THESE TO [x]_1 of Powers of Tau!\n        BN254.G1Point memory firstPowerOfTau = BN254.G1Point({\n        X: 15397661830938158195220872607788450164522003659458108417904919983213308643927,\n        Y: 4051901473739185471504766068400292374549287637553596337727654132125147894034\n        });\n        z = BN254.plus(firstPowerOfTau, z);\n        //calculate -g1*s = -[s]_1\n        BN254.G1Point memory negativeS = BN254.scalar_mul(\n            BN254.negate(g1Gen),\n            s\n        );\n        //calculate C-[s]_1\n        BN254.G1Point memory cMinusS = BN254.plus(c, negativeS);\n\n        //check e(z, pi)e(C-[s]_1, -g2) = 1\n        return BN254.pairing(z, pi, cMinusS, BN254.negGeneratorG2());\n    }\n\n    function validateDisclosureResponse(\n        DataStoreKZGMetadata memory dskzgMetadata,\n        uint32 chunkNumber,\n        BN254.G1Point calldata interpolationPoly,\n        BN254.G1Point calldata revealProof,\n        BN254.G2Point memory zeroPoly,\n        bytes calldata zeroPolyProof\n    ) internal view returns (bool) {\n        // check that [zeroPoly.x0, zeroPoly.x1, zeroPoly.y0, zeroPoly.y1] is actually the \"chunkNumber\" leaf\n        // of the zero polynomial Merkle tree\n\n        {\n            //deterministic assignment of \"y\" here\n            // @todo\n            require(\n                Merkle.verifyInclusionKeccak(\n                // Merkle proof\n                    zeroPolyProof,\n                // Merkle root hash\n                    getZeroPolyMerkleRoot(dskzgMetadata.degree),\n                // leaf\n                    keccak256(\n                        abi.encodePacked(\n                            zeroPoly.X[1],\n                            zeroPoly.X[0],\n                            zeroPoly.Y[1],\n                            zeroPoly.Y[0]\n                        )\n                    ),\n                // index in the Merkle tree\n                    getLeadingCosetIndexFromHighestRootOfUnity(\n                        chunkNumber,\n                        dskzgMetadata.numSys,\n                        dskzgMetadata.numPar\n                    )\n                ),\n                \"Incorrect zero poly merkle proof\"\n            );\n        }\n\n        /**\n         Doing pairing verification  e(Pi(s), Z_k(s)).e(C - I, -g2) == 1\n         */\n        //get the commitment to the zero polynomial of multireveal degree\n\n        // calculate [C]_1 - [I]_1\n        BN254.G1Point memory cMinusI = BN254.plus(\n            dskzgMetadata.c,\n            BN254.negate(interpolationPoly)\n        );\n\n        //check e(z, pi)e(C-[s]_1, -g2) = 1\n        return BN254.pairing(revealProof, zeroPoly, cMinusI, BN254.negGeneratorG2());\n    }\n\n    function nonInteractivePolynomialProof(\n        bytes calldata header,\n        uint32 chunkNumber,\n        bytes calldata poly,\n        MultiRevealProof calldata multiRevealProof,\n        BN254.G2Point calldata polyEquivalenceProof\n    ) internal view returns (bool) {\n        DataStoreKZGMetadata\n        memory dskzgMetadata = getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader(\n            header\n        );\n\n        //verify pairing for the commitment to interpolating polynomial\n        require(\n            validateDisclosureResponse(\n                dskzgMetadata,\n                chunkNumber,\n                multiRevealProof.interpolationPoly,\n                multiRevealProof.revealProof,\n                multiRevealProof.zeroPoly,\n                multiRevealProof.zeroPolyProof\n            ),\n            \"Reveal failed due to non 1 pairing\"\n        );\n\n        // TODO: verify that this check is correct!\n        // check that degree of polynomial in the header matches the length of the submitted polynomial\n        // i.e. make sure submitted polynomial doesn't contain extra points\n        require(\n            (dskzgMetadata.degree + 1) * 32 == poly.length,\n            \"Polynomial must have a 256 bit coefficient for each term\"\n        );\n\n        //Calculating r, the point at which to evaluate the interpolating polynomial\n        uint256 r = uint256(\n            keccak256(\n                abi.encodePacked(\n                    keccak256(poly),\n                    multiRevealProof.interpolationPoly.X,\n                    multiRevealProof.interpolationPoly.Y\n                )\n            )\n        ) % MODULUS;\n        uint256 s = linearPolynomialEvaluation(poly, r);\n        return\n        openPolynomialAtPoint(\n            multiRevealProof.interpolationPoly,\n            polyEquivalenceProof,\n            r,\n            s\n        );\n    }\n\n    function verifyPolyEquivalenceProof(\n        bytes calldata poly,\n        BN254.G1Point calldata interpolationPoly,\n        BN254.G2Point calldata polyEquivalenceProof\n    ) internal view returns (bool) {\n        //Calculating r, the point at which to evaluate the interpolating polynomial\n        uint256 r = uint256(\n            keccak256(\n                abi.encodePacked(\n                    keccak256(poly),\n                    interpolationPoly.X,\n                    interpolationPoly.Y\n                )\n            )\n        ) % MODULUS;\n        uint256 s = linearPolynomialEvaluation(poly, r);\n        bool ok = openPolynomialAtPoint(\n            interpolationPoly,\n            polyEquivalenceProof,\n            r,\n            s\n        );\n        return ok;\n    }\n\n    function verifyBatchPolyEquivalenceProof(\n        bytes[] calldata polys,\n        BN254.G1Point[] calldata interpolationPolys,\n        BN254.G2Point calldata polyEquivalenceProof\n    ) internal view returns (bool) {\n        bytes32[] memory rs = new bytes32[](polys.length);\n        //Calculating r, the point at which to evaluate the interpolating polynomial\n        for (uint i = 0; i < polys.length; i++) {\n            rs[i] = keccak256(\n                abi.encodePacked(\n                    keccak256(polys[i]),\n                    interpolationPolys[i].X,\n                    interpolationPolys[i].Y\n                )\n            );\n        }\n        //this is the point to open each polynomial at\n        uint256 r = uint256(keccak256(abi.encodePacked(rs))) % MODULUS;\n        //this is the offset we add to each polynomial to prevent collision\n        //we use array to help with stack\n        uint256[2] memory gammaAndGammaPower;\n        gammaAndGammaPower[0] =\n        uint256(keccak256(abi.encodePacked(rs, uint256(0)))) %\n        MODULUS;\n        gammaAndGammaPower[1] = gammaAndGammaPower[0];\n        //store I1\n        BN254.G1Point memory gammaShiftedCommitmentSum = interpolationPolys[0];\n        //store I1(r)\n        uint256 gammaShiftedEvaluationSum = linearPolynomialEvaluation(\n            polys[0],\n            r\n        );\n        for (uint i = 1; i < interpolationPolys.length; i++) {\n            //gammaShiftedCommitmentSum += gamma^i * Ii\n            gammaShiftedCommitmentSum = BN254.plus(\n                gammaShiftedCommitmentSum,\n                BN254.scalar_mul(interpolationPolys[i], gammaAndGammaPower[1])\n            );\n            //gammaShiftedEvaluationSum += gamma^i * Ii(r)\n            uint256 eval = linearPolynomialEvaluation(polys[i], r);\n            gammaShiftedEvaluationSum = addmod(\n                gammaShiftedEvaluationSum,\n                mulmod(gammaAndGammaPower[1], eval, MODULUS),\n                MODULUS\n            );\n            // gammaPower = gamma^(i+1)\n            gammaAndGammaPower[1] = mulmod(\n                gammaAndGammaPower[0],\n                gammaAndGammaPower[1],\n                MODULUS\n            );\n        }\n\n        return\n        openPolynomialAtPoint(\n            gammaShiftedCommitmentSum,\n            polyEquivalenceProof,\n            r,\n            gammaShiftedEvaluationSum\n        );\n    }\n\n    function batchNonInteractivePolynomialProofs(\n        bytes calldata header,\n        uint32 firstChunkNumber,\n        bytes[] calldata polys,\n        MultiRevealProof[] calldata multiRevealProofs,\n        BN254.G2Point calldata polyEquivalenceProof\n    ) internal view returns (bool) {\n        //randomness from each polynomial\n        bytes32[] memory rs = new bytes32[](polys.length);\n        DataStoreKZGMetadata\n        memory dskzgMetadata = getDataCommitmentAndMultirevealDegreeAndSymbolBreakdownFromHeader(\n            header\n        );\n        uint256 numProofs = multiRevealProofs.length;\n        for (uint256 i = 0; i < numProofs; ) {\n            //verify pairing for the commitment to interpolating polynomial\n            require(\n                validateDisclosureResponse(\n                    dskzgMetadata,\n                    firstChunkNumber + uint32(i),\n                    multiRevealProofs[i].interpolationPoly,\n                    multiRevealProofs[i].revealProof,\n                    multiRevealProofs[i].zeroPoly,\n                    multiRevealProofs[i].zeroPolyProof\n                ),\n                \"Reveal failed due to non 1 pairing\"\n            );\n\n            // TODO: verify that this check is correct!\n            // check that degree of polynomial in the header matches the length of the submitted polynomial\n            // i.e. make sure submitted polynomial doesn't contain extra points\n            require(\n                dskzgMetadata.degree * 32 == polys[i].length,\n                \"Polynomial must have a 256 bit coefficient for each term\"\n            );\n\n            //Calculating r, the point at which to evaluate the interpolating polynomial\n            rs[i] = keccak256(\n                abi.encodePacked(\n                    keccak256(polys[i]),\n                    multiRevealProofs[i].interpolationPoly.X,\n                    multiRevealProofs[i].interpolationPoly.Y\n                )\n            );\n        unchecked {\n            ++i;\n        }\n        }\n        //this is the point to open each polynomial at\n        uint256 r = uint256(keccak256(abi.encodePacked(rs))) % MODULUS;\n        //this is the offset we add to each polynomial to prevent collision\n        //we use array to help with stack\n        uint256[2] memory gammaAndGammaPower;\n        gammaAndGammaPower[0] =\n        uint256(keccak256(abi.encodePacked(rs, uint256(0)))) %\n        MODULUS;\n        gammaAndGammaPower[1] = gammaAndGammaPower[0];\n        //store I1\n        BN254.G1Point memory gammaShiftedCommitmentSum = multiRevealProofs[0]\n        .interpolationPoly;\n        //store I1(r)\n        uint256 gammaShiftedEvaluationSum = linearPolynomialEvaluation(\n            polys[0],\n            r\n        );\n        for (uint i = 1; i < multiRevealProofs.length; i++) {\n            //gammaShiftedCommitmentSum += gamma^i * Ii\n            gammaShiftedCommitmentSum = BN254.plus(\n                gammaShiftedCommitmentSum,\n                BN254.scalar_mul(\n                    multiRevealProofs[i].interpolationPoly,\n                    gammaAndGammaPower[1]\n                )\n            );\n            //gammaShiftedEvaluationSum += gamma^i * Ii(r)\n            uint256 eval = linearPolynomialEvaluation(polys[i], r);\n            gammaShiftedEvaluationSum = gammaShiftedEvaluationSum = addmod(\n                gammaShiftedEvaluationSum,\n                mulmod(gammaAndGammaPower[1], eval, MODULUS),\n                MODULUS\n            );\n            // gammaPower = gamma^(i+1)\n            gammaAndGammaPower[1] = mulmod(\n                gammaAndGammaPower[0],\n                gammaAndGammaPower[1],\n                MODULUS\n            );\n        }\n\n        return\n        openPolynomialAtPoint(\n            gammaShiftedCommitmentSum,\n            polyEquivalenceProof,\n            r,\n            gammaShiftedEvaluationSum\n        );\n    }\n\n    //evaluates the given polynomial \"poly\" at value \"r\" and returns the result\n    function linearPolynomialEvaluation(bytes calldata poly, uint256 r)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 sum;\n        uint256 length = poly.length;\n        uint256 rPower = 1;\n        for (uint i = 0; i < length; ) {\n            uint256 coefficient = uint256(bytes32(poly[i:i + 32]));\n            sum = addmod(sum, mulmod(coefficient, rPower, MODULUS), MODULUS);\n            rPower = mulmod(rPower, r, MODULUS);\n            i += 32;\n        }\n        return sum;\n    }\n}\n"
    },
    "contracts/libraries/eigenda/BN254.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED AND MIT\n// several functions are taken or adapted from https://github.com/HarryR/solcrypto/blob/master/contracts/altbn128.sol (MIT license):\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// The remainder of the code is written by LayrLabs Inc. and UNLICENSED\n\npragma solidity ^0.8.9;\n\n/**\n * @title Library for operations on the BN254 elliptic curve.\n * @author Layr Labs, Inc.\n * @notice Contains BN254 parameters, common operations (addition, scalar mul, pairing), and BLS signature functionality.\n */\nlibrary BN254 {\n    // modulus for the underlying field F_p of the elliptic curve\n    uint256 internal constant FP_MODULUS =\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\n    // modulus for the underlying field F_r of the elliptic curve\n    uint256 internal constant FR_MODULUS =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // primitive root of unity\n    uint256 internal constant OMEGA = 10359452186428527605436343203440067497552205259388878191021578220384701716497;\n\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[1] * i + X[0]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    // generator of group G2\n    /// @dev Generator point in F_q2 is of the form: (x0 + ix1, y0 + iy1).\n    uint256 internal constant G2x1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 internal constant G2x0 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 internal constant G2y1 =\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 internal constant G2y0 =\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    /// @notice returns the G2 generator\n    /// @dev mind the ordering of the 1s and 0s!\n    ///      this is because of the (unknown to us) convention used in the bn254 pairing precompile contract\n    ///      \"Elements a * i + b of F_p^2 are encoded as two elements of F_p, (a, b).\"\n    ///      https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md#encoding\n    function generatorG2() internal pure returns (G2Point memory) {\n        return G2Point(\n            [G2x1, G2x0], [G2y1, G2y0]\n        );\n    }\n\n    // negation of the generator of group G2\n    /// @dev Generator point in F_q2 is of the form: (x0 + ix1, y0 + iy1).\n    uint256 internal constant nG2x1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 internal constant nG2x0 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 internal constant nG2y1 =\n        17805874995975841540914202342111839520379459829704422454583296818431106115052;\n    uint256 internal constant nG2y0 =\n        13392588948715843804641432497768002650278120570034223513918757245338268106653;\n    function negGeneratorG2() internal pure returns (G2Point memory) {\n        return G2Point(\n            [nG2x1, nG2x0], [nG2y1, nG2y0]\n        );\n    }\n\n    // first power of srs in G2\n    // TODO: change in production\n    uint256 internal constant G2SRSx1 = 7912312892787135728292535536655271843828059318189722219035249994421084560563;\n    uint256 internal constant G2SRSx0 = 21039730876973405969844107393779063362038454413254731404052240341412356318284;\n    uint256 internal constant G2SRSy1 = 18697407556011630376420900106252341752488547575648825575049647403852275261247;\n    uint256 internal constant G2SRSy0 = 7586489485579523767759120334904353546627445333297951253230866312564920951171;\n    function G2SRSFirstPower() internal pure returns (G2Point memory) {\n        return G2Point(\n            [G2SRSx0, G2SRSx1], [G2SRSy0, G2SRSy1]\n        );\n    }\n\n    bytes32 internal constant powersOfTauMerkleRoot =\n        0x22c998e49752bbb1918ba87d6d59dd0e83620a311ba91dd4b2cc84990b31b56f;\n\n\n    /**\n     * @param p Some point in G1.\n     * @return The negation of `p`, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, FP_MODULUS - (p.Y % FP_MODULUS));\n        }\n    }\n\n    /**\n     * @return r the sum of two points of G1\n     */\n    function plus(\n        G1Point memory p1,\n        G1Point memory p2\n    ) internal view returns (G1Point memory r) {\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0x80, r, 0x40)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"ec-add-failed\");\n    }\n\n    /**\n     * @return r the product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(\n        G1Point memory p,\n        uint256 s\n    ) internal view returns (G1Point memory r) {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x60, r, 0x40)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"ec-mul-failed\");\n    }\n\n    /**\n     *  @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2\n    ) internal view returns (bool) {\n        G1Point[2] memory p1 = [a1, b1];\n        G2Point[2] memory p2 = [a2, b2];\n\n        uint256[12] memory input;\n\n        for (uint256 i = 0; i < 2; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(\n                sub(gas(), 2000),\n                8,\n                input,\n                mul(12, 0x20),\n                out,\n                0x20\n            )\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n\n    /**\n     * @notice This function is functionally the same as pairing(), however it specifies a gas limit\n     *         the user can set, as a precompile may use the entire gas budget if it reverts.\n     */\n    function safePairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        uint256 pairingGas\n    ) internal view returns (bool, bool) {\n        G1Point[2] memory p1 = [a1, b1];\n        G2Point[2] memory p2 = [a2, b2];\n\n        uint256[12] memory input;\n\n        for (uint256 i = 0; i < 2; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(\n                pairingGas,\n                8,\n                input,\n                mul(12, 0x20),\n                out,\n                0x20\n            )\n        }\n\n        //Out is the output of the pairing precompile, either 0 or 1 based on whether the two pairings are equal.\n        //Success is true if the precompile actually goes through (aka all inputs are valid)\n\n        return (success, out[0] != 0);\n    }\n\n    /// @return the keccak256 hash of the G1 Point\n    /// @dev used for BLS signatures\n    function hashG1Point(\n        BN254.G1Point memory pk\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(pk.X, pk.Y));\n    }\n\n\n    /**\n     * @notice adapted from https://github.com/HarryR/solcrypto/blob/master/contracts/altbn128.sol\n     */\n    function hashToG1(bytes32 _x) internal view returns (uint256, uint256) {\n        uint256 beta = 0;\n        uint256 y = 0;\n\n        // XXX: Gen Order (n) or Field Order (p) ?\n        uint256 x = uint256(_x) % FP_MODULUS;\n\n        while( true ) {\n            (beta, y) = findYFromX(x);\n\n            // y^2 == beta\n            if( beta == mulmod(y, y, FP_MODULUS) ) {\n                return (x, y);\n            }\n\n            x = addmod(x, 1, FP_MODULUS);\n        }\n        return (0, 0);\n    }\n\n    /**\n    * Given X, find Y\n    *\n    *   where y = sqrt(x^3 + b)\n    *\n    * Returns: (x^3 + b), y\n    */\n    function findYFromX(uint256 x)\n        internal view returns(uint256, uint256)\n    {\n        // beta = (x^3 + b) % p\n        uint256 beta = addmod(mulmod(mulmod(x, x, FP_MODULUS), x, FP_MODULUS), 3, FP_MODULUS);\n\n        // y^2 = x^3 + b\n        // this acts like: y = sqrt(beta) = beta^((p+1) / 4)\n        uint256 y = expMod(beta, 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52, FP_MODULUS);\n\n        return (beta, y);\n    }\n\n    function expMod(uint256 _base, uint256 _exponent, uint256 _modulus) internal view returns (uint256 retval) {\n        bool success;\n        uint256[1] memory output;\n        uint[6] memory input;\n        input[0] = 0x20;        // baseLen = new(big.Int).SetBytes(getData(input, 0, 32))\n        input[1] = 0x20;        // expLen  = new(big.Int).SetBytes(getData(input, 32, 32))\n        input[2] = 0x20;        // modLen  = new(big.Int).SetBytes(getData(input, 64, 32))\n        input[3] = _base;\n        input[4] = _exponent;\n        input[5] = _modulus;\n        assembly {\n            success := staticcall(sub(gas(), 2000), 5, input, 0xc0, output, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n        require(success);\n        return output[0];\n    }\n}\n"
    },
    "contracts/libraries/eigenda/Parse.sol": {
      "content": "pragma solidity ^0.8.9;\n\ncontract Parser {\n    /**\n     * @notice Parses data from non-interactive polynomial proofs.\n     * @param polys The non-interactive polynomial proofs themselves\n     * @param startIndex The byte index from which to begin reading data.\n     * @param length The length of data to parse, in bytes.\n     * @return provenString The parsed data.\n     */\n    function parse(bytes[] calldata polys, uint256 startIndex, uint256 length) public pure returns(bytes memory provenString) {\n        // each symbol encodes 31 bytes, and is padded to 32 bytes -- this verifies that we are beginning to parse the data from a non-padded byte\n        require(startIndex % 32 != 0, \"Cannot start reading from a padded byte\");\n        // index of the `polys` array from which we are currently reading\n        uint256 polyIndex = 0;\n        // keeps track of the index to read inside of the current polynomial\n        uint256 index = startIndex;\n        // continue reading until we reach the desired length\n        while(provenString.length < length) {\n            /**\n             * Read:\n             * 1) until the beginning of the next 32 byte segment OR\n             * 2) however many more bytes there are left in the fraud string\n             * -- whichever amount is the *smallest*\n             */\n            uint256 bytesToRead = min(\n            // the amount of bytes until the end of the current 32 byte segment\n                (32 * ((index / 32) + 1)) - index,\n            // the remaining total bytes to parse\n                length - provenString.length\n            );\n            /**\n             * Append the read bytes to the end of the proven string.\n             * Note that indexing of bytes is inclusive of the first index and exclusive of the second, meaning\n             * that, for example, polys[0][x:x+1] specifies the *single byte* at position x of `polys[0]`, and\n             * polys[0][x:x] will specify an empty byte string.\n             */\n            provenString = abi.encodePacked(provenString, polys[polyIndex][index:index+bytesToRead]);\n            // if we finished reading the current polynomial, then we move onto the next one\n            if (index + bytesToRead == polys[polyIndex].length) {\n                polyIndex++;\n                // skip the first byte of the polynomial since this is zero padding\n                index = 1;\n                // we have read `index + bytesToRead` bytes, and add 1 more to skip the zero-padding byte at the beginning of every 32 bytes\n            } else {\n                index += bytesToRead + 1;\n            }\n        }\n        return provenString;\n    }\n\n    /// @notice Calculates the minimum of 2 numbers\n    function min(uint256 a, uint256 b) internal pure returns(uint256) {\n        return (a < b) ? a : b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/libraries/eigenda/Merkle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function verifyInclusionKeccak(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bool) {\n        return processInclusionProofKeccak(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function processInclusionProofSha256(bytes memory proof, bytes32 leaf, uint256 index) internal view returns (bytes32) {\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash[0];\n    }\n\n    /**\n     @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\n     @param leaves the leaves of the merkle tree\n\n     @notice requires the leaves.length is a power of 2\n     */ \n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n}"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20PermitUpgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../governance/utils/IVotesUpgradeable.sol\";\nimport \"../../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, IVotesUpgradeable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotesUpgradeable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/L1/messaging/L1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { AddressAliasHelper } from \"../../standards/AddressAliasHelper.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_BVMCodec } from \"../../libraries/codec/Lib_BVMCodec.sol\";\nimport { Lib_AddressManager } from \"../../libraries/resolver/Lib_AddressManager.sol\";\nimport { Lib_SecureMerkleTrie } from \"../../libraries/trie/Lib_SecureMerkleTrie.sol\";\nimport { Lib_DefaultValues } from \"../../libraries/constants/Lib_DefaultValues.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\nimport { Lib_CrossDomainUtils } from \"../../libraries/bridge/Lib_CrossDomainUtils.sol\";\n\n/* Interface Imports */\nimport { IL1CrossDomainMessenger } from \"./IL1CrossDomainMessenger.sol\";\nimport { ICanonicalTransactionChain } from \"../rollup/ICanonicalTransactionChain.sol\";\nimport { IStateCommitmentChain } from \"../rollup/IStateCommitmentChain.sol\";\n\n/* External Imports */\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    PausableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/**\n * @title L1CrossDomainMessenger\n * @dev The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages\n * from L2 onto L1. In the event that a message sent from L1 to L2 is rejected for exceeding the L2\n * epoch gas limit, it can be resubmitted via this contract's replay function.\n *\n */\ncontract L1CrossDomainMessenger is\n    IL1CrossDomainMessenger,\n    Lib_AddressResolver,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /**********\n     * Events *\n     **********/\n\n    event MessageBlocked(bytes32 indexed _xDomainCalldataHash);\n\n    event MessageAllowed(bytes32 indexed _xDomainCalldataHash);\n\n    /**********************\n     * Contract Variables *\n     **********************/\n\n    mapping(bytes32 => bool) public blockedMessages;\n    mapping(bytes32 => bool) public relayedMessages;\n    mapping(bytes32 => bool) public successfulMessages;\n\n    address internal xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n    address internal pauseOwner ;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * This contract is intended to be behind a delegate proxy.\n     * We pass the zero address to the address resolver just to satisfy the constructor.\n     * We still need to set this value in initialize().\n     */\n    constructor() Lib_AddressResolver(address(0)) {}\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    // slither-disable-next-line external-function\n    function initialize(address _libAddressManager) public initializer {\n        require(\n            address(libAddressManager) == address(0),\n            \"L1CrossDomainMessenger already intialized.\"\n        );\n        libAddressManager = Lib_AddressManager(_libAddressManager);\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n        // Initialize upgradable OZ contracts\n        __Context_init_unchained(); // Context is a dependency for both Ownable and Pausable\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n    }\n\n    /**\n     * Pause relaying.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * UnPause relaying.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setPauseOwner(address _pauseOwner) external onlyOwner {\n        pauseOwner = _pauseOwner;\n    }\n\n    function getPauseOwner() public view returns (address) {\n        return pauseOwner;\n    }\n\n    function pauseByPOwner() external {\n        require(\n            pauseOwner == msg.sender,\n            \"msg.sender shoule be pauseowner.\"\n        );\n        _pause();\n    }\n\n    /**\n     * Block a message.\n     * @param _xDomainCalldataHash Hash of the message to block.\n     */\n    function blockMessage(bytes32 _xDomainCalldataHash) external onlyOwner {\n        blockedMessages[_xDomainCalldataHash] = true;\n        emit MessageBlocked(_xDomainCalldataHash);\n    }\n\n    /**\n     * Allow a message.\n     * @param _xDomainCalldataHash Hash of the message to block.\n     */\n    function allowMessage(bytes32 _xDomainCalldataHash) external onlyOwner {\n        blockedMessages[_xDomainCalldataHash] = false;\n        emit MessageAllowed(_xDomainCalldataHash);\n    }\n\n    // slither-disable-next-line external-function\n    function xDomainMessageSender() public view returns (address) {\n        require(\n            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,\n            \"xDomainMessageSender is not set\"\n        );\n        return xDomainMsgSender;\n    }\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    // slither-disable-next-line external-function\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) public {\n        address bvmCanonicalTransactionChain = resolve(\"CanonicalTransactionChain\");\n        // Use the CTC queue length as nonce\n        uint40 nonce = ICanonicalTransactionChain(bvmCanonicalTransactionChain).getQueueLength();\n\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            msg.sender,\n            _message,\n            nonce\n        );\n\n        // slither-disable-next-line reentrancy-events\n        _sendXDomainMessage(bvmCanonicalTransactionChain, xDomainCalldata, _gasLimit);\n\n        // slither-disable-next-line reentrancy-events\n        emit SentMessage(_target, msg.sender, _message, nonce, _gasLimit);\n    }\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @inheritdoc IL1CrossDomainMessenger\n     */\n    // slither-disable-next-line external-function\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce,\n        L2MessageInclusionProof memory _proof\n    ) public nonReentrant whenNotPaused {\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\n        require(\n            _verifyXDomainMessage(xDomainCalldata, _proof) == true,\n            \"Provided message could not be verified.\"\n        );\n\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\n        require(\n            successfulMessages[xDomainCalldataHash] == false,\n            \"Provided message has already been received.\"\n        );\n\n        require(\n            blockedMessages[xDomainCalldataHash] == false,\n            \"Provided message has been blocked.\"\n        );\n\n        require(\n            _target != resolve(\"CanonicalTransactionChain\"),\n            \"Cannot send L2->L1 messages to L1 system contracts.\"\n        );\n\n        xDomainMsgSender = _sender;\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events, reentrancy-benign\n        (bool success, ) = _target.call(_message);\n        // slither-disable-next-line reentrancy-benign\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n        // Mark the message as received if the call was successful. Ensures that a message can be\n        // relayed multiple times in the case that the call reverted.\n        if (success == true) {\n            // slither-disable-next-line reentrancy-no-eth\n            successfulMessages[xDomainCalldataHash] = true;\n            // slither-disable-next-line reentrancy-events\n            emit RelayedMessage(xDomainCalldataHash);\n        } else {\n            // slither-disable-next-line reentrancy-events\n            emit FailedRelayedMessage(xDomainCalldataHash);\n        }\n\n        // Store an identifier that can be used to prove that the given message was relayed by some\n        // user. Gives us an easy way to pay relayers for their work.\n        bytes32 relayId = keccak256(abi.encodePacked(xDomainCalldata, msg.sender, block.number));\n        // slither-disable-next-line reentrancy-benign\n        relayedMessages[relayId] = true;\n    }\n\n    /**\n     * Replays a cross domain message to the target messenger.\n     * @inheritdoc IL1CrossDomainMessenger\n     */\n    // slither-disable-next-line external-function\n    function replayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _queueIndex,\n        uint32 _oldGasLimit,\n        uint32 _newGasLimit\n    ) public {\n        // Verify that the message is in the queue:\n        address canonicalTransactionChain = resolve(\"CanonicalTransactionChain\");\n        Lib_BVMCodec.QueueElement memory element = ICanonicalTransactionChain(\n            canonicalTransactionChain\n        ).getQueueElement(_queueIndex);\n\n        // Compute the calldata that was originally used to send the message.\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _queueIndex\n        );\n\n        // Compute the transactionHash\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                AddressAliasHelper.applyL1ToL2Alias(address(this)),\n                Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\n                _oldGasLimit,\n                xDomainCalldata\n            )\n        );\n\n        // Now check that the provided message data matches the one in the queue element.\n        require(\n            transactionHash == element.transactionHash,\n            \"Provided message has not been enqueued.\"\n        );\n\n        // Send the same message but with the new gas limit.\n        _sendXDomainMessage(canonicalTransactionChain, xDomainCalldata, _newGasLimit);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Verifies that the given message is valid.\n     * @param _xDomainCalldata Calldata to verify.\n     * @param _proof Inclusion proof for the message.\n     * @return Whether or not the provided message is valid.\n     */\n    function _verifyXDomainMessage(\n        bytes memory _xDomainCalldata,\n        L2MessageInclusionProof memory _proof\n    ) internal view returns (bool) {\n        return (_verifyStateRootProof(_proof) && _verifyStorageProof(_xDomainCalldata, _proof));\n    }\n\n    /**\n     * Verifies that the state root within an inclusion proof is valid.\n     * @param _proof Message inclusion proof.\n     * @return Whether or not the provided proof is valid.\n     */\n    function _verifyStateRootProof(L2MessageInclusionProof memory _proof)\n        internal\n        view\n        returns (bool)\n    {\n        IStateCommitmentChain bvmStateCommitmentChain = IStateCommitmentChain(\n            resolve(\"StateCommitmentChain\")\n        );\n\n        return (bvmStateCommitmentChain.insideFraudProofWindow(_proof.stateRootBatchHeader) ==\n            false &&\n            bvmStateCommitmentChain.verifyStateCommitment(\n                _proof.stateRoot,\n                _proof.stateRootBatchHeader,\n                _proof.stateRootProof\n            ));\n    }\n\n    /**\n     * Verifies that the storage proof within an inclusion proof is valid.\n     * @param _xDomainCalldata Encoded message calldata.\n     * @param _proof Message inclusion proof.\n     * @return Whether or not the provided proof is valid.\n     */\n    function _verifyStorageProof(\n        bytes memory _xDomainCalldata,\n        L2MessageInclusionProof memory _proof\n    ) internal view returns (bool) {\n        bytes32 storageKey = keccak256(\n            abi.encodePacked(\n                keccak256(\n                    abi.encodePacked(\n                        _xDomainCalldata,\n                        Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER\n                    )\n                ),\n                uint256(0)\n            )\n        );\n\n        (bool exists, bytes memory encodedMessagePassingAccount) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER),\n            _proof.stateTrieWitness,\n            _proof.stateRoot\n        );\n\n        require(\n            exists == true,\n            \"Message passing predeploy has not been initialized or invalid proof provided.\"\n        );\n\n        Lib_BVMCodec.EVMAccount memory account = Lib_BVMCodec.decodeEVMAccount(\n            encodedMessagePassingAccount\n        );\n\n        return\n            Lib_SecureMerkleTrie.verifyInclusionProof(\n                abi.encodePacked(storageKey),\n                abi.encodePacked(uint8(1)),\n                _proof.storageTrieWitness,\n                account.storageRoot\n            );\n    }\n\n    /**\n     * Sends a cross domain message.\n     * @param _canonicalTransactionChain Address of the CanonicalTransactionChain instance.\n     * @param _message Message to send.\n     * @param _gasLimit BVM gas limit for the message.\n     */\n    function _sendXDomainMessage(\n        address _canonicalTransactionChain,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) internal {\n        // slither-disable-next-line reentrancy-events\n        ICanonicalTransactionChain(_canonicalTransactionChain).enqueue(\n            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\n            _gasLimit,\n            _message\n        );\n    }\n}\n"
    },
    "contracts/standards/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.7;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "contracts/libraries/resolver/Lib_AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_AddressManager } from \"./Lib_AddressManager.sol\";\n\n/**\n * @title Lib_AddressResolver\n */\nabstract contract Lib_AddressResolver {\n    /*************\n     * Variables *\n     *************/\n\n    Lib_AddressManager public libAddressManager;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Lib_AddressManager.\n     */\n    constructor(address _libAddressManager) {\n        libAddressManager = Lib_AddressManager(_libAddressManager);\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Resolves the address associated with a given name.\n     * @param _name Name to resolve an address for.\n     * @return Address associated with the given name.\n     */\n    function resolve(string memory _name) public view returns (address) {\n        return libAddressManager.getAddress(_name);\n    }\n}\n"
    },
    "contracts/libraries/codec/Lib_BVMCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_RLPReader } from \"../rlp/Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"../rlp/Lib_RLPWriter.sol\";\nimport { Lib_BytesUtils } from \"../utils/Lib_BytesUtils.sol\";\nimport { Lib_Bytes32Utils } from \"../utils/Lib_Bytes32Utils.sol\";\n\n/**\n * @title Lib_BVMCodec\n */\nlibrary Lib_BVMCodec {\n    /*********\n     * Enums *\n     *********/\n\n    enum QueueOrigin {\n        SEQUENCER_QUEUE,\n        L1TOL2_QUEUE\n    }\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct EVMAccount {\n        uint256 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n    }\n\n    struct ChainBatchHeader {\n        uint256 batchIndex;\n        bytes32 batchRoot;\n        uint256 batchSize;\n        uint256 prevTotalElements;\n        bytes signature;\n        bytes extraData;\n    }\n\n    struct ChainInclusionProof {\n        uint256 index;\n        bytes32[] siblings;\n    }\n\n    struct Transaction {\n        uint256 timestamp;\n        uint256 blockNumber;\n        QueueOrigin l1QueueOrigin;\n        address l1TxOrigin;\n        address entrypoint;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    struct TransactionChainElement {\n        bool isSequenced;\n        uint256 queueIndex; // QUEUED TX ONLY\n        uint256 timestamp; // SEQUENCER TX ONLY\n        uint256 blockNumber; // SEQUENCER TX ONLY\n        bytes txData; // SEQUENCER TX ONLY\n    }\n\n    struct QueueElement {\n        bytes32 transactionHash;\n        uint40 timestamp;\n        uint40 blockNumber;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Encodes a standard BVM transaction.\n     * @param _transaction BVM transaction to encode.\n     * @return Encoded transaction bytes.\n     */\n    function encodeTransaction(Transaction memory _transaction)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                _transaction.timestamp,\n                _transaction.blockNumber,\n                _transaction.l1QueueOrigin,\n                _transaction.l1TxOrigin,\n                _transaction.entrypoint,\n                _transaction.gasLimit,\n                _transaction.data\n            );\n    }\n\n    /**\n     * Hashes a standard BVM transaction.\n     * @param _transaction BVM transaction to encode.\n     * @return Hashed transaction\n     */\n    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {\n        return keccak256(encodeTransaction(_transaction));\n    }\n\n    /**\n     * @notice Decodes an RLP-encoded account state into a useful struct.\n     * @param _encoded RLP-encoded account state.\n     * @return Account state struct.\n     */\n    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\n\n        return\n            EVMAccount({\n                nonce: Lib_RLPReader.readUint256(accountState[0]),\n                balance: Lib_RLPReader.readUint256(accountState[1]),\n                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\n                codeHash: Lib_RLPReader.readBytes32(accountState[3])\n            });\n    }\n\n    /**\n     * Calculates a hash for a given batch header.\n     * @param _batchHeader Header to hash.\n     * @return Hash of the header.\n     */\n    function hashBatchHeader(Lib_BVMCodec.ChainBatchHeader memory _batchHeader)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _batchHeader.batchRoot,\n                    _batchHeader.batchSize,\n                    _batchHeader.prevTotalElements,\n                    _batchHeader.signature,\n                    _batchHeader.extraData\n                )\n            );\n    }\n}\n"
    },
    "contracts/libraries/resolver/Lib_AddressManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* External Imports */\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Lib_AddressManager\n */\ncontract Lib_AddressManager is Ownable {\n    /**********\n     * Events *\n     **********/\n\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\n\n    /*************\n     * Variables *\n     *************/\n\n    mapping(bytes32 => address) private addresses;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Changes the address associated with a particular name.\n     * @param _name String name to associate an address with.\n     * @param _address Address to associate with the name.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }\n\n    /**\n     * Retrieves the address associated with a given name.\n     * @param _name Name to retrieve an address for.\n     * @return Address associated with the given name.\n     */\n    function getAddress(string memory _name) external view returns (address) {\n        return addresses[_getNameHash(_name)];\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Computes the hash of a name.\n     * @param _name Name to compute a hash for.\n     * @return Hash of the given name.\n     */\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_name));\n    }\n}\n"
    },
    "contracts/libraries/trie/Lib_SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_MerkleTrie } from \"./Lib_MerkleTrie.sol\";\n\n/**\n * @title Lib_SecureMerkleTrie\n */\nlibrary Lib_SecureMerkleTrie {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _verified) {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _exists, bytes memory _value) {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.get(key, _proof, _root);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Computes the secure counterpart to a key.\n     * @param _key Key to get a secure key from.\n     * @return _secureKey Secure version of the key.\n     */\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {\n        return abi.encodePacked(keccak256(_key));\n    }\n}\n"
    },
    "contracts/libraries/constants/Lib_DefaultValues.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_DefaultValues\n */\nlibrary Lib_DefaultValues {\n    // The default x-domain message sender being set to a non-zero value makes\n    // deployment a bit more expensive, but in exchange the refund on every call to\n    // `relayMessage` by the L1 and L2 messengers will be higher.\n    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;\n}\n"
    },
    "contracts/libraries/constants/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant BVM_MANTLE = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address payable internal constant BVM_ETH = payable(0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "contracts/libraries/bridge/Lib_CrossDomainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_CrossDomainUtils\n */\nlibrary Lib_CrossDomainUtils {\n    /**\n     * Generates the correct cross domain calldata for a message.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     * @return ABI encoded cross domain calldata.\n     */\n    function encodeXDomainCalldata(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,bytes,uint256)\",\n                _target,\n                _sender,\n                _message,\n                _messageNonce\n            );\n    }\n}\n"
    },
    "contracts/L1/messaging/IL1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_BVMCodec } from \"../../libraries/codec/Lib_BVMCodec.sol\";\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"../../libraries/bridge/ICrossDomainMessenger.sol\";\n\n/**\n * @title IL1CrossDomainMessenger\n */\ninterface IL1CrossDomainMessenger is ICrossDomainMessenger {\n    /*******************\n     * Data Structures *\n     *******************/\n\n    struct L2MessageInclusionProof {\n        bytes32 stateRoot;\n        Lib_BVMCodec.ChainBatchHeader stateRootBatchHeader;\n        Lib_BVMCodec.ChainInclusionProof stateRootProof;\n        bytes stateTrieWitness;\n        bytes storageTrieWitness;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     * @param _proof Inclusion proof for the given message.\n     */\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce,\n        L2MessageInclusionProof memory _proof\n    ) external;\n\n    /**\n     * Replays a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _sender Original sender address.\n     * @param _message Message to send to the target.\n     * @param _queueIndex CTC Queue index for the message to replay.\n     * @param _oldGasLimit Original gas limit used to send the message.\n     * @param _newGasLimit New gas limit to be used for this message.\n     */\n    function replayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _queueIndex,\n        uint32 _oldGasLimit,\n        uint32 _newGasLimit\n    ) external;\n}\n"
    },
    "contracts/L1/rollup/ICanonicalTransactionChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/* Library Imports */\nimport { Lib_BVMCodec } from \"../../libraries/codec/Lib_BVMCodec.sol\";\n\n/* Interface Imports */\nimport { IChainStorageContainer } from \"./IChainStorageContainer.sol\";\n\n/**\n * @title ICanonicalTransactionChain\n */\ninterface ICanonicalTransactionChain {\n    /**********\n     * Events *\n     **********/\n\n    event L2GasParamsUpdated(\n        uint256 l2GasDiscountDivisor,\n        uint256 enqueueGasCost,\n        uint256 enqueueL2GasPrepaid\n    );\n\n    event TransactionEnqueued(\n        address indexed _l1TxOrigin,\n        address indexed _target,\n        uint256 _gasLimit,\n        bytes _data,\n        uint256 indexed _queueIndex,\n        uint256 _timestamp\n    );\n\n    event QueueBatchAppended(\n        uint256 _startingQueueIndex,\n        uint256 _numQueueElements,\n        uint256 _totalElements\n    );\n\n    event SequencerBatchAppended(\n        uint256 _startingQueueIndex,\n        uint256 _numQueueElements,\n        uint256 _totalElements\n    );\n\n    event TransactionBatchAppended(\n        uint256 indexed _batchIndex,\n        bytes32 _batchRoot,\n        uint256 _batchSize,\n        uint256 _prevTotalElements,\n        bytes _signature,\n        bytes _extraData\n    );\n\n\n    event CTCBatchReset(\n        uint256 indexed _batchIndex,\n        uint40 _nextqIndex,\n        uint40 _totalElement,\n        uint40 _batchSize,\n        uint40 _numQueuedTransactions ,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    );\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct BatchContext {\n        uint256 numSequencedTransactions;\n        uint256 numSubsequentQueueTransactions;\n        uint256 timestamp;\n        uint256 blockNumber;\n    }\n\n    /*******************************\n     * Authorized Setter Functions *\n     *******************************/\n\n    /**\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\n     */\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost) external;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches() external view returns (IChainStorageContainer);\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements() external view returns (uint256 _totalElements);\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    function getTotalBatches() external view returns (uint256 _totalBatches);\n\n    /**\n     * Returns the index of the next element to be enqueued.\n     * @return Index for the next queue element.\n     */\n    function getNextQueueIndex() external view returns (uint40);\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    function getQueueElement(uint256 _index)\n        external\n        view\n        returns (Lib_BVMCodec.QueueElement memory _element);\n\n    /**\n     * Returns the timestamp of the last transaction.\n     * @return Timestamp for the last transaction.\n     */\n    function getLastTimestamp() external view returns (uint40);\n\n    /**\n     * Returns the blocknumber of the last transaction.\n     * @return Blocknumber for the last transaction.\n     */\n    function getLastBlockNumber() external view returns (uint40);\n\n    /**\n     * Get the number of queue elements which have not yet been included.\n     * @return Number of pending queue elements.\n     */\n    function getNumPendingQueueElements() external view returns (uint40);\n\n    /**\n     * Retrieves the length of the queue, including\n     * both pending and canonical transactions.\n     * @return Length of the queue.\n     */\n    function getQueueLength() external view returns (uint40);\n\n    /**\n     * Adds a transaction to the queue.\n     * @param _target Target contract to send the transaction to.\n     * @param _gasLimit Gas limit for the given transaction.\n     * @param _data Transaction data.\n     */\n    function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external;\n\n    /**\n     * Allows the sequencer to append a batch of transactions.\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\n     * .param _contexts Array of batch contexts.\n     * .param _transactionDataFields Array of raw transaction data.\n     */\n    function appendSequencerBatch(\n        // uint40 _shouldStartAtElement,\n        // uint24 _totalElementsToAppend,\n        // BatchContext[] _contexts,\n        // bytes[] _transactionDataFields\n    ) external;\n\n    function resetIndex(uint256 _batchIndex, uint40 _totalElement, uint40 _batchSize,\n        uint40 _nextqIndex,uint40 _numQueuedTransactions ,\n        uint40 _timestamp, uint40 _blockNumber) external;\n}\n"
    },
    "contracts/L1/rollup/IStateCommitmentChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/* Library Imports */\nimport { Lib_BVMCodec } from \"../../libraries/codec/Lib_BVMCodec.sol\";\n\n/**\n * @title IStateCommitmentChain\n */\ninterface IStateCommitmentChain {\n    /**********\n     * Events *\n     **********/\n\n    event StateBatchAppended(\n        uint256 indexed _batchIndex,\n        bytes32 _batchRoot,\n        uint256 _batchSize,\n        uint256 _prevTotalElements,\n        bytes _signature,\n        bytes _extraData\n    );\n\n    event StateBatchDeleted(uint256 indexed _batchIndex, bytes32 _batchRoot);\n\n    event DistributeTssReward(\n        uint256 indexed _startBlockNumber,\n        uint256 _length,\n        uint256 indexed _batchTime,\n        address[] _tssMembers\n    );\n\n    event RollBackL2Chain(uint256 indexed _startBlockNumber);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements() external view returns (uint256 _totalElements);\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    function getTotalBatches() external view returns (uint256 _totalBatches);\n\n    /**\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\n     */\n    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);\n\n    /**\n     * Appends a batch of state roots to the chain.\n     * @param _batch Batch of state roots.\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\n     * @param _signature tss group signature of state batches.\n     */\n    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement, bytes memory _signature) external;\n\n    /**\n     * Deletes all state roots after (and including) a given batch.\n     * @param _batchHeader Header of the batch to start deleting from.\n     */\n    function deleteStateBatch(Lib_BVMCodec.ChainBatchHeader memory _batchHeader) external;\n\n    /**\n     * Verifies a batch inclusion proof.\n     * @param _element Hash of the element to verify a proof for.\n     * @param _batchHeader Header of the batch in which the element was included.\n     * @param _proof Merkle inclusion proof for the element.\n     */\n    function verifyStateCommitment(\n        bytes32 _element,\n        Lib_BVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_BVMCodec.ChainInclusionProof memory _proof\n    ) external view returns (bool _verified);\n\n    /**\n     * Checks whether a given batch is still inside its fraud proof window.\n     * @param _batchHeader Header of the batch to check.\n     * @return _inside Whether or not the batch is inside the fraud proof window.\n     */\n    function insideFraudProofWindow(Lib_BVMCodec.ChainBatchHeader memory _batchHeader)\n    external\n    view\n    returns (bool _inside);\n\n    /**\n     * Emit event to notify sequencers to roll back.\n     * @param _shouldRollBack roll back to should start .\n     * @param _shouldStartAtElement Index of the element at which this batch should start\n     * @param _signature signature of rollback message\n     */\n    function rollBackL2Chain(uint256 _shouldRollBack,uint256 _shouldStartAtElement, bytes memory _signature) external;\n\n}\n"
    },
    "contracts/libraries/rlp/Lib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_RLPReader\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\n */\nlibrary Lib_RLPReader {\n    /*************\n     * Constants *\n     *************/\n\n    uint256 internal constant MAX_LIST_LENGTH = 32;\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({ length: _in.length, ptr: ptr });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");\n\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\n            );\n\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\n        return readList(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\n        return readBytes(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(bytes memory _in) internal pure returns (string memory) {\n        return readString(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\n        require(_in.length <= 33, \"Invalid RLP bytes32 value.\");\n\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\n        return readBytes32(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\n        return readUint256(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\n        require(_in.length == 1, \"Invalid RLP boolean value.\");\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        require(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(bytes memory _in) internal pure returns (bool) {\n        return readBool(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(_in.length == 21, \"Invalid RLP address value.\");\n\n        return address(uint160(readUint256(_in)));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(bytes memory _in) internal pure returns (address) {\n        return readAddress(toRLPItem(_in));\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        return _copy(_in);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(RLPItem memory _in)\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(_in.length > 0, \"RLP item cannot be null.\");\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            // slither-disable-next-line variable-scope\n            uint256 strLen = prefix - 0x80;\n\n            require(_in.length > strLen, \"Invalid RLP short string.\");\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\n            }\n\n            require(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            // slither-disable-next-line variable-scope\n            uint256 listLen = prefix - 0xc0;\n\n            require(_in.length > listLen, \"Invalid RLP short list.\");\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(_in.length > lenOfListLen, \"Invalid RLP long list length.\");\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\n            }\n\n            require(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    ) private pure returns (bytes memory) {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - (_length % 32)) - 1;\n        }\n\n        assembly {\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\n        }\n        return out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n"
    },
    "contracts/libraries/rlp/Lib_RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_RLPWriter\n * @author Bakaoh (with modifications)\n */\nlibrary Lib_RLPWriter {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * RLP encodes a byte string.\n     * @param _in The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded byte byte strings.\n     * @param _in The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * RLP encodes a string.\n     * @param _in The string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * RLP encodes an address.\n     * @param _in The address to encode.\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a uint.\n     * @param _in The uint256 to encode.\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * RLP encodes a bool.\n     * @param _in The bool to encode.\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param _len The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "contracts/libraries/utils/Lib_BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_BytesUtils\n */\nlibrary Lib_BytesUtils {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\n        if (_start >= _bytes.length) {\n            return bytes(\"\");\n        }\n\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\n        if (_bytes.length < 32) {\n            bytes32 ret;\n            assembly {\n                ret := mload(add(_bytes, 32))\n            }\n            return ret;\n        }\n\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\n    }\n\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\n        return uint256(toBytes32(_bytes));\n    }\n\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory nibbles = new bytes(_bytes.length * 2);\n\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            nibbles[i * 2] = _bytes[i] >> 4;\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n\n        return nibbles;\n    }\n\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory ret = new bytes(_bytes.length / 2);\n\n        for (uint256 i = 0; i < ret.length; i++) {\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n\n        return ret;\n    }\n\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/libraries/utils/Lib_Bytes32Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_Byte32Utils\n */\nlibrary Lib_Bytes32Utils {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \"true.\"\n     * @param _in Input bytes32 value.\n     * @return Bytes32 as a boolean.\n     */\n    function toBool(bytes32 _in) internal pure returns (bool) {\n        return _in != 0;\n    }\n\n    /**\n     * Converts a boolean to a bytes32 value.\n     * @param _in Input boolean value.\n     * @return Boolean as a bytes32.\n     */\n    function fromBool(bool _in) internal pure returns (bytes32) {\n        return bytes32(uint256(_in ? 1 : 0));\n    }\n\n    /**\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\n     * @param _in Input bytes32 value.\n     * @return Bytes32 as an address.\n     */\n    function toAddress(bytes32 _in) internal pure returns (address) {\n        return address(uint160(uint256(_in)));\n    }\n\n    /**\n     * Converts an address to a bytes32.\n     * @param _in Input address value.\n     * @return Address as a bytes32.\n     */\n    function fromAddress(address _in) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_in)));\n    }\n}\n"
    },
    "contracts/libraries/trie/Lib_MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_BytesUtils } from \"../utils/Lib_BytesUtils.sol\";\nimport { Lib_RLPReader } from \"../rlp/Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"../rlp/Lib_RLPWriter.sol\";\n\n/**\n * @title Lib_MerkleTrie\n */\nlibrary Lib_MerkleTrie {\n    /*******************\n     * Data Structures *\n     *******************/\n\n    enum NodeType {\n        BranchNode,\n        ExtensionNode,\n        LeafNode\n    }\n\n    struct TrieNode {\n        bytes encoded;\n        Lib_RLPReader.RLPItem[] decoded;\n    }\n\n    /**********************\n     * Contract Constants *\n     **********************/\n\n    // TREE_RADIX determines the number of elements per branch node.\n    uint256 constant TREE_RADIX = 16;\n    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\n    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\n    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n    // Prefixes are prepended to the `path` within a leaf or extension node and\n    // allow us to differentiate between the two node types. `ODD` or `EVEN` is\n    // determined by the number of nibbles within the unprefixed `path`. If the\n    // number of nibbles if even, we need to insert an extra padding nibble so\n    // the resulting prefixed `path` has an even number of nibbles.\n    uint8 constant PREFIX_EXTENSION_EVEN = 0;\n    uint8 constant PREFIX_EXTENSION_ODD = 1;\n    uint8 constant PREFIX_LEAF_EVEN = 2;\n    uint8 constant PREFIX_LEAF_ODD = 3;\n\n    // Just a utility constant. RLP represents `NULL` as 0x80.\n    bytes1 constant RLP_NULL = bytes1(0x80);\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _verified) {\n        (bool exists, bytes memory value) = get(_key, _proof, _root);\n\n        return (exists && Lib_BytesUtils.equal(_value, value));\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _exists, bytes memory _value) {\n        TrieNode[] memory proof = _parseProof(_proof);\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\n            proof,\n            _key,\n            _root\n        );\n\n        bool exists = keyRemainder.length == 0;\n\n        require(exists || isFinalNode, \"Provided proof is invalid.\");\n\n        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\"\");\n\n        return (exists, value);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * @notice Walks through a proof using a provided key.\n     * @param _proof Inclusion proof to walk through.\n     * @param _key Key to use for the walk.\n     * @param _root Known root of the trie.\n     * @return _pathLength Length of the final path\n     * @return _keyRemainder Portion of the key remaining after the walk.\n     * @return _isFinalNode Whether or not we've hit a dead end.\n     */\n    function _walkNodePath(\n        TrieNode[] memory _proof,\n        bytes memory _key,\n        bytes32 _root\n    )\n        private\n        pure\n        returns (\n            uint256 _pathLength,\n            bytes memory _keyRemainder,\n            bool _isFinalNode\n        )\n    {\n        uint256 pathLength = 0;\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\n\n        bytes32 currentNodeID = _root;\n        uint256 currentKeyIndex = 0;\n        uint256 currentKeyIncrement = 0;\n        TrieNode memory currentNode;\n\n        // Proof is top-down, so we start at the first element (root).\n        for (uint256 i = 0; i < _proof.length; i++) {\n            currentNode = _proof[i];\n            currentKeyIndex += currentKeyIncrement;\n\n            // Keep track of the proof elements we actually need.\n            // It's expensive to resize arrays, so this simply reduces gas costs.\n            pathLength += 1;\n\n            if (currentKeyIndex == 0) {\n                // First proof element is always the root node.\n                require(keccak256(currentNode.encoded) == currentNodeID, \"Invalid root hash\");\n            } else if (currentNode.encoded.length >= 32) {\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\n                require(\n                    keccak256(currentNode.encoded) == currentNodeID,\n                    \"Invalid large internal hash\"\n                );\n            } else {\n                // Nodes smaller than 31 bytes aren't hashed.\n                require(\n                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\n                    \"Invalid internal node hash\"\n                );\n            }\n\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\n                if (currentKeyIndex == key.length) {\n                    // We've hit the end of the key\n                    // meaning the value should be within this branch node.\n                    break;\n                } else {\n                    // We're not at the end of the key yet.\n                    // Figure out what the next node ID should be and continue.\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\n                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\n                    currentNodeID = _getNodeID(nextNode);\n                    currentKeyIncrement = 1;\n                    continue;\n                }\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n                bytes memory path = _getNodePath(currentNode);\n                uint8 prefix = uint8(path[0]);\n                uint8 offset = 2 - (prefix % 2);\n                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\n                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n                    if (\n                        pathRemainder.length == sharedNibbleLength &&\n                        keyRemainder.length == sharedNibbleLength\n                    ) {\n                        // The key within this leaf matches our key exactly.\n                        // Increment the key index to reflect that we have no remainder.\n                        currentKeyIndex += sharedNibbleLength;\n                    }\n\n                    // We've hit a leaf node, so our next node should be NULL.\n                    currentNodeID = bytes32(RLP_NULL);\n                    break;\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n                    if (sharedNibbleLength != pathRemainder.length) {\n                        // Our extension node is not identical to the remainder.\n                        // We've hit the end of this path\n                        // updates will need to modify this extension.\n                        currentNodeID = bytes32(RLP_NULL);\n                        break;\n                    } else {\n                        // Our extension shares some nibbles.\n                        // Carry on to the next node.\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\n                        currentKeyIncrement = sharedNibbleLength;\n                        continue;\n                    }\n                } else {\n                    revert(\"Received a node with an unknown prefix\");\n                }\n            } else {\n                revert(\"Received an unparseable node.\");\n            }\n        }\n\n        // If our node ID is NULL, then we're at a dead end.\n        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\n        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);\n    }\n\n    /**\n     * @notice Parses an RLP-encoded proof into something more useful.\n     * @param _proof RLP-encoded proof to parse.\n     * @return _parsed Proof parsed into easily accessible structs.\n     */\n    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {\n        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\n        TrieNode[] memory proof = new TrieNode[](nodes.length);\n\n        for (uint256 i = 0; i < nodes.length; i++) {\n            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\n            proof[i] = TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });\n        }\n\n        return proof;\n    }\n\n    /**\n     * @notice Picks out the ID for a node. Node ID is referred to as the\n     * \"hash\" within the specification, but nodes < 32 bytes are not actually\n     * hashed.\n     * @param _node Node to pull an ID for.\n     * @return _nodeID ID for the node, depending on the size of its contents.\n     */\n    function _getNodeID(Lib_RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {\n        bytes memory nodeID;\n\n        if (_node.length < 32) {\n            // Nodes smaller than 32 bytes are RLP encoded.\n            nodeID = Lib_RLPReader.readRawBytes(_node);\n        } else {\n            // Nodes 32 bytes or larger are hashed.\n            nodeID = Lib_RLPReader.readBytes(_node);\n        }\n\n        return Lib_BytesUtils.toBytes32(nodeID);\n    }\n\n    /**\n     * @notice Gets the path for a leaf or extension node.\n     * @param _node Node to get a path for.\n     * @return _path Node path, converted to an array of nibbles.\n     */\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {\n        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\n    }\n\n    /**\n     * @notice Gets the path for a node.\n     * @param _node Node to get a value for.\n     * @return _value Node value, as hex bytes.\n     */\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {\n        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\n    }\n\n    /**\n     * @notice Utility; determines the number of nibbles shared between two\n     * nibble arrays.\n     * @param _a First nibble array.\n     * @param _b Second nibble array.\n     * @return _shared Number of shared nibbles.\n     */\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\n        private\n        pure\n        returns (uint256 _shared)\n    {\n        uint256 i = 0;\n        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\n            i++;\n        }\n        return i;\n    }\n}\n"
    },
    "contracts/L1/rollup/IChainStorageContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IChainStorageContainer\n */\ninterface IChainStorageContainer {\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\n     * 27 bytes to store arbitrary data.\n     * @param _globalMetadata New global metadata to set.\n     */\n    function setGlobalMetadata(bytes27 _globalMetadata) external;\n\n    /**\n     * Retrieves the container's global metadata field.\n     * @return Container global metadata field.\n     */\n    function getGlobalMetadata() external view returns (bytes27);\n\n    /**\n     * Retrieves the number of objects stored in the container.\n     * @return Number of objects in the container.\n     */\n    function length() external view returns (uint256);\n\n    /**\n     * Pushes an object into the container.\n     * @param _object A 32 byte value to insert into the container.\n     */\n    function push(bytes32 _object) external;\n\n    /**\n     * Pushes an object into the container. Function allows setting the global metadata since\n     * we'll need to touch the \"length\" storage slot anyway, which also contains the global\n     * metadata (it's an optimization).\n     * @param _object A 32 byte value to insert into the container.\n     * @param _globalMetadata New global metadata for the container.\n     */\n    function push(bytes32 _object, bytes27 _globalMetadata) external;\n\n    /**\n     * Retrieves an object from the container.\n     * @param _index Index of the particular object to access.\n     * @return 32 byte object value.\n     */\n    function get(uint256 _index) external view returns (bytes32);\n\n    /**\n     * Removes all objects after and including a given index.\n     * @param _index Object index to delete from.\n     */\n    function deleteElementsAfterInclusive(uint256 _index) external;\n\n    /**\n     * Removes all objects after and including a given index. Also allows setting the global\n     * metadata field.\n     * @param _index Object index to delete from.\n     * @param _globalMetadata New global metadata for the container.\n     */\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;\n}\n"
    },
    "contracts/da/BVM_EigenDataLayrFee.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract BVM_EigenDataLayrFee is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    address public gasFeeAddress;\n    uint256 userRollupFee;\n\n    event RollupFeeHistory(uint256 l2Block, uint256 userRollupFee);\n    event FeeAddressUpdated(address oldFeeAddress, address newFeeAddress);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _address) public initializer {\n        require(_address != address(0), \"initialize: can't set zero address to gasFeeAddress\");\n        __Ownable_init();\n        userRollupFee = 0;\n        gasFeeAddress = _address;\n    }\n\n    function setFeeAddress(address _address) public onlyOwner {\n        require(_address != address(0), \"setFeeAddress: address is the zero address\");\n        address oldGasFeeAddress = gasFeeAddress;\n        gasFeeAddress = _address;\n        emit FeeAddressUpdated(oldGasFeeAddress, gasFeeAddress);\n    }\n\n    modifier onlyGasFee() {\n        require(msg.sender == gasFeeAddress, \"contract call is not gas fee address\");\n        _;\n    }\n\n    function setRollupFee(uint256 _l2Block, uint256 _userRollupFee) public onlyGasFee {\n        userRollupFee = _userRollupFee;\n        emit RollupFeeHistory(_l2Block, _userRollupFee);\n    }\n\n    function getRollupFee() public view returns (uint256) {\n        return userRollupFee;\n    }\n}\n"
    },
    "contracts/L1/tss/TssGroupManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {Lib_Address} from \"../../libraries/utils/Lib_Address.sol\";\nimport \"./ITssGroupManager.sol\";\nimport \"./ITssStakingSlashing.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract TssGroupManager is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ITssGroupManager\n{\n    using SafeMathUpgradeable for uint256;\n    using ECDSAUpgradeable for bytes32;\n    using AddressUpgradeable for address;\n    bytes confirmGroupPublicKey;\n    address confirmGroupAddress;\n    uint256 threshold;\n    uint256 gRoundId;\n    uint256 tempThreshold;\n    address public stakingSlash;\n\n    bytes[] activeTssMembers; // active tss member group\n    bytes[] inActiveTssMembers; // inactive tss member group\n    mapping(bytes => TssMember) public tssActiveMemberInfo; // Tss member publicKey => tssMember\n    mapping(bytes => bytes) private _memberGroupKey; // user publicKey => Cpk\n    mapping(bytes => uint256) private _groupKeyCounter; // Cpk counter\n    mapping(bytes => bool) private _isSubmitGroupKey; // submit group key or not\n    mapping(bytes => bool) public isInActiveMember; // tss member exist or not\n\n    event tssGroupMemberAppend(uint256 _roundId, uint256 _threshold, bytes[] _inActiveTssMembers);\n\n    event tssActiveMemberAppended(uint256 _roundId, bytes _groupKey, bytes[] activeTssMembers);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize() public initializer {\n        __Ownable_init();\n        gRoundId = 0;\n        threshold = 0;\n        tempThreshold = 0;\n    }\n\n    modifier onlyStakingSlash() {\n        require(msg.sender == stakingSlash, \"contract call is not staking slashing\");\n        _;\n    }\n\n    function setStakingSlash(address _address) public onlyOwner {\n        require(_address != address(0), \"param _address is the zero address\");\n        stakingSlash = _address;\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function setTssGroupMember(uint256 _threshold, bytes[] calldata _batchPublicKey)\n        public\n        override\n        onlyOwner\n    {\n        require((_batchPublicKey.length > 0), \"batch public key is empty\");\n        require(_threshold < _batchPublicKey.length, \"threshold must less than tss member\");\n        for (uint256 i = 0; i < _batchPublicKey.length; i++) {\n            address operator = Lib_Address.publicKeyToAddress(_batchPublicKey[i]);\n            require(IStakingSlashing(stakingSlash).isCanOperator(operator),\"batch public keys has a node ,can not be operator\");\n        }\n\n        if(inActiveTssMembers.length > 0) {\n            for (uint256 i = 0; i < inActiveTssMembers.length; i++) {\n                // re-election clear data\n                delete _groupKeyCounter[_memberGroupKey[inActiveTssMembers[i]]];\n                delete _memberGroupKey[inActiveTssMembers[i]];\n                delete _isSubmitGroupKey[inActiveTssMembers[i]];\n                delete isInActiveMember[inActiveTssMembers[i]];\n            }\n            delete inActiveTssMembers;\n        }\n        for (uint256 i = 0; i < _batchPublicKey.length; i++) {\n            inActiveTssMembers.push(_batchPublicKey[i]);\n            isInActiveMember[_batchPublicKey[i]] = true;\n            _isSubmitGroupKey[_batchPublicKey[i]] = false;\n        }\n        tempThreshold = _threshold;\n        emit tssGroupMemberAppend(gRoundId + 1, _threshold, _batchPublicKey);\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function setGroupPublicKey(bytes calldata _publicKey, bytes calldata _groupPublicKey)\n        public\n        override\n    {\n        require(isInActiveMember[_publicKey], \"your public key is not in InActiveMember\");\n        require(msg.sender == Lib_Address.publicKeyToAddress(_publicKey), \"public key not match\");\n        require(_groupPublicKey.length == 64, \"Invalid groupPublicKey length\");\n\n        if (!_isSubmitGroupKey[_publicKey]) {\n            _isSubmitGroupKey[_publicKey] = true;\n        }\n        if (!_isEqual(_memberGroupKey[_publicKey], _groupPublicKey)) {\n            _groupKeyCounter[_groupPublicKey] += 1;\n            if (_memberGroupKey[_publicKey].length != 0) {\n                _groupKeyCounter[_memberGroupKey[_publicKey]] -= 1;\n            }\n            _memberGroupKey[_publicKey] = _groupPublicKey;\n        }\n        if (_groupKeyCounter[_groupPublicKey] >= inActiveTssMembers.length) {\n            _updateTssMember(_groupPublicKey);\n        }\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function getTssGroupInfo()\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            bytes memory,\n            bytes[] memory\n        )\n    {\n        return (gRoundId, threshold, confirmGroupPublicKey, activeTssMembers);\n    }\n\n    /**\n    * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function getTssInactiveGroupInfo() public view override returns (uint256, uint256,  bytes[] memory){\n        return (gRoundId + 1, tempThreshold, inActiveTssMembers);\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function memberJail(bytes calldata _publicKey) public override onlyStakingSlash {\n        tssActiveMemberInfo[_publicKey].status = MemberStatus.jail;\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function memberUnJail(bytes calldata _publicKey) public override onlyStakingSlash {\n        tssActiveMemberInfo[_publicKey].status = MemberStatus.unJail;\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function removeMember(bytes calldata _publicKey) public override onlyOwner {\n        require(\n            activeTssMembers.length > threshold + 1,\n            \"TssGroupManager removeMember: active members must more than threshold plus one\"\n        );\n        for (uint256 i = 0; i < activeTssMembers.length; i++) {\n            if (_isEqual(activeTssMembers[i], _publicKey)) {\n                _removeActiveTssMembers(i);\n                break;\n            }\n        }\n        delete tssActiveMemberInfo[_publicKey];\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function getTssGroupUnJailMembers() public view override returns (address[] memory) {\n        uint256 expectedLength;\n        for (uint256 i = 0; i < activeTssMembers.length; i++) {\n            if (tssActiveMemberInfo[activeTssMembers[i]].status == MemberStatus.unJail) {\n                expectedLength++;\n            }\n        }\n        address[] memory _addresses = new address[](expectedLength);\n        uint256 index;\n        for (uint256 i = 0; i < activeTssMembers.length; i++) {\n            if (tssActiveMemberInfo[activeTssMembers[i]].status == MemberStatus.unJail) {\n                _addresses[index] = tssActiveMemberInfo[activeTssMembers[i]].nodeAddress;\n                index++;\n            }\n        }\n        return _addresses;\n    }\n\n    function isTssGroupUnJailMembers(address _addr) public view override returns (bool) {\n        for (uint256 i = 0; i < activeTssMembers.length; i++) {\n            if (tssActiveMemberInfo[activeTssMembers[i]].status == MemberStatus.unJail) {\n                if ( _addr == tssActiveMemberInfo[activeTssMembers[i]].nodeAddress) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function memberExistActive(address _addr) public view override returns (bool) {\n        for (uint256 i = 0; i < activeTssMembers.length; i++) {\n            if ( _addr == tssActiveMemberInfo[activeTssMembers[i]].nodeAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function getTssGroupMembers() public view override returns (bytes[] memory) {\n        return activeTssMembers;\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function getTssMember(bytes calldata _publicKey) public view override returns (TssMember memory) {\n        return tssActiveMemberInfo[_publicKey];\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function memberExistActive(bytes calldata _publicKey) public view override returns (bool) {\n        if (tssActiveMemberInfo[_publicKey].publicKey.length > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function memberExistInActive(bytes calldata _publicKey) public view override returns (bool) {\n        return isInActiveMember[_publicKey];\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function inActiveIsEmpty() public view override returns (bool) {\n        return inActiveTssMembers.length == 0;\n    }\n\n    /**\n     * @inheritdoc ITssGroupManager\n     */\n    // slither-disable-next-line external-function\n    function verifySign(bytes32 _message, bytes calldata _sig) public view override returns (bool) {\n        return (recover(_message, _sig) == confirmGroupAddress);\n    }\n\n    function _updateTssMember(bytes calldata _groupPublicKey) private {\n        if (activeTssMembers.length > 0) {\n            for (uint256 i = 0; i < activeTssMembers.length; i++) {\n                delete tssActiveMemberInfo[activeTssMembers[i]];    // delete tss active member map\n            }\n            delete activeTssMembers;  // delete active members\n        }\n        for (uint256 i = 0; i < inActiveTssMembers.length; i++) {\n            activeTssMembers.push(inActiveTssMembers[i]);\n            tssActiveMemberInfo[inActiveTssMembers[i]] = TssMember({\n                publicKey: inActiveTssMembers[i],\n                nodeAddress: Lib_Address.publicKeyToAddress(inActiveTssMembers[i]),\n                status: MemberStatus.unJail\n            });\n            // election finish clear InActiveMember data\n            delete _groupKeyCounter[_memberGroupKey[inActiveTssMembers[i]]];\n            delete _memberGroupKey[inActiveTssMembers[i]];\n            delete _isSubmitGroupKey[inActiveTssMembers[i]];\n            delete isInActiveMember[inActiveTssMembers[i]];\n        }\n        delete inActiveTssMembers;\n        confirmGroupPublicKey = _groupPublicKey;\n        confirmGroupAddress = Lib_Address.publicKeyToAddress(_groupPublicKey);\n        threshold = tempThreshold;\n        gRoundId = gRoundId + 1;\n        emit tssActiveMemberAppended(gRoundId, _groupPublicKey, activeTssMembers);\n    }\n\n    function recover(bytes32 _ethSignedMessageHash, bytes calldata _sig)\n        public\n        pure\n        returns (address)\n    {\n        (bytes32 r, bytes32 s, uint8 v) = _split(_sig);\n        address signer = ecrecover(_ethSignedMessageHash, v, r, s);\n        require(signer != address(0), \"ecrecover failed\");\n        return signer;\n    }\n\n    function _split(bytes memory _sig)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        require(_sig.length == 65, \"invalid signature length\");\n        assembly {\n            r := mload(add(_sig, 32))\n            s := mload(add(_sig, 64))\n            v := byte(0, mload(add(_sig, 96)))\n        }\n        if (v < 27) v += 27;\n    }\n\n    function _isEqual(bytes memory byteListA, bytes memory byteListB) private pure returns (bool) {\n        if (byteListA.length != byteListB.length) return false;\n        for (uint256 i = 0; i < byteListA.length; i++) {\n            if (byteListA[i] != byteListB[i]) return false;\n        }\n        return true;\n    }\n\n    function _removeActiveTssMembers(uint256 _index) private {\n        activeTssMembers[_index] = activeTssMembers[activeTssMembers.length - 1];\n        activeTssMembers.pop();\n    }\n}\n"
    },
    "contracts/L1/local/TestMantleToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/// @title L1MantleToken\n/// @author 0xMantle\n/// @notice ERC20 token with minting, burning, and governance functionality\ncontract L1MantleToken is\nInitializable,\nERC20Upgradeable,\nERC20BurnableUpgradeable,\nOwnableUpgradeable,\nERC20PermitUpgradeable,\nERC20VotesUpgradeable\n{\n    /* ========== STATE VARIABLES ========== */\n\n    string private constant NAME = \"Mantle\";\n    string private constant SYMBOL = \"MNT\";\n\n    /// @dev The minimum amount of time that must elapse before a mint is allowed\n    uint256 public constant MIN_MINT_INTERVAL = 365 days;\n\n    /// @dev The denominator of the maximum fractional amount that can be minted\n    uint256 public constant MINT_CAP_DENOMINATOR = 10_000;\n\n    /// @dev The numerator of the maximum fractional amount that can be minted\n    uint256 public immutable MINT_CAP_MAX_NUMERATOR = 200;\n\n    /// @dev The current numerator of the fractional amount that can be minted\n    uint256 public mintCapNumerator;\n\n    /// @dev The blockTimeStamp at which mint will be able to be called again\n    uint256 public nextMint;\n\n    /* ========== EVENTS ========== */\n\n    /// @dev Emitted when the mintCapNumerator is set\n    /// @param from The address which changed the mintCapNumerator\n    /// @param previousMintCapNumerator The previous mintCapNumerator\n    /// @param newMintCapNumerator The new mintCapNumerator\n    event MintCapNumeratorChanged(address indexed from, uint256 previousMintCapNumerator, uint256 newMintCapNumerator);\n\n    /* ========== ERRORS ========== */\n\n    /// @notice Thrown when at least one of the inputs passed into the constructor is a zero value\n    error MantleToken_ImproperlyInitialized();\n\n    /// @notice Thrown when mint is called before the nextMint timestamp has passed\n    error MantleToken_NextMintTimestampNotElapsed(uint256 currentTimestamp, uint256 nextMintTimestamp);\n\n    /// @notice Thrown when mint is called with a value greater than the maximum allowed\n    error MantleToken_MintAmountTooLarge(uint256 amount, uint256 maximumAmount);\n\n    /// @notice Thrown when the mintCapNumerator is set to a value greater than the maximum allowed\n    error MantleToken_MintCapNumeratorTooLarge(uint256 numerator, uint256 maximumNumerator);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    /// @notice Initializes the L1MantleToken contract, setting the inital total supply as {initialSupply} and the owner as {_owner}\n    /// @dev the mintCapNumerator should not be set as it is initialized as 0\n    /// @dev Requirements:\n    ///     - all parameters must be non-zero\n    /// @param _initialSupply The initial total supply of the token\n    /// @param _owner The owner of the token\n\n    function initialize(uint256 _initialSupply, address _owner) public initializer {\n        if (_initialSupply == 0 || _owner == address(0)) revert MantleToken_ImproperlyInitialized();\n\n        __ERC20_init(NAME, SYMBOL);\n        __ERC20Burnable_init();\n        __Ownable_init();\n        __ERC20Permit_init(NAME);\n        __ERC20Votes_init();\n\n        _mint(_owner, _initialSupply);\n        nextMint = block.timestamp + MIN_MINT_INTERVAL;\n\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Allows the owner to mint new tokens and increase this token's total supply\n    /// @dev Requirements:\n    ///     - Only allows minting below an inflation cap at a specified time interval\n    ///         - The max mint amount is computed as follows:\n    ///             - maxMintAmount = (mintCapNumerator * totalSupply()) / MINT_CAP_DENOMINATOR\n    ///              - The specified time interval at which mints can occur is initially set to 1 year\n    ///     - the parameter {amount} must be less than or equal to {maxMintAmount} as computed above\n    ///     - the {blockTimestamp} of the block in which this function is called must be greater than or equal to {nextMint}\n    /// @param _recipient The address to mint tokens to\n    /// @param _amount The amount of tokens to mint\n    function mint(address _recipient, uint256 _amount) public onlyOwner {\n        uint256 maximumMintAmount = (totalSupply() * mintCapNumerator) / MINT_CAP_DENOMINATOR;\n        if (_amount > maximumMintAmount) {\n            revert MantleToken_MintAmountTooLarge(_amount, maximumMintAmount);\n        }\n        if (block.timestamp < nextMint) revert MantleToken_NextMintTimestampNotElapsed(block.timestamp, nextMint);\n\n        nextMint = block.timestamp + MIN_MINT_INTERVAL;\n        _mint(_recipient, _amount);\n    }\n\n    /// @notice Allows the owner to set the mintCapNumerator\n    /// @dev emits a {MintCapNumeratorSet} event\n    /// @dev Requirements:\n    ///     - The caller must be the contract owner\n    ///     - parameter {_mintCapNumerator} must be less than or equal to {MINT_CAP_MAX_NUMERATOR}\n    function setMintCapNumerator(uint256 _mintCapNumerator) public onlyOwner {\n        if (_mintCapNumerator > MINT_CAP_MAX_NUMERATOR) {\n            revert MantleToken_MintCapNumeratorTooLarge(_mintCapNumerator, MINT_CAP_MAX_NUMERATOR);\n        }\n\n        uint256 previousMintCapNumerator = mintCapNumerator;\n        mintCapNumerator = _mintCapNumerator;\n\n        emit MintCapNumeratorChanged(msg.sender, previousMintCapNumerator, mintCapNumerator);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    /// @inheritdoc ERC20Upgradeable\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function _mint(address to, uint256 amount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._mint(to, amount);\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function _burn(address account, uint256 amount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._burn(account, amount);\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/VerifierEntry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./libraries/VerificationContext.sol\";\nimport \"./libraries/Params.sol\";\nimport \"./IVerifier.sol\";\nimport \"./IVerifierEntry.sol\";\n\ncontract VerifierEntry is IVerifierEntry, Initializable, OwnableUpgradeable {\n    IVerifier public  blockInitiationVerifier;\n    IVerifier public blockFinalizationVerifier;\n    IVerifier public interTxVerifier;\n    IVerifier public stackOpVerifier;\n    IVerifier public environmentalOpVerifier;\n    IVerifier public memoryOpVerifier;\n    IVerifier public storageOpVerifier;\n    IVerifier public callOpVerifier;\n    IVerifier public invalidOpVerifier;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    function setVerifier(uint8 verifier, IVerifier impl)\n        external\n        onlyOwner\n    {\n        if (verifier == Params.V_BLOCK_INIT) {\n            blockInitiationVerifier = impl;\n        } else if (verifier == Params.V_BLOCK_FINAL) {\n            blockFinalizationVerifier = impl;\n        } else if (verifier == Params.V_INTER_TX) {\n            interTxVerifier = impl;\n        } else if (verifier == Params.V_STACK_OP) {\n            stackOpVerifier = impl;\n        } else if (verifier == Params.V_ENVIRONMENTAL_OP) {\n            environmentalOpVerifier = impl;\n        } else if (verifier == Params.V_MEMORY_OP) {\n            memoryOpVerifier = impl;\n        } else if (verifier == Params.V_STORAGE_OP) {\n            storageOpVerifier = impl;\n        } else if (verifier == Params.V_CALL_OP) {\n            callOpVerifier = impl;\n        } else if (verifier == Params.V_INVALID_OP) {\n            invalidOpVerifier = impl;\n        } else {\n            revert(\"unreachable\");\n        }\n    }\n\n    function verifyOneStepProof(\n        VerificationContext.Context memory ctx,\n        uint8 verifier,\n        bytes32 currStateHash,\n        bytes calldata encoded\n    ) external view override returns (bytes32) {\n        IVerifier impl;\n        if (verifier == Params.V_BLOCK_INIT) {\n            impl = blockInitiationVerifier;\n        } else if (verifier == Params.V_BLOCK_FINAL) {\n            impl = blockFinalizationVerifier;\n        } else if (verifier == Params.V_INTER_TX) {\n            impl = interTxVerifier;\n        } else if (verifier == Params.V_STACK_OP) {\n            impl = stackOpVerifier;\n        } else if (verifier == Params.V_ENVIRONMENTAL_OP) {\n            impl = environmentalOpVerifier;\n        } else if (verifier == Params.V_MEMORY_OP) {\n            impl = memoryOpVerifier;\n        } else if (verifier == Params.V_STORAGE_OP) {\n            impl = storageOpVerifier;\n        } else if (verifier == Params.V_CALL_OP) {\n            impl = callOpVerifier;\n        } else if (verifier == Params.V_INVALID_OP) {\n            impl = invalidOpVerifier;\n        } else {\n            revert(\"unreachable\");\n        }\n        return impl.verifyOneStepProof(ctx, currStateHash, encoded);\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/libraries/VerificationContext.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/DeserializationLib.sol\";\nimport \"../../libraries/BytesLib.sol\";\nimport \"../../libraries/MerkleLib.sol\";\n\nimport \"./MemoryLib.sol\";\nimport \"./EVMTypesLib.sol\";\n\nlibrary VerificationContext {\n    using BytesLib for bytes;\n    using EVMTypesLib for EVMTypesLib.Transaction;\n\n    struct Context {\n        address coinbase;\n        uint256 timestamp;\n        uint256 number;\n        address origin;\n        EVMTypesLib.Transaction transaction;\n        bytes32 inputRoot;\n        bytes32 txHash;\n    }\n\n    function newContext(bytes calldata proof) internal view returns (Context memory ctx) {\n//        inbox.verifyTxInclusion(proof);\n//        ctx.coinbase = inbox.sequencerAddress();\n        ctx.coinbase = address(0); // TODO FIXME\n        uint256 offset = 0;\n        uint256 txDataLength;\n        (offset, ctx.origin) = DeserializationLib.deserializeAddress(proof, offset);\n        (offset, ctx.number) = DeserializationLib.deserializeUint256(proof, offset);\n        (offset, ctx.timestamp) = DeserializationLib.deserializeUint256(proof, offset);\n        (offset, txDataLength) = DeserializationLib.deserializeUint256(proof, offset);\n        bytes memory txData = bytes(proof[offset:txDataLength]);\n        ctx.transaction = EVMTypesLib.decodeTransaction(txData);\n    }\n\n    function getCoinbase(Context memory ctx) internal pure returns (address) {\n        return ctx.coinbase;\n    }\n\n    function getTimestamp(Context memory ctx) internal pure returns (uint256) {\n        return ctx.timestamp;\n    }\n\n    function getBlockNumber(Context memory ctx) internal pure returns (uint256) {\n        return ctx.number;\n    }\n\n    function getDifficulty(Context memory) internal pure returns (uint256) {\n        return 1;\n    }\n\n    function getGasLimit(Context memory) internal pure returns (uint64) {\n        return 80000000;\n    }\n\n    function getChainID(Context memory) internal pure returns (uint256) {\n        return 13527;\n    }\n\n    // Transaction\n    function getOrigin(Context memory ctx) internal pure returns (address) {\n        return ctx.origin;\n    }\n\n    function getRecipient(Context memory ctx) internal pure returns (address) {\n        return ctx.transaction.to;\n    }\n\n    function getValue(Context memory ctx) internal pure returns (uint256) {\n        return ctx.transaction.value;\n    }\n\n    function getGas(Context memory ctx) internal pure returns (uint64) {\n        return ctx.transaction.gas;\n    }\n\n    function getGasPrice(Context memory ctx) internal pure returns (uint256) {\n        return ctx.transaction.gasPrice;\n    }\n\n    function getInput(Context memory ctx) internal pure returns (bytes memory) {\n        return ctx.transaction.data;\n    }\n\n    function getInputSize(Context memory ctx) internal pure returns (uint64) {\n        return uint64(ctx.transaction.data.length);\n    }\n\n    function getInputRoot(Context memory ctx) internal pure returns (bytes32) {\n        if (ctx.inputRoot == 0x0) {\n            ctx.inputRoot = MemoryLib.getMemoryRoot(ctx.transaction.data);\n        }\n        return ctx.inputRoot;\n    }\n\n    function getTxHash(Context memory ctx) internal pure returns (bytes32) {\n        if (ctx.txHash == 0x0) {\n            ctx.txHash = ctx.transaction.hashTransaction();\n        }\n        return ctx.transaction.hashTransaction();\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/libraries/Params.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nlibrary Params {\n    // Verifier\n    uint8 constant V_STACK_OP = 0;\n    uint8 constant V_ENVIRONMENTAL_OP = 1;\n    uint8 constant V_MEMORY_OP = 2;\n    uint8 constant V_STORAGE_OP = 3;\n    uint8 constant V_CALL_OP = 4;\n    uint8 constant V_INVALID_OP = 5;\n    uint8 constant V_INTER_TX = 6;\n    uint8 constant V_BLOCK_INIT = 7;\n    uint8 constant V_BLOCK_FINAL = 8;\n\n    // Gas\n    uint64 constant G_ZERO = 0;\n    uint64 constant G_JUMPDEST = 1;\n    uint64 constant G_BASE = 2;\n    uint64 constant G_VERYLOW = 3;\n    uint64 constant G_LOW = 5;\n    uint64 constant G_MID = 8;\n    uint64 constant G_HIGH = 10;\n    uint64 constant G_EXTCODE = 700;\n    uint64 constant G_BALANCE = 700;\n    uint64 constant G_SLOAD = 800;\n    uint64 constant G_SSET = 20000;\n    uint64 constant G_SRESET = 5000;\n    uint64 constant R_SCLEAR = 15000;\n    uint64 constant R_SELFDESTRUCT = 24000;\n    uint64 constant G_SELFDESTRUCT = 5000;\n    uint64 constant G_CREATE = 32000;\n    uint64 constant G_CODEDEPOSIT = 200;\n    uint64 constant G_CALL = 700;\n    uint64 constant G_CALLVALUE = 9000;\n    uint64 constant G_CALLSTIPEND = 2300;\n    uint64 constant G_NEWACCOUNT = 25000;\n    uint64 constant G_EXP = 10;\n    uint64 constant G_EXPBYTE = 50;\n    uint64 constant G_MEMORY = 3;\n    uint64 constant G_TXCREATE = 32000;\n    uint64 constant G_TXDATAZERO = 4;\n    uint64 constant G_TXDATANONZERO = 16;\n    uint64 constant G_TRANSACTION = 21000;\n    uint64 constant G_LOG = 375;\n    uint64 constant G_LOGDATA = 8;\n    uint64 constant G_LOGTOPIC = 375;\n    uint64 constant G_KECCAK = 30;\n    uint64 constant G_KECCAKWORD = 6;\n    uint64 constant G_COPY = 3;\n    uint64 constant G_BLOCKHASH = 20;\n    uint64 constant G_QUADDIVISOR = 20;\n\n    // Stack\n    uint64 constant STACK_LIMIT = 1024;\n\n    bytes32 constant EMPTY_TRIE_ROOT = 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421;\n    bytes32 constant EMPTY_CODE_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    bytes32 constant EMPTY_UNCLE_HASH = 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347;\n    uint64 constant RECENT_BLOCK_HASHES_LENGTH = 256;\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"./libraries/VerificationContext.sol\";\n\ninterface IVerifier {\n    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        external\n        pure\n        returns (bytes32);\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/IVerifierEntry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"./libraries/VerificationContext.sol\";\n\ninterface IVerifierEntry {\n    function verifyOneStepProof(\n        VerificationContext.Context memory ctx,\n        uint8 verifier,\n        bytes32 currStateHash,\n        bytes calldata encoded\n    ) external view returns (bytes32);\n}\n"
    },
    "contracts/L1/fraud-proof/libraries/DeserializationLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"./BytesLib.sol\";\n\nlibrary DeserializationLib {\n    function deserializeAddress(bytes memory data, uint256 startOffset) internal pure returns (uint256, address) {\n        return (startOffset + 20, BytesLib.toAddress(data, startOffset));\n    }\n\n    function deserializeUint256(bytes memory data, uint256 startOffset) internal pure returns (uint256, uint256) {\n        require(data.length >= startOffset && data.length - startOffset >= 32, \"too short\");\n        return (startOffset + 32, BytesLib.toUint256(data, startOffset));\n    }\n\n    function deserializeBytes32(bytes memory data, uint256 startOffset) internal pure returns (uint256, bytes32) {\n        require(data.length >= startOffset && data.length - startOffset >= 32, \"too short\");\n        return (startOffset + 32, BytesLib.toBytes32(data, startOffset));\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n * @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for { let cc := add(_postBytes, 0x20) } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } { mstore(mc, mload(cc)) }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } { sstore(sc, mload(mc)) }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } { sstore(sc, mload(mc)) }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toBytes32Pad(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        bytes32 result;\n\n        assembly {\n            result := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        if (_bytes.length < _start + 32) {\n            uint256 pad = 32 + _start - _bytes.length;\n            result = result >> pad << pad;\n        }\n\n        return result;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for { let cc := add(_postBytes, 0x20) }\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/libraries/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary MerkleLib {\n    // Hashes a and b in the order they are passed\n    function hash_node(bytes32 a, bytes32 b) internal pure returns (bytes32 hash) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            hash := keccak256(0x00, 0x40)\n        }\n    }\n\n    // Hashes a and b in order define by boolean\n    function hash_pair(bytes32 a, bytes32 b, bool order) internal pure returns (bytes32 hash) {\n        hash = order ? hash_node(a, b) : hash_node(b, a);\n    }\n\n    // Counts number of set bits (1's) in 32-bit unsigned integer\n    function bit_count_32(uint32 n) internal pure returns (uint32) {\n        n = n - ((n >> 1) & 0x55555555);\n        n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\n        return (((n + (n >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n    }\n\n    // Round 32-bit unsigned integer up to the nearest power of 2\n    function round_up_to_power_of_2(uint32 n) internal pure returns (uint32) {\n        if (bit_count_32(n) == 1) return n;\n\n        n |= n >> 1;\n        n |= n >> 2;\n        n |= n >> 4;\n        n |= n >> 8;\n        n |= n >> 16;\n\n        return n + 1;\n    }\n\n    // Get the Element Merkle Root for a tree with just a single bytes32 element in memory\n    function get_root_from_one(bytes32 element) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(bytes1(0), element));\n    }\n\n    // Get nodes (parent of leafs) from bytes32 elements in memory\n    function get_nodes_from_elements(bytes32[] memory elements) internal pure returns (bytes32[] memory nodes) {\n        uint256 element_count = elements.length;\n        uint256 node_count = (element_count >> 1) + (element_count & 1);\n        nodes = new bytes32[](node_count);\n        uint256 write_index;\n        uint256 left_index;\n\n        while (write_index < node_count) {\n            left_index = write_index << 1;\n\n            if (left_index == element_count - 1) {\n                nodes[write_index] = keccak256(abi.encodePacked(bytes1(0), elements[left_index]));\n                break;\n            }\n\n            nodes[write_index++] = hash_node(\n                keccak256(abi.encodePacked(bytes1(0), elements[left_index])),\n                keccak256(abi.encodePacked(bytes1(0), elements[left_index + 1]))\n            );\n        }\n    }\n\n    // Get the Element Merkle Root given nodes (parent of leafs)\n    function get_root_from_nodes(bytes32[] memory nodes) internal pure returns (bytes32) {\n        uint256 node_count = nodes.length;\n        uint256 write_index;\n        uint256 left_index;\n\n        while (node_count > 1) {\n            left_index = write_index << 1;\n\n            if (left_index == node_count - 1) {\n                nodes[write_index] = nodes[left_index];\n                write_index = 0;\n                node_count = (node_count >> 1) + (node_count & 1);\n                continue;\n            }\n\n            if (left_index >= node_count) {\n                write_index = 0;\n                node_count = (node_count >> 1) + (node_count & 1);\n                continue;\n            }\n\n            nodes[write_index++] = hash_node(nodes[left_index], nodes[left_index + 1]);\n        }\n\n        return nodes[0];\n    }\n\n    // Get the Element Merkle Root for a tree with several bytes32 elements in memory\n    function get_root_from_many(bytes32[] memory elements) internal pure returns (bytes32) {\n        return get_root_from_nodes(get_nodes_from_elements(elements));\n    }\n\n    // Get the original Element Merkle Root, given a Size Proof\n    function get_root_from_size_proof(uint256 element_count, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        uint256 proof_index = bit_count_32(uint32(element_count)) - 1;\n        hash = proof[proof_index];\n\n        while (proof_index > 0) {\n            hash = hash_node(proof[--proof_index], hash);\n        }\n    }\n\n    // Get the original Element Merkle Root, given an index, a leaf, and a Single Proof\n    function get_root_from_leaf_and_single_proof(uint256 index, bytes32 leaf, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        uint256 proof_index = proof.length - 1;\n        uint256 upper_bound = uint256(proof[0]) - 1;\n\n        while (proof_index > 0) {\n            if (index != upper_bound || (index & 1 == 1)) {\n                leaf = (index & 1 == 1) ? hash_node(proof[proof_index], leaf) : hash_node(leaf, proof[proof_index]);\n                proof_index -= 1;\n            }\n\n            index >>= 1;\n            upper_bound >>= 1;\n        }\n\n        return leaf;\n    }\n\n    // Get the original Element Merkle Root, given an index, a bytes32 element, and a Single Proof\n    function get_root_from_single_proof(uint256 index, bytes32 element, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        hash = keccak256(abi.encodePacked(bytes1(0), element));\n        hash = get_root_from_leaf_and_single_proof(index, hash, proof);\n    }\n\n    // Get the original and updated Element Merkle Root, given an index, a leaf, an update leaf, and a Single Proof\n    function get_roots_from_leaf_and_single_proof_update(\n        uint256 index,\n        bytes32 leaf,\n        bytes32 update_leaf,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 scratch, bytes32) {\n        uint256 proof_index = proof.length - 1;\n        uint256 upper_bound = uint256(proof[0]) - 1;\n\n        while (proof_index > 0) {\n            if ((index != upper_bound) || (index & 1 == 1)) {\n                scratch = proof[proof_index];\n                proof_index -= 1;\n                leaf = (index & 1 == 1) ? hash_node(scratch, leaf) : hash_node(leaf, scratch);\n                update_leaf = (index & 1 == 1) ? hash_node(scratch, update_leaf) : hash_node(update_leaf, scratch);\n            }\n\n            index >>= 1;\n            upper_bound >>= 1;\n        }\n\n        return (leaf, update_leaf);\n    }\n\n    // Get the original and updated Element Merkle Root, given an index, a bytes32 element, a bytes32 update element, and a Single Proof\n    function get_roots_from_single_proof_update(\n        uint256 index,\n        bytes32 element,\n        bytes32 update_element,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 hash, bytes32 update_hash) {\n        hash = keccak256(abi.encodePacked(bytes1(0), element));\n        update_hash = keccak256(abi.encodePacked(bytes1(0), update_element));\n        return get_roots_from_leaf_and_single_proof_update(index, hash, update_hash, proof);\n    }\n\n    // Get the indices of the elements being proven, given an Existence Multi Proof\n    function get_indices_from_multi_proof(uint256 element_count, bytes32 flags, bytes32 skips, bytes32 orders)\n        internal\n        pure\n        returns (uint256[] memory indices)\n    {\n        indices = new uint256[](element_count);\n        uint256[] memory bits_pushed = new uint256[](element_count);\n        bool[] memory grouped_with_next = new bool[](element_count);\n        element_count -= 1;\n        uint256 index = element_count;\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\n        bytes32 flag;\n        bytes32 skip;\n        bytes32 order;\n        uint256 bits_to_push;\n\n        while (true) {\n            flag = flags & bit_check;\n            skip = skips & bit_check;\n            order = orders & bit_check;\n            bits_to_push = 1 << bits_pushed[index];\n\n            if (skip == bit_check) {\n                if (flag == bit_check) return indices;\n\n                while (true) {\n                    bits_pushed[index]++;\n\n                    if (index == 0) {\n                        index = element_count;\n                        break;\n                    }\n\n                    if (!grouped_with_next[index--]) break;\n                }\n\n                bit_check <<= 1;\n                continue;\n            }\n\n            if (flag == bit_check) {\n                while (true) {\n                    if (order == bit_check) {\n                        indices[index] |= bits_to_push;\n                    }\n\n                    bits_pushed[index]++;\n\n                    if (index == 0) {\n                        index = element_count;\n                        break;\n                    }\n\n                    if (!grouped_with_next[index]) {\n                        grouped_with_next[index--] = true;\n                        break;\n                    }\n\n                    grouped_with_next[index--] = true;\n                }\n            }\n\n            while (true) {\n                if (order != bit_check) {\n                    indices[index] |= bits_to_push;\n                }\n\n                bits_pushed[index]++;\n\n                if (index == 0) {\n                    index = element_count;\n                    break;\n                }\n\n                if (!grouped_with_next[index--]) break;\n            }\n\n            bit_check <<= 1;\n        }\n    }\n\n    // Get leafs from bytes32 elements in memory, in reverse order\n    function get_reversed_leafs_from_elements(bytes32[] memory elements)\n        internal\n        pure\n        returns (bytes32[] memory leafs)\n    {\n        uint256 element_count = elements.length;\n        leafs = new bytes32[](element_count);\n        // uint256 read_index = element_count - 1;\n        // uint256 write_index;\n\n        for (uint64 i = 0; i < element_count; i++) {\n            leafs[i] = keccak256(abi.encodePacked(bytes1(0), elements[element_count - 1 - i]));\n        }\n\n        // while (write_index < element_count) {\n        //     leafs[write_index] = keccak256(abi.encodePacked(bytes1(0), elements[read_index]));\n        //     write_index += 1;\n        //     read_index -= 1;\n        // }\n    }\n\n    // Get the original Element Merkle Root, given leafs and an Existence Multi Proof\n    function get_root_from_leafs_and_multi_proof(bytes32[] memory leafs, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 right)\n    {\n        uint256 leaf_count = leafs.length;\n        uint256 read_index;\n        uint256 write_index;\n        uint256 proof_index = 4;\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\n        bytes32 flags = proof[1];\n        bytes32 skips = proof[2];\n        bytes32 orders = proof[3];\n\n        while (true) {\n            if (skips & bit_check == bit_check) {\n                if (flags & bit_check == bit_check) return leafs[(write_index == 0 ? leaf_count : write_index) - 1];\n\n                leafs[write_index] = leafs[read_index];\n\n                read_index = (read_index + 1) % leaf_count;\n                write_index = (write_index + 1) % leaf_count;\n                bit_check <<= 1;\n                continue;\n            }\n\n            right = (flags & bit_check == bit_check) ? leafs[read_index++] : proof[proof_index++];\n\n            read_index %= leaf_count;\n\n            leafs[write_index] = hash_pair(leafs[read_index], right, orders & bit_check == bit_check);\n\n            read_index = (read_index + 1) % leaf_count;\n            write_index = (write_index + 1) % leaf_count;\n            bit_check <<= 1;\n        }\n    }\n\n    // Get the original Element Merkle Root, given bytes32 memory in memory and an Existence Multi Proof\n    function get_root_from_multi_proof(bytes32[] memory elements, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return get_root_from_leafs_and_multi_proof(get_reversed_leafs_from_elements(elements), proof);\n    }\n\n    // Get current and update leafs from current bytes32 elements in memory and update bytes32 elements in memory, in reverse order\n    function get_reversed_leafs_from_current_and_update_elements(\n        bytes32[] memory elements,\n        bytes32[] memory update_elements\n    ) internal pure returns (bytes32[] memory leafs, bytes32[] memory update_leafs) {\n        uint256 element_count = elements.length;\n        require(update_elements.length == element_count, \"LENGTH_MISMATCH\");\n\n        leafs = new bytes32[](element_count);\n        update_leafs = new bytes32[](element_count);\n        // uint256 read_index = element_count - 1;\n        // uint256 write_index;\n\n        // while (write_index < element_count) {\n        //     leafs[write_index] = keccak256(abi.encodePacked(bytes1(0), elements[read_index]));\n        //     update_leafs[write_index] = keccak256(abi.encodePacked(bytes1(0), update_elements[read_index]));\n        //     write_index += 1;\n        //     read_index -= 1;\n        // }\n\n        for (uint64 i = 0; i < element_count; i++) {\n            leafs[i] = keccak256(abi.encodePacked(bytes1(0), elements[element_count - 1 - i]));\n            update_leafs[i] = keccak256(abi.encodePacked(bytes1(0), update_elements[element_count - 1 - i]));\n        }\n    }\n\n    // Get the original and updated Element Merkle Root, given leafs, update leafs, and an Existence Multi Proof\n    function get_roots_from_leafs_and_multi_proof_update(\n        bytes32[] memory leafs,\n        bytes32[] memory update_leafs,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 flags, bytes32 skips) {\n        uint256 leaf_count = update_leafs.length;\n        uint256 read_index;\n        uint256 write_index;\n        uint256 proof_index = 4;\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\n        flags = proof[1];\n        skips = proof[2];\n        bytes32 orders = proof[3];\n        bytes32 scratch;\n        uint256 scratch_2;\n\n        while (true) {\n            if (skips & bit_check == bit_check) {\n                if (flags & bit_check == bit_check) {\n                    read_index = (write_index == 0 ? leaf_count : write_index) - 1;\n\n                    return (leafs[read_index], update_leafs[read_index]);\n                }\n\n                leafs[write_index] = leafs[read_index];\n                update_leafs[write_index] = update_leafs[read_index];\n\n                read_index = (read_index + 1) % leaf_count;\n                write_index = (write_index + 1) % leaf_count;\n                bit_check <<= 1;\n                continue;\n            }\n\n            if (flags & bit_check == bit_check) {\n                scratch_2 = (read_index + 1) % leaf_count;\n\n                leafs[write_index] = hash_pair(leafs[scratch_2], leafs[read_index], orders & bit_check == bit_check);\n                update_leafs[write_index] =\n                    hash_pair(update_leafs[scratch_2], update_leafs[read_index], orders & bit_check == bit_check);\n\n                read_index += 2;\n            } else {\n                scratch = proof[proof_index++];\n\n                leafs[write_index] = hash_pair(leafs[read_index], scratch, orders & bit_check == bit_check);\n                update_leafs[write_index] =\n                    hash_pair(update_leafs[read_index], scratch, orders & bit_check == bit_check);\n\n                read_index += 1;\n            }\n\n            read_index %= leaf_count;\n            write_index = (write_index + 1) % leaf_count;\n            bit_check <<= 1;\n        }\n    }\n\n    // Get the original and updated Element Merkle Root,\n    // given bytes32 elements in memory, bytes32 update elements in memory, and an Existence Multi Proof\n    function get_roots_from_multi_proof_update(\n        bytes32[] memory elements,\n        bytes32[] memory update_elements,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32, bytes32) {\n        (bytes32[] memory leafs, bytes32[] memory update_leafs) =\n            get_reversed_leafs_from_current_and_update_elements(elements, update_elements);\n        return get_roots_from_leafs_and_multi_proof_update(leafs, update_leafs, proof);\n    }\n\n    // Get the original Element Merkle Root, given an Append Proof\n    function get_root_from_append_proof(bytes32[] memory proof) internal pure returns (bytes32 hash) {\n        uint256 proof_index = bit_count_32(uint32(uint256(proof[0])));\n        hash = proof[proof_index];\n\n        while (proof_index > 1) {\n            proof_index -= 1;\n            hash = hash_node(proof[proof_index], hash);\n        }\n    }\n\n    // Get the original and updated Element Merkle Root, given append leaf and an Append Proof\n    function get_roots_from_leaf_and_append_proof_single_append(bytes32 append_leaf, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 hash, bytes32 scratch)\n    {\n        uint256 proof_index = bit_count_32(uint32(uint256(proof[0])));\n        hash = proof[proof_index];\n        append_leaf = hash_node(hash, append_leaf);\n\n        while (proof_index > 1) {\n            proof_index -= 1;\n            scratch = proof[proof_index];\n            append_leaf = hash_node(scratch, append_leaf);\n            hash = hash_node(scratch, hash);\n        }\n\n        return (hash, append_leaf);\n    }\n\n    // Get the original and updated Element Merkle Root, given a bytes32 append element in memory and an Append Proof\n    function get_roots_from_append_proof_single_append(bytes32 append_element, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 append_leaf, bytes32)\n    {\n        append_leaf = keccak256(abi.encodePacked(bytes1(0), append_element));\n        return get_roots_from_leaf_and_append_proof_single_append(append_leaf, proof);\n    }\n\n    // Get leafs from bytes32 elements in memory\n    function get_leafs_from_elements(bytes32[] memory elements) internal pure returns (bytes32[] memory leafs) {\n        uint256 element_count = elements.length;\n        leafs = new bytes32[](element_count);\n\n        while (element_count > 0) {\n            element_count -= 1;\n            leafs[element_count] = keccak256(abi.encodePacked(bytes1(0), elements[element_count]));\n        }\n    }\n\n    // Get the original and updated Element Merkle Root, given append leafs and an Append Proof\n    function get_roots_from_leafs_and_append_proof_multi_append(bytes32[] memory append_leafs, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 hash, bytes32)\n    {\n        uint256 leaf_count = append_leafs.length;\n        uint256 write_index;\n        uint256 read_index;\n        uint256 offset = uint256(proof[0]);\n        uint256 index = offset;\n\n        // reuse leaf_count variable as upper_bound, since leaf_count no longer needed\n        leaf_count += offset;\n        leaf_count -= 1;\n        uint256 proof_index = bit_count_32(uint32(offset));\n        hash = proof[proof_index];\n\n        while (leaf_count > 0) {\n            if ((write_index == 0) && (index & 1 == 1)) {\n                append_leafs[0] = hash_node(proof[proof_index], append_leafs[read_index]);\n                proof_index -= 1;\n                read_index += 1;\n\n                if (proof_index > 0) {\n                    hash = hash_node(proof[proof_index], hash);\n                }\n\n                write_index = 1;\n                index += 1;\n            } else if (index < leaf_count) {\n                append_leafs[write_index++] = hash_node(append_leafs[read_index++], append_leafs[read_index]);\n                read_index += 1;\n                index += 2;\n            }\n\n            if (index >= leaf_count) {\n                if (index == leaf_count) {\n                    append_leafs[write_index] = append_leafs[read_index];\n                }\n\n                read_index = 0;\n                write_index = 0;\n                leaf_count >>= 1;\n                offset >>= 1;\n                index = offset;\n            }\n        }\n\n        return (hash, append_leafs[0]);\n    }\n\n    // Get the original and updated Element Merkle Root, given bytes32 append elements in memory and an Append Proof\n    function get_roots_from_append_proof_multi_append(bytes32[] memory append_elements, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32, bytes32)\n    {\n        return get_roots_from_leafs_and_append_proof_multi_append(get_leafs_from_elements(append_elements), proof);\n    }\n\n    // Get the updated Element Merkle Root, given an append leaf and an Append Proof\n    function get_new_root_from_leafs_and_append_proof_single_append(bytes32 append_leaf, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 append_hash)\n    {\n        uint256 proof_index = bit_count_32(uint32(uint256(proof[0])));\n        append_hash = hash_node(proof[proof_index], append_leaf);\n\n        while (proof_index > 1) {\n            proof_index -= 1;\n            append_hash = hash_node(proof[proof_index], append_hash);\n        }\n    }\n\n    // Get the updated Element Merkle Root, given a bytes32 append elements in memory and an Append Proof\n    function get_new_root_from_append_proof_single_append(bytes32 append_element, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 append_leaf)\n    {\n        append_leaf = keccak256(abi.encodePacked(bytes1(0), append_element));\n        return get_new_root_from_leafs_and_append_proof_single_append(append_leaf, proof);\n    }\n\n    // Get the updated Element Merkle Root, given append leafs and an Append Proof\n    function get_new_root_from_leafs_and_append_proof_multi_append(\n        bytes32[] memory append_leafs,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32) {\n        uint256 leaf_count = append_leafs.length;\n        uint256 write_index;\n        uint256 read_index;\n        uint256 offset = uint256(proof[0]);\n        uint256 index = offset;\n\n        // reuse leaf_count variable as upper_bound, since leaf_count no longer needed\n        leaf_count += offset;\n        leaf_count -= 1;\n        uint256 proof_index = proof.length - 1;\n\n        while (leaf_count > 0) {\n            if ((write_index == 0) && (index & 1 == 1)) {\n                append_leafs[0] = hash_node(proof[proof_index], append_leafs[read_index]);\n\n                read_index += 1;\n                proof_index -= 1;\n                write_index = 1;\n                index += 1;\n            } else if (index < leaf_count) {\n                append_leafs[write_index++] = hash_node(append_leafs[read_index++], append_leafs[read_index++]);\n\n                index += 2;\n            }\n\n            if (index >= leaf_count) {\n                if (index == leaf_count) {\n                    append_leafs[write_index] = append_leafs[read_index];\n                }\n\n                read_index = 0;\n                write_index = 0;\n                leaf_count >>= 1;\n                offset >>= 1;\n                index = offset;\n            }\n        }\n\n        return append_leafs[0];\n    }\n\n    // Get the updated Element Merkle Root, given bytes32 append elements in memory and an Append Proof\n    function get_new_root_from_append_proof_multi_append(bytes32[] memory append_elements, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return get_new_root_from_leafs_and_append_proof_multi_append(get_leafs_from_elements(append_elements), proof);\n    }\n\n    // Get the original Element Merkle Root and derive Append Proof, given an index, an append leaf, and a Single Proof\n    function get_append_proof_from_leaf_and_single_proof(uint256 index, bytes32 leaf, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 append_hash, bytes32[] memory append_proof)\n    {\n        uint256 proof_index = proof.length - 1;\n        uint256 append_node_index = uint256(proof[0]);\n        uint256 upper_bound = append_node_index - 1;\n        uint256 append_proof_index = bit_count_32(uint32(append_node_index)) + 1;\n        append_proof = new bytes32[](append_proof_index);\n        append_proof[0] = bytes32(append_node_index);\n        bytes32 scratch;\n\n        while (proof_index > 0) {\n            if (index != upper_bound || (index & 1 == 1)) {\n                scratch = proof[proof_index];\n\n                leaf = (index & 1 == 1) ? hash_node(scratch, leaf) : hash_node(leaf, scratch);\n\n                if (append_node_index & 1 == 1) {\n                    append_proof_index -= 1;\n                    append_proof[append_proof_index] = scratch;\n                    append_hash = hash_node(scratch, append_hash);\n                }\n\n                proof_index -= 1;\n            } else if (append_node_index & 1 == 1) {\n                append_proof_index -= 1;\n                append_proof[append_proof_index] = leaf;\n                append_hash = leaf;\n            }\n\n            index >>= 1;\n            upper_bound >>= 1;\n            append_node_index >>= 1;\n        }\n\n        require(append_proof_index == 2 || append_hash == leaf, \"INVALID_PROOF\");\n\n        if (append_proof_index == 2) {\n            append_proof[1] = leaf;\n        }\n    }\n\n    // Get the original Element Merkle Root and derive Append Proof, given an index, a bytes32 element, and a Single Proof\n    function get_append_proof_from_single_proof(uint256 index, bytes32 element, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 leaf, bytes32[] memory)\n    {\n        leaf = keccak256(abi.encodePacked(bytes1(0), element));\n        return get_append_proof_from_leaf_and_single_proof(index, leaf, proof);\n    }\n\n    // Get the original Element Merkle Root and derive Append Proof, given an index, a leaf, an update leaf, and a Single Proof\n    function get_append_proof_from_leaf_and_single_proof_update(\n        uint256 index,\n        bytes32 leaf,\n        bytes32 update_leaf,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 append_hash, bytes32[] memory append_proof) {\n        uint256 proof_index = proof.length - 1;\n        uint256 append_node_index = uint256(proof[0]);\n        uint256 upper_bound = append_node_index - 1;\n        uint256 append_proof_index = bit_count_32(uint32(append_node_index)) + 1;\n        append_proof = new bytes32[](append_proof_index);\n        append_proof[0] = bytes32(append_node_index);\n        bytes32 scratch;\n\n        while (proof_index > 0) {\n            if (index != upper_bound || (index & 1 == 1)) {\n                scratch = proof[proof_index];\n\n                leaf = (index & 1 == 1) ? hash_node(scratch, leaf) : hash_node(leaf, scratch);\n\n                update_leaf = (index & 1 == 1) ? hash_node(scratch, update_leaf) : hash_node(update_leaf, scratch);\n\n                if (append_node_index & 1 == 1) {\n                    append_proof_index -= 1;\n                    append_proof[append_proof_index] = scratch;\n                    append_hash = hash_node(scratch, append_hash);\n                }\n\n                proof_index -= 1;\n            } else if (append_node_index & 1 == 1) {\n                append_proof_index -= 1;\n                append_proof[append_proof_index] = update_leaf;\n                append_hash = leaf;\n            }\n\n            index >>= 1;\n            upper_bound >>= 1;\n            append_node_index >>= 1;\n        }\n\n        require(append_proof_index == 2 || append_hash == leaf, \"INVALID_PROOF\");\n\n        if (append_proof_index == 2) {\n            append_proof[1] = update_leaf;\n        }\n    }\n\n    // Get the original Element Merkle Root and derive Append Proof,\n    // given an index, a bytes32 element, a bytes32 update element, and a Single Proof\n    function get_append_proof_from_single_proof_update(\n        uint256 index,\n        bytes32 element,\n        bytes32 update_element,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 leaf, bytes32[] memory) {\n        leaf = keccak256(abi.encodePacked(bytes1(0), element));\n        bytes32 update_leaf = keccak256(abi.encodePacked(bytes1(0), update_element));\n        return get_append_proof_from_leaf_and_single_proof_update(index, leaf, update_leaf, proof);\n    }\n\n    // Hashes leaf at read index and next index (circular) to write index\n    function hash_within_leafs(\n        bytes32[] memory leafs,\n        uint256 write_index,\n        uint256 read_index,\n        uint256 leaf_count,\n        bool order\n    ) internal pure {\n        leafs[write_index] = order\n            ? hash_node(leafs[(read_index + 1) % leaf_count], leafs[read_index])\n            : hash_node(leafs[read_index], leafs[(read_index + 1) % leaf_count]);\n    }\n\n    // Hashes value with leaf at read index to write index\n    function hash_with_leafs(bytes32[] memory leafs, bytes32 value, uint256 write_index, uint256 read_index, bool order)\n        internal\n        pure\n    {\n        leafs[write_index] = order ? hash_node(leafs[read_index], value) : hash_node(value, leafs[read_index]);\n    }\n\n    // Get the original Element Merkle Root and derive Append Proof, given leafs and an Existence Multi Proof\n    function get_append_proof_from_leafs_and_multi_proof(bytes32[] memory leafs, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 append_hash, bytes32[] memory append_proof)\n    {\n        uint256 leaf_count = leafs.length;\n        uint256 read_index;\n        uint256 write_index;\n        uint256 proof_index = 4;\n        uint256 append_node_index = uint256(proof[0]);\n        uint256 append_proof_index = uint256(bit_count_32(uint32(append_node_index))) + 1;\n        append_proof = new bytes32[](append_proof_index);\n        append_proof[0] = bytes32(append_node_index);\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\n        bytes32 skips = proof[2];\n        uint256 read_index_of_append_node;\n        bool scratch;\n\n        while (true) {\n            if (skips & bit_check == bit_check) {\n                if (proof[1] & bit_check == bit_check) {\n                    read_index = (write_index == 0 ? leaf_count : write_index) - 1;\n\n                    // reuse bit_check as scratch variable\n                    bit_check = leafs[read_index];\n\n                    require(append_proof_index == 2 || append_hash == bit_check, \"INVALID_PROOF\");\n\n                    if (append_proof_index == 2) {\n                        append_proof[1] = bit_check;\n                    }\n\n                    return (append_hash, append_proof);\n                }\n\n                if (append_node_index & 1 == 1) {\n                    append_proof_index -= 1;\n                    append_hash = leafs[read_index]; // TODO scratch this leafs[read_index] above\n                    append_proof[append_proof_index] = leafs[read_index];\n                }\n\n                read_index_of_append_node = write_index;\n                append_node_index >>= 1;\n\n                leafs[write_index] = leafs[read_index];\n\n                read_index = (read_index + 1) % leaf_count;\n                write_index = (write_index + 1) % leaf_count;\n                bit_check <<= 1;\n                continue;\n            }\n\n            scratch = proof[1] & bit_check == bit_check;\n\n            if (read_index_of_append_node == read_index) {\n                if (append_node_index & 1 == 1) {\n                    append_proof_index -= 1;\n\n                    if (scratch) {\n                        // reuse read_index_of_append_node as temporary scratch variable\n                        read_index_of_append_node = (read_index + 1) % leaf_count;\n\n                        append_hash = hash_node(leafs[read_index_of_append_node], append_hash);\n                        append_proof[append_proof_index] = leafs[read_index_of_append_node];\n                    } else {\n                        append_hash = hash_node(proof[proof_index], append_hash);\n                        append_proof[append_proof_index] = proof[proof_index];\n                    }\n                }\n\n                read_index_of_append_node = write_index;\n                append_node_index >>= 1;\n            }\n\n            if (scratch) {\n                scratch = proof[3] & bit_check == bit_check;\n                hash_within_leafs(leafs, write_index, read_index, leaf_count, scratch);\n                read_index += 2;\n            } else {\n                scratch = proof[3] & bit_check == bit_check;\n                hash_with_leafs(leafs, proof[proof_index], write_index, read_index, scratch);\n                proof_index += 1;\n                read_index += 1;\n            }\n\n            read_index %= leaf_count;\n            write_index = (write_index + 1) % leaf_count;\n            bit_check <<= 1;\n        }\n    }\n\n    // Get the original Element Merkle Root and derive Append Proof, given bytes32 elements in memory and an Existence Multi Proof\n    function get_append_proof_from_multi_proof(bytes32[] memory elements, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32, bytes32[] memory)\n    {\n        return get_append_proof_from_leafs_and_multi_proof(get_reversed_leafs_from_elements(elements), proof);\n    }\n\n    // Get combined current and update leafs from current bytes32 elements in memory and update bytes32 elements in memory, in reverse order\n    function get_reversed_combined_leafs_from_current_and_update_elements(\n        bytes32[] memory elements,\n        bytes32[] memory update_elements\n    ) internal pure returns (bytes32[] memory combined_leafs) {\n        uint256 element_count = elements.length;\n        require(update_elements.length == element_count, \"LENGTH_MISMATCH\");\n\n        combined_leafs = new bytes32[](element_count << 1);\n        // uint256 read_index = element_count - 1;\n        // uint256 write_index;\n\n        // while (write_index < element_count) {\n        //     combined_leafs[write_index] = keccak256(abi.encodePacked(bytes1(0), elements[read_index]));\n        //     combined_leafs[element_count + write_index] =\n        //         keccak256(abi.encodePacked(bytes1(0), update_elements[read_index]));\n        //     write_index += 1;\n        //     read_index -= 1;\n        // }\n\n        for (uint64 i = 0; i < element_count; i++) {\n            combined_leafs[i] = keccak256(abi.encodePacked(bytes1(0), elements[element_count - 1 - i]));\n            combined_leafs[element_count + i] =\n                keccak256(abi.encodePacked(bytes1(0), update_elements[element_count - 1 - i]));\n        }\n    }\n\n    // Copy leaf and update leaf at read indices and to write indices\n    function copy_within_combined_leafs(\n        bytes32[] memory combined_leafs,\n        uint256 write_index,\n        uint256 read_index,\n        uint256 leaf_count\n    ) internal pure {\n        combined_leafs[write_index] = combined_leafs[read_index];\n        combined_leafs[leaf_count + write_index] = combined_leafs[leaf_count + read_index];\n    }\n\n    // Hashes leaf and update leaf at read indices and next indices (circular) to write indices\n    function hash_within_combined_leafs(\n        bytes32[] memory combined_leafs,\n        uint256 write_index,\n        uint256 read_index,\n        uint256 leaf_count,\n        bool order\n    ) internal pure {\n        uint256 scratch = (read_index + 1) % leaf_count;\n\n        combined_leafs[write_index] = order\n            ? hash_node(combined_leafs[scratch], combined_leafs[read_index])\n            : hash_node(combined_leafs[read_index], combined_leafs[scratch]);\n\n        combined_leafs[leaf_count + write_index] = order\n            ? hash_node(combined_leafs[leaf_count + scratch], combined_leafs[leaf_count + read_index])\n            : hash_node(combined_leafs[leaf_count + read_index], combined_leafs[leaf_count + scratch]);\n    }\n\n    // Hashes value with leaf and update leaf at read indices to write indices\n    function hash_with_combined_leafs(\n        bytes32[] memory combined_leafs,\n        bytes32 value,\n        uint256 write_index,\n        uint256 read_index,\n        uint256 leaf_count,\n        bool order\n    ) internal pure {\n        combined_leafs[write_index] =\n            order ? hash_node(combined_leafs[read_index], value) : hash_node(value, combined_leafs[read_index]);\n\n        combined_leafs[leaf_count + write_index] = order\n            ? hash_node(combined_leafs[leaf_count + read_index], value)\n            : hash_node(value, combined_leafs[leaf_count + read_index]);\n    }\n\n    // Get the original Element Merkle Root and derive Append Proof, given combined leafs and update leafs and an Existence Multi Proof\n    function get_append_proof_from_leafs_and_multi_proof_update(bytes32[] memory combined_leafs, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 append_hash, bytes32[] memory append_proof)\n    {\n        uint256 leaf_count = combined_leafs.length >> 1;\n        uint256 read_index;\n        uint256 write_index;\n        uint256 read_index_of_append_node;\n        uint256 proof_index = 4;\n        uint256 append_node_index = uint256(proof[0]);\n        uint256 append_proof_index = bit_count_32(uint32(append_node_index)) + 1;\n        append_proof = new bytes32[](append_proof_index);\n        append_proof[0] = bytes32(append_node_index);\n        bytes32 bit_check = 0x0000000000000000000000000000000000000000000000000000000000000001;\n        bool scratch;\n\n        while (true) {\n            if (proof[2] & bit_check == bit_check) {\n                if (proof[1] & bit_check == bit_check) {\n                    read_index = (write_index == 0 ? leaf_count : write_index) - 1;\n\n                    // reuse bit_check as scratch variable\n                    bit_check = combined_leafs[read_index];\n\n                    require(append_proof_index == 2 || append_hash == bit_check, \"INVALID_PROOF\");\n\n                    if (append_proof_index == 2) {\n                        append_proof[1] = combined_leafs[leaf_count + read_index];\n                    }\n\n                    return (bit_check, append_proof);\n                }\n\n                if (append_node_index & 1 == 1) {\n                    append_proof_index -= 1;\n                    append_hash = combined_leafs[read_index];\n                    append_proof[append_proof_index] = combined_leafs[leaf_count + read_index];\n                }\n\n                read_index_of_append_node = write_index;\n                append_node_index >>= 1;\n\n                copy_within_combined_leafs(combined_leafs, write_index, read_index, leaf_count);\n\n                read_index = (read_index + 1) % leaf_count;\n                write_index = (write_index + 1) % leaf_count;\n                bit_check <<= 1;\n                continue;\n            }\n\n            scratch = proof[1] & bit_check == bit_check;\n\n            if (read_index_of_append_node == read_index) {\n                if (append_node_index & 1 == 1) {\n                    append_proof_index -= 1;\n\n                    if (scratch) {\n                        // use read_index_of_append_node as temporary scratch\n                        read_index_of_append_node = (read_index + 1) % leaf_count;\n\n                        append_hash = hash_node(combined_leafs[read_index_of_append_node], append_hash);\n                        append_proof[append_proof_index] = combined_leafs[leaf_count + read_index_of_append_node];\n                    } else {\n                        append_hash = hash_node(proof[proof_index], append_hash);\n                        append_proof[append_proof_index] = proof[proof_index];\n                    }\n                }\n\n                read_index_of_append_node = write_index;\n                append_node_index >>= 1;\n            }\n\n            if (scratch) {\n                scratch = proof[3] & bit_check == bit_check;\n\n                hash_within_combined_leafs(combined_leafs, write_index, read_index, leaf_count, scratch);\n\n                read_index += 2;\n            } else {\n                scratch = proof[3] & bit_check == bit_check;\n\n                hash_with_combined_leafs(\n                    combined_leafs, proof[proof_index], write_index, read_index, leaf_count, scratch\n                );\n\n                proof_index += 1;\n                read_index += 1;\n            }\n\n            read_index %= leaf_count;\n            write_index = (write_index + 1) % leaf_count;\n            bit_check <<= 1;\n        }\n    }\n\n    // Get the original Element Merkle Root and derive Append Proof,\n    // given bytes32 elements in memory, bytes32 update elements in memory, and an Existence Multi Proof\n    function get_append_proof_from_multi_proof_update(\n        bytes32[] memory elements,\n        bytes32[] memory update_elements,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32, bytes32[] memory) {\n        return get_append_proof_from_leafs_and_multi_proof_update(\n            get_reversed_combined_leafs_from_current_and_update_elements(elements, update_elements), proof\n        );\n    }\n\n    // INTERFACE: Check if bytes32 element exists at index, given a root and a Single Proof\n    function element_exists(bytes32 root, uint256 index, bytes32 element, bytes32[] memory proof)\n        internal\n        pure\n        returns (bool)\n    {\n        return hash_node(proof[0], get_root_from_single_proof(index, element, proof)) == root;\n    }\n\n    // INTERFACE: Check if bytes32 elements in memory exist, given a root and a Single Proof\n    function elements_exist(bytes32 root, bytes32[] memory elements, bytes32[] memory proof)\n        internal\n        pure\n        returns (bool)\n    {\n        return hash_node(proof[0], get_root_from_multi_proof(elements, proof)) == root;\n    }\n\n    // INTERFACE: Get the indices of the bytes32 elements in memory, given an Existence Multi Proof\n    function get_indices(bytes32[] memory elements, bytes32[] memory proof) internal pure returns (uint256[] memory) {\n        return get_indices_from_multi_proof(elements.length, proof[1], proof[2], proof[3]);\n    }\n\n    // INTERFACE: Check tree size, given a Size Proof\n    function verify_size_with_proof(bytes32 root, uint256 size, bytes32[] memory proof) internal pure returns (bool) {\n        if (root == bytes32(0) && size == 0) return true;\n\n        return hash_node(bytes32(size), get_root_from_size_proof(size, proof)) == root;\n    }\n\n    // INTERFACE: Check tree size, given a the Element Merkle Root\n    function verify_size(bytes32 root, uint256 size, bytes32 element_root) internal pure returns (bool) {\n        if (root == bytes32(0) && size == 0) return true;\n\n        return hash_node(bytes32(size), element_root) == root;\n    }\n\n    // INTERFACE: Try to update a bytes32 element, given a root, and index, an bytes32 element, and a Single Proof\n    function try_update_one(\n        bytes32 root,\n        uint256 index,\n        bytes32 element,\n        bytes32 update_element,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 new_element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32 old_element_root;\n        (old_element_root, new_element_root) = get_roots_from_single_proof_update(index, element, update_element, proof);\n\n        require(hash_node(total_element_count, old_element_root) == root, \"INVALID_PROOF\");\n\n        return hash_node(total_element_count, new_element_root);\n    }\n\n    // INTERFACE: Try to update bytes32 elements in memory, given a root, bytes32 elements in memory, and an Existence Multi Proof\n    function try_update_many(\n        bytes32 root,\n        bytes32[] memory elements,\n        bytes32[] memory update_elements,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 new_element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32 old_element_root;\n        (old_element_root, new_element_root) = get_roots_from_multi_proof_update(elements, update_elements, proof);\n\n        require(hash_node(total_element_count, old_element_root) == root, \"INVALID_PROOF\");\n\n        return hash_node(total_element_count, new_element_root);\n    }\n\n    // INTERFACE: Try to append a bytes32 element, given a root and an Append Proof\n    function try_append_one(bytes32 root, bytes32 append_element, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 new_element_root)\n    {\n        bytes32 total_element_count = proof[0];\n\n        require((root == bytes32(0)) == (total_element_count == bytes32(0)), \"INVALID_TREE\");\n\n        if (root == bytes32(0)) return hash_node(bytes32(uint256(1)), get_root_from_one(append_element));\n\n        bytes32 old_element_root;\n        (old_element_root, new_element_root) = get_roots_from_append_proof_single_append(append_element, proof);\n\n        require(hash_node(total_element_count, old_element_root) == root, \"INVALID_PROOF\");\n\n        return hash_node(bytes32(uint256(total_element_count) + 1), new_element_root);\n    }\n\n    // INTERFACE: Try to append bytes32 elements in memory, given a root and an Append Proof\n    function try_append_many(bytes32 root, bytes32[] memory append_elements, bytes32[] memory proof)\n        internal\n        pure\n        returns (bytes32 new_element_root)\n    {\n        bytes32 total_element_count = proof[0];\n\n        require((root == bytes32(0)) == (total_element_count == bytes32(0)), \"INVALID_TREE\");\n\n        if (root == bytes32(0)) {\n            return hash_node(bytes32(append_elements.length), get_root_from_many(append_elements));\n        }\n\n        bytes32 old_element_root;\n        (old_element_root, new_element_root) = get_roots_from_append_proof_multi_append(append_elements, proof);\n\n        require(hash_node(total_element_count, old_element_root) == root, \"INVALID_PROOF\");\n\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), new_element_root);\n    }\n\n    // INTERFACE: Try to append a bytes32 element, given a root, an index, a bytes32 element, and a Single Proof\n    function try_append_one_using_one(\n        bytes32 root,\n        uint256 index,\n        bytes32 element,\n        bytes32 append_element,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32[] memory append_proof;\n        (element_root, append_proof) = get_append_proof_from_single_proof(index, element, proof);\n\n        require(hash_node(total_element_count, element_root) == root, \"INVALID_PROOF\");\n\n        element_root = get_new_root_from_append_proof_single_append(append_element, append_proof);\n\n        return hash_node(bytes32(uint256(total_element_count) + 1), element_root);\n    }\n\n    // INTERFACE: Try to append bytes32 elements in memory, given a root, an index, a bytes32 element, and a Single Proof\n    function try_append_many_using_one(\n        bytes32 root,\n        uint256 index,\n        bytes32 element,\n        bytes32[] memory append_elements,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32[] memory append_proof;\n        (element_root, append_proof) = get_append_proof_from_single_proof(index, element, proof);\n\n        require(hash_node(total_element_count, element_root) == root, \"INVALID_PROOF\");\n\n        element_root = get_new_root_from_append_proof_multi_append(append_elements, append_proof);\n\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), element_root);\n    }\n\n    // INTERFACE: Try to append a bytes32 element, given a root, bytes32 elements in memory, and an Existence Multi Proof\n    function try_append_one_using_many(\n        bytes32 root,\n        bytes32[] memory elements,\n        bytes32 append_element,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32[] memory append_proof;\n        (element_root, append_proof) = get_append_proof_from_multi_proof(elements, proof);\n\n        require(hash_node(total_element_count, element_root) == root, \"INVALID_PROOF\");\n\n        element_root = get_new_root_from_append_proof_single_append(append_element, append_proof);\n\n        return hash_node(bytes32(uint256(total_element_count) + 1), element_root);\n    }\n\n    // INTERFACE: Try to append bytes32 elements in memory, given a root, bytes32 elements in memory, and an Existence Multi Proof\n    function try_append_many_using_many(\n        bytes32 root,\n        bytes32[] memory elements,\n        bytes32[] memory append_elements,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32[] memory append_proof;\n        (element_root, append_proof) = get_append_proof_from_multi_proof(elements, proof);\n\n        require(hash_node(total_element_count, element_root) == root, \"INVALID_PROOF\");\n\n        element_root = get_new_root_from_append_proof_multi_append(append_elements, append_proof);\n\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), element_root);\n    }\n\n    // INTERFACE: Try to update a bytes32 element and append a bytes32 element,\n    // given a root, an index, a bytes32 element, and a Single Proof\n    function try_update_one_and_append_one(\n        bytes32 root,\n        uint256 index,\n        bytes32 element,\n        bytes32 update_element,\n        bytes32 append_element,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32[] memory append_proof;\n        (element_root, append_proof) = get_append_proof_from_single_proof_update(index, element, update_element, proof);\n\n        require(hash_node(total_element_count, element_root) == root, \"INVALID_PROOF\");\n\n        element_root = get_new_root_from_append_proof_single_append(append_element, append_proof);\n\n        return hash_node(bytes32(uint256(total_element_count) + 1), element_root);\n    }\n\n    // INTERFACE: Try to update a bytes32 element and append bytes32 elements in memory,\n    // given a root, an index, a bytes32 element, and a Single Proof\n    function try_update_one_and_append_many(\n        bytes32 root,\n        uint256 index,\n        bytes32 element,\n        bytes32 update_element,\n        bytes32[] memory append_elements,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32[] memory append_proof;\n        (element_root, append_proof) = get_append_proof_from_single_proof_update(index, element, update_element, proof);\n\n        require(hash_node(total_element_count, element_root) == root, \"INVALID_PROOF\");\n\n        element_root = get_new_root_from_append_proof_multi_append(append_elements, append_proof);\n\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), element_root);\n    }\n\n    // INTERFACE: Try to update bytes32 elements in memory and append a bytes32 element,\n    // given a root, bytes32 elements in memory, and a Single Proof\n    function try_update_many_and_append_one(\n        bytes32 root,\n        bytes32[] memory elements,\n        bytes32[] memory update_elements,\n        bytes32 append_element,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32[] memory append_proof;\n        (element_root, append_proof) = get_append_proof_from_multi_proof_update(elements, update_elements, proof);\n\n        require(hash_node(total_element_count, element_root) == root, \"INVALID_PROOF\");\n\n        element_root = get_new_root_from_append_proof_single_append(append_element, append_proof);\n\n        return hash_node(bytes32(uint256(total_element_count) + 1), element_root);\n    }\n\n    // INTERFACE: Try to update bytes32 elements in memory and append bytes32 elements in memory,\n    // given a root, bytes32 elements in memory, and an Existence Multi Proof\n    function try_update_many_and_append_many(\n        bytes32 root,\n        bytes32[] memory elements,\n        bytes32[] memory update_elements,\n        bytes32[] memory append_elements,\n        bytes32[] memory proof\n    ) internal pure returns (bytes32 element_root) {\n        bytes32 total_element_count = proof[0];\n\n        require(root != bytes32(0) || total_element_count == bytes32(0), \"EMPTY_TREE\");\n\n        bytes32[] memory append_proof;\n        (element_root, append_proof) = get_append_proof_from_multi_proof_update(elements, update_elements, proof);\n\n        require(hash_node(total_element_count, element_root) == root, \"INVALID_PROOF\");\n\n        element_root = get_new_root_from_append_proof_multi_append(append_elements, append_proof);\n\n        return hash_node(bytes32(uint256(total_element_count) + append_elements.length), element_root);\n    }\n\n    // INTERFACE: Create a tree and return the root, given a bytes32 element\n    function create_from_one(bytes32 element) internal pure returns (bytes32 new_element_root) {\n        return hash_node(bytes32(uint256(1)), get_root_from_one(element));\n    }\n\n    // INTERFACE: Create a tree and return the root, given bytes32 elements in memory\n    function create_from_many(bytes32[] memory elements) internal pure returns (bytes32 new_element_root) {\n        return hash_node(bytes32(elements.length), get_root_from_many(elements));\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/libraries/MemoryLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/DeserializationLib.sol\";\nimport \"../../libraries/MerkleLib.sol\";\nimport \"../../libraries/BytesLib.sol\";\nimport \"./OneStepProof.sol\";\n\nlibrary MemoryLib {\n    using BytesLib for bytes;\n\n    function calcCellNum(uint64 offset, uint64 length) internal pure returns (uint64) {\n        return (offset + length + 31) / 32 - offset / 32;\n    }\n\n    function getMemoryRoot(bytes memory content) internal pure returns (bytes32) {\n        uint64 cellNum = MemoryLib.calcCellNum(0, uint64(content.length));\n        bytes32[] memory elements = new bytes32[](cellNum);\n        for (uint256 i = 0; i < cellNum - 1; i++) {\n            elements[i] = content.toBytes32(i * 32);\n        }\n        elements[cellNum - 1] = content.toBytes32Pad((cellNum - 1) * 32);\n        return MerkleLib.create_from_many(elements);\n    }\n\n    function decodeAndVerifyMemoryReadProof(\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded,\n        uint64 offset,\n        uint64 memoryOffset,\n        uint64 memoryReadLength\n    ) internal pure returns (uint64, bytes memory) {\n        if (stateProof.memSize == 0 || memoryReadLength == 0) {\n            return (offset, new bytes(memoryReadLength));\n        }\n        uint64 startCell = memoryOffset / 32;\n        uint64 cellNum = calcCellNum(memoryOffset, memoryReadLength);\n        uint64 memoryCell = calcCellNum(0, stateProof.memSize);\n        OneStepProof.MemoryMerkleProof memory merkleProof;\n        {\n            if (memoryCell <= startCell) {\n                cellNum += startCell - memoryCell;\n                OneStepProof.MemoryAppendProof memory appendProof;\n                (offset, appendProof) = OneStepProof.decodeMemoryAppendProof(encoded, offset, cellNum);\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\n                stateProof.memRoot =\n                    MerkleLib.try_append_many(stateProof.memRoot, appendProof.appendCells, merkleProof.proof);\n                if (memoryOffset + memoryReadLength > stateProof.memSize) {\n                    stateProof.memSize = (memoryOffset + memoryReadLength + 31) / 32 * 32; // Expand by words\n                }\n                bytes memory readContent = new bytes(memoryReadLength);\n                return (offset, readContent);\n            }\n        }\n        {\n            if (memoryCell >= startCell + cellNum) {\n                OneStepProof.MemoryReadProof memory readProof;\n                (offset, readProof) = OneStepProof.decodeMemoryReadProof(encoded, offset, cellNum);\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\n                if (cellNum == 1) {\n                    MerkleLib.element_exists(stateProof.memRoot, startCell, readProof.cells[0], merkleProof.proof);\n                    require(\n                        MerkleLib.element_exists(stateProof.memRoot, startCell, readProof.cells[0], merkleProof.proof),\n                        \"IMP\"\n                    );\n                } else {\n                    {\n                        // avoid stack too deep\n                        uint256[] memory indices = MerkleLib.get_indices(readProof.cells, merkleProof.proof);\n                        for (uint64 i = 0; i < cellNum; i++) {\n                            require(indices[i] == startCell + i, \"IMP\");\n                        }\n                    }\n                    MerkleLib.elements_exist(stateProof.memRoot, readProof.cells, merkleProof.proof);\n                    require(MerkleLib.elements_exist(stateProof.memRoot, readProof.cells, merkleProof.proof), \"IMP\");\n                }\n                bytes memory readContent = abi.encodePacked(readProof.cells).slice(memoryOffset % 32, memoryReadLength);\n                return (offset, readContent);\n            }\n        }\n        uint64 existCellNum = memoryCell - startCell;\n        OneStepProof.MemoryCombinedReadProof memory combinedReadProof;\n        (offset, combinedReadProof) =\n            OneStepProof.decodeMemoryCombinedReadProof(encoded, offset, existCellNum, cellNum - existCellNum);\n        (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\n        if (existCellNum == 1) {\n            stateProof.memRoot = MerkleLib.try_append_many_using_one(\n                stateProof.memRoot,\n                startCell,\n                combinedReadProof.cells[0],\n                combinedReadProof.appendCells,\n                merkleProof.proof\n            );\n        } else {\n            {\n                // avoid stack too deep\n                uint256[] memory indices = MerkleLib.get_indices(combinedReadProof.cells, merkleProof.proof);\n                for (uint64 i = 0; i < existCellNum; i++) {\n                    require(indices[i] == startCell + i, \"IMP\");\n                }\n            }\n            stateProof.memRoot = MerkleLib.try_append_many_using_many(\n                stateProof.memRoot, combinedReadProof.cells, combinedReadProof.appendCells, merkleProof.proof\n            );\n        }\n        if (memoryOffset + memoryReadLength > stateProof.memSize) {\n            stateProof.memSize = (memoryOffset + memoryReadLength + 31) / 32 * 32; // Expand by words\n        }\n        bytes memory readContent = abi.encodePacked(combinedReadProof.cells, combinedReadProof.appendCells).slice(\n            memoryOffset % 32, memoryReadLength\n        );\n        return (offset, readContent);\n    }\n\n    function decodeAndVerifyMemoryLikeReadProofNoAppend(\n        bytes32 memoryLikeRoot,\n        uint64 memoryLikeSize,\n        bytes calldata encoded,\n        uint64 offset,\n        uint64 memoryLikeOffset,\n        uint64 memoryLikeReadLength\n    ) internal pure returns (uint64, bytes memory) {\n        if (memoryLikeSize == 0 || memoryLikeReadLength == 0) {\n            return (offset, new bytes(memoryLikeReadLength));\n        }\n        uint64 startCell = memoryLikeOffset / 32;\n        uint64 cellNum = calcCellNum(memoryLikeOffset, memoryLikeReadLength);\n        uint64 memoryCell = calcCellNum(0, memoryLikeSize);\n        {\n            if (memoryCell <= startCell) {\n                bytes memory readContent;\n                readContent = new bytes(memoryLikeReadLength);\n                return (offset, readContent);\n            }\n        }\n        {\n            if (memoryCell >= startCell + cellNum) {\n                bytes memory readContent;\n                OneStepProof.MemoryReadProof memory readProof;\n                OneStepProof.MemoryMerkleProof memory merkleProof;\n                (offset, readProof) = OneStepProof.decodeMemoryReadProof(encoded, offset, cellNum);\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\n                if (cellNum == 1) {\n                    MerkleLib.element_exists(memoryLikeRoot, startCell, readProof.cells[0], merkleProof.proof);\n                    require(\n                        MerkleLib.element_exists(memoryLikeRoot, startCell, readProof.cells[0], merkleProof.proof),\n                        \"IMP\"\n                    );\n                } else {\n                    {\n                        uint256[] memory indices = MerkleLib.get_indices(readProof.cells, merkleProof.proof);\n                        for (uint64 i = 0; i < cellNum; i++) {\n                            require(indices[i] == startCell + i, \"IMP2\");\n                        }\n                    }\n                    MerkleLib.elements_exist(memoryLikeRoot, readProof.cells, merkleProof.proof);\n                    require(MerkleLib.elements_exist(memoryLikeRoot, readProof.cells, merkleProof.proof), \"IMP\");\n                }\n                readContent = abi.encodePacked(readProof.cells).slice(memoryLikeOffset % 32, memoryLikeReadLength);\n                return (offset, readContent);\n            }\n        }\n        uint64 existCellNum = memoryCell - startCell;\n        OneStepProof.MemoryReadProof memory readProof;\n        OneStepProof.MemoryMerkleProof memory merkleProof;\n        (offset, readProof) = OneStepProof.decodeMemoryReadProof(encoded, offset, existCellNum);\n        (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\n        if (existCellNum == 1) {\n            MerkleLib.element_exists(memoryLikeRoot, startCell, readProof.cells[0], merkleProof.proof);\n            require(MerkleLib.element_exists(memoryLikeRoot, startCell, readProof.cells[0], merkleProof.proof), \"IMP\");\n        } else {\n            {\n                uint256[] memory indices = MerkleLib.get_indices(readProof.cells, merkleProof.proof);\n                for (uint64 i = 0; i < cellNum; i++) {\n                    require(indices[i] == startCell + i, \"IMP\");\n                }\n            }\n            MerkleLib.elements_exist(memoryLikeRoot, readProof.cells, merkleProof.proof);\n            require(MerkleLib.elements_exist(memoryLikeRoot, readProof.cells, merkleProof.proof), \"IMP\");\n        }\n        bytes memory padding = new bytes(32 * (cellNum - existCellNum));\n        bytes memory readContent;\n        readContent = abi.encodePacked(readProof.cells, padding).slice(memoryLikeOffset % 32, memoryLikeReadLength);\n        return (offset, readContent);\n    }\n\n    function decodeAndVerifyMemoryWriteProof(\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded,\n        uint64 offset,\n        uint64 memoryOffset,\n        uint64 memoryWriteLength\n    ) internal pure returns (uint64, bytes memory) {\n        if (memoryWriteLength == 0) {\n            return (offset, new bytes(0));\n        }\n        if (stateProof.memSize == 0) {\n            // Don't call decodeMemoryWriteProof if memory is empty\n            // Instead, update memory root and size directly\n            revert();\n        }\n        uint64 startCell = memoryOffset / 32;\n        uint64 cellNum = calcCellNum(memoryOffset, memoryWriteLength);\n        uint64 memoryCell = calcCellNum(0, stateProof.memSize);\n        OneStepProof.MemoryMerkleProof memory merkleProof;\n\n        {\n            if (memoryCell <= startCell) {\n                cellNum += startCell - memoryCell;\n                OneStepProof.MemoryAppendProof memory appendProof;\n                (offset, appendProof) = OneStepProof.decodeMemoryAppendProof(encoded, offset, cellNum);\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\n                if (cellNum == 1) {\n                    stateProof.memRoot =\n                        MerkleLib.try_append_one(stateProof.memRoot, appendProof.appendCells[0], merkleProof.proof);\n                } else {\n                    stateProof.memRoot =\n                        MerkleLib.try_append_many(stateProof.memRoot, appendProof.appendCells, merkleProof.proof);\n                }\n                if (memoryOffset + memoryWriteLength > stateProof.memSize) {\n                    stateProof.memSize = (memoryOffset + memoryWriteLength + 31) / 32 * 32; // Expand by words\n                }\n                bytes memory writeContent =\n                    abi.encodePacked(appendProof.appendCells).slice(memoryOffset % 32, memoryWriteLength);\n                return (offset, writeContent);\n            }\n        }\n        {\n            if (memoryCell >= startCell + cellNum) {\n                OneStepProof.MemoryWriteProof memory writeProof;\n                (offset, writeProof) = OneStepProof.decodeMemoryWriteProof(encoded, offset, cellNum);\n                (offset, merkleProof) = OneStepProof.decodeMemoryMerkleProof(encoded, offset);\n                if (cellNum == 1) {\n                    stateProof.memRoot = MerkleLib.try_update_one(\n                        stateProof.memRoot,\n                        startCell,\n                        writeProof.cells[0],\n                        writeProof.updatedCells[0],\n                        merkleProof.proof\n                    );\n                } else {\n                    {\n                        // Avoid stack too deep\n                        uint256[] memory indices = MerkleLib.get_indices(writeProof.cells, merkleProof.proof);\n                        for (uint64 i = 0; i < cellNum; i++) {\n                            require(indices[i] == startCell + i, \"IMP\");\n                        }\n                    }\n                    stateProof.memRoot = MerkleLib.try_update_many(\n                        stateProof.memRoot, writeProof.cells, writeProof.updatedCells, merkleProof.proof\n                    );\n                }\n                bytes memory writeContent =\n                    abi.encodePacked(writeProof.updatedCells).slice(memoryOffset % 32, memoryWriteLength);\n                return (offset, writeContent);\n            }\n        }\n        uint64 existCellNum = memoryCell - startCell;\n        OneStepProof.MemoryCombinedWriteProof memory combinedWriteProof;\n        (offset, combinedWriteProof) =\n            OneStepProof.decodeMemoryCombinedWriteProof(encoded, offset, existCellNum, cellNum - existCellNum);\n        if (cellNum == 1) {\n            stateProof.memRoot = MerkleLib.try_update_one_and_append_many(\n                stateProof.memRoot,\n                startCell,\n                combinedWriteProof.cells[0],\n                combinedWriteProof.updatedCells[0],\n                combinedWriteProof.appendCells,\n                merkleProof.proof\n            );\n        } else {\n            {\n                // avoid stack too deep\n                uint256[] memory indices = MerkleLib.get_indices(combinedWriteProof.cells, merkleProof.proof);\n                for (uint64 i = 0; i < cellNum; i++) {\n                    require(indices[i] == startCell + i, \"IMP\");\n                }\n            }\n            stateProof.memRoot = MerkleLib.try_update_many_and_append_many(\n                stateProof.memRoot,\n                combinedWriteProof.cells,\n                combinedWriteProof.updatedCells,\n                combinedWriteProof.appendCells,\n                merkleProof.proof\n            );\n        }\n        if (memoryOffset + memoryWriteLength > stateProof.memSize) {\n            stateProof.memSize = (memoryOffset + memoryWriteLength + 31) / 32 * 32; // Expand by words\n        }\n        bytes memory writeContent = abi.encodePacked(combinedWriteProof.updatedCells, combinedWriteProof.appendCells)\n            .slice(memoryOffset % 32, memoryWriteLength);\n        return (offset, writeContent);\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/libraries/EVMTypesLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BytesLib.sol\";\nimport \"../../libraries/RLPReader.sol\";\nimport \"../../libraries/RLPWriter.sol\";\nimport \"./BloomLib.sol\";\n\nlibrary EVMTypesLib {\n    using BytesLib for bytes;\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    struct BlockHeader {\n        bytes32 parentHash;\n        bytes32 ommerHash;\n        address beneficiary;\n        bytes32 stateRoot;\n        bytes32 transactionRoot;\n        bytes32 receiptsRoot;\n        uint256 difficulty;\n        uint256 number;\n        uint64 gasLimit;\n        uint64 gasUsed;\n        uint64 timestamp;\n        BloomLib.Bloom logsBloom;\n    }\n\n    function hashBlockHeader(BlockHeader memory header) internal pure returns (bytes32) {\n        bytes[] memory raw = new bytes[](15);\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(header.parentHash));\n        raw[1] = RLPWriter.writeBytes(abi.encodePacked(header.ommerHash));\n        raw[2] = RLPWriter.writeAddress(header.beneficiary);\n        raw[3] = RLPWriter.writeBytes(abi.encodePacked(header.stateRoot));\n        raw[4] = RLPWriter.writeBytes(abi.encodePacked(header.transactionRoot));\n        raw[5] = RLPWriter.writeBytes(abi.encodePacked(header.receiptsRoot));\n        raw[6] = RLPWriter.writeBytes(abi.encodePacked(header.logsBloom.data));\n        raw[7] = RLPWriter.writeUint(header.difficulty);\n        raw[8] = RLPWriter.writeUint(header.number);\n        raw[9] = RLPWriter.writeUint(uint256(header.gasLimit));\n        raw[10] = RLPWriter.writeUint(uint256(header.gasUsed));\n        raw[11] = RLPWriter.writeUint(uint256(header.timestamp));\n        raw[12] = RLPWriter.writeBytes(\"\"); // Extra\n        raw[13] = RLPWriter.writeBytes(abi.encodePacked(bytes32(0))); // MixDigest\n        raw[14] = RLPWriter.writeBytes(abi.encodePacked(bytes8(0))); // Nonce\n        return keccak256(RLPWriter.writeList(raw));\n    }\n\n    struct Transaction {\n        uint64 nonce;\n        uint256 gasPrice;\n        uint64 gas;\n        address to;\n        uint256 value;\n        bytes data;\n        uint256 v;\n        uint256 r;\n        uint256 s;\n    }\n\n    function decodeTransaction(bytes memory data) internal pure returns (Transaction memory transaction) {\n        RLPReader.RLPItem[] memory decoded = data.toRlpItem().toList();\n        transaction.nonce = uint64(decoded[0].toUint());\n        transaction.gasPrice = decoded[1].toUint();\n        transaction.gas = uint64(decoded[2].toUint());\n        transaction.to = address(uint160(decoded[3].toUint()));\n        transaction.value = decoded[4].toUint();\n        transaction.data = decoded[5].toBytes();\n        transaction.v = decoded[6].toUint();\n        transaction.r = decoded[7].toUint();\n        transaction.s = decoded[8].toUint();\n    }\n\n    function hashTransaction(Transaction memory txn) internal pure returns (bytes32) {\n        bytes[] memory raw = new bytes[](9);\n        raw[0] = RLPWriter.writeUint(uint256(txn.nonce));\n        raw[1] = RLPWriter.writeUint(txn.gasPrice);\n        raw[2] = RLPWriter.writeUint(uint256(txn.gas));\n        raw[3] = RLPWriter.writeAddress(txn.to);\n        raw[4] = RLPWriter.writeUint(txn.value);\n        raw[5] = RLPWriter.writeBytes(txn.data);\n        raw[6] = RLPWriter.writeUint(txn.v);\n        raw[7] = RLPWriter.writeUint(txn.r);\n        raw[8] = RLPWriter.writeUint(txn.s);\n        return keccak256(RLPWriter.writeList(raw));\n    }\n\n    struct Account {\n        uint64 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n    }\n\n    function decodeAccount(RLPReader.RLPItem memory encoded) internal pure returns (Account memory proof) {\n        RLPReader.RLPItem[] memory items = encoded.toList();\n        require(items.length == 4, \"Invalid Account\");\n        proof.nonce = uint64(items[0].toUint());\n        proof.balance = items[1].toUint();\n        proof.storageRoot = bytes32(items[2].toUint());\n        proof.codeHash = bytes32(items[3].toUint());\n    }\n\n    function encodeRLP(Account memory account) internal pure returns (bytes memory) {\n        bytes[] memory raw = new bytes[](4);\n        raw[0] = RLPWriter.writeUint(uint256(account.nonce));\n        raw[1] = RLPWriter.writeUint(account.balance);\n        raw[2] = RLPWriter.writeBytes(abi.encodePacked(account.storageRoot));\n        raw[3] = RLPWriter.writeBytes(abi.encodePacked(account.codeHash));\n        return RLPWriter.writeList(raw);\n    }\n\n    function hashLogEntry(address addr, uint256[] memory topics, bytes memory data) internal pure returns (bytes32) {\n        bytes[] memory topicRaw = new bytes[](topics.length);\n        for (uint256 i = 0; i < topics.length; i++) {\n            topicRaw[i] = RLPWriter.writeBytes(abi.encodePacked(bytes32(topics[i])));\n        }\n        bytes[] memory raw = new bytes[](3);\n        raw[0] = RLPWriter.writeAddress(addr);\n        raw[1] = RLPWriter.writeBytes(RLPWriter.writeList(topicRaw));\n        raw[2] = RLPWriter.writeBytes(data);\n        return keccak256(RLPWriter.writeList(raw));\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/libraries/OneStepProof.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/RLPReader.sol\";\nimport \"../../libraries/BytesLib.sol\";\nimport \"./BloomLib.sol\";\nimport \"./VerificationContext.sol\";\n\nlibrary OneStepProof {\n    using BytesLib for bytes;\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n    using RLPReader for bytes;\n    using VerificationContext for VerificationContext.Context;\n\n    // [encode rule]\n    struct StateProof {\n        uint64 blockNumber; // Block number of current transaction [always]\n        uint64 transactionIdx; // Transaction index in block [always]\n        uint16 depth; // Current call depth [always]\n        uint64 gas; // Gas left in the current call [always]\n        uint64 refund; // Gas refund accumulated in the current transaction [always]\n        bytes32 lastDepthHash; // The state hash of the last depth call frame [always]\n        address contractAddress; // Current executing contract address [depth > 1]\n        address caller; // Current caller [depth > 1]\n        uint256 value; // Current call value [depth > 1]\n        uint8 callFlag; // Current call type [depth > 1]\n        uint64 out; // Offset of the return data of current call to be copied to the last depth call frame [depth > 1]\n        uint64 outSize; // Size of the return data of current call to be copied to the last depth call frame [depth > 1]\n        uint64 pc; // Current program counter [always]\n        uint8 opCode; // Current opcode to be executed [always]\n        bytes32 codeHash; // Current executing contract code hash [always]\n        uint64 stackSize; // Size of the stack [always]\n        bytes32 stackHash; // Commitment of the stack [always]\n        uint64 memSize; // Size of the memory [always]\n        bytes32 memRoot; // Commitment of the memory [memSize > 0]\n        uint64 inputDataSize; // Size of the call data [depth > 1]\n        bytes32 inputDataRoot; // Commitment of the return data [depth > 1 && inputDataSize > 0]\n        uint64 returnDataSize; // Size of the return data [always]\n        bytes32 returnDataRoot; // Commitment of the return data [returnDataSize > 0]\n        bytes32 committedGlobalStateRoot; // Commitment of the global MPT state at the start of transaction [always]\n        bytes32 globalStateRoot; // Commitment of the global MPT state [always]\n        bytes32 selfDestructAcc; // Commitment of the self destructed contracts in the current transaction [always]\n        bytes32 logAcc; // Commitment of the logs emitted in the current transaction [always]\n        bytes32 blockHashRoot; // Commitment of the 256 previous blockhash in the current block [always]\n        bytes32 accessListRoot; // Commitment of the access list in the current transaction [always]\n    }\n\n    function decodeStateProof(VerificationContext.Context memory ctx, bytes calldata encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, StateProof memory proof)\n    {\n        uint64 remainLength = uint64(encoded.length) - offset;\n        uint64 stateProofLen = 323;\n        require(remainLength >= stateProofLen, \"Proof Underflow (State)\");\n        proof.blockNumber = encoded.toUint64(offset);\n        proof.transactionIdx = encoded.toUint64(offset + 8);\n        proof.depth = encoded.toUint16(offset + 16);\n        proof.gas = encoded.toUint64(offset + 18);\n        proof.refund = encoded.toUint64(offset + 26);\n        proof.lastDepthHash = encoded.toBytes32(offset + 34);\n        offset = offset + 66;\n        if (proof.depth > 1) {\n            stateProofLen += 97;\n            require(remainLength >= stateProofLen, \"Proof Underflow (State)\");\n            proof.contractAddress = encoded.toAddress(offset);\n            proof.caller = encoded.toAddress(offset + 20);\n            proof.value = encoded.toUint256(offset + 40);\n            proof.callFlag = encoded.toUint8(offset + 72);\n            proof.out = encoded.toUint64(offset + 73);\n            proof.outSize = encoded.toUint64(offset + 81);\n            offset += 89;\n        } else {\n            proof.contractAddress = ctx.getRecipient();\n            proof.caller = ctx.getOrigin();\n            proof.value = ctx.getValue();\n            if (ctx.getRecipient() == address(0)) {\n                proof.callFlag = 4;\n            } else {\n                proof.callFlag = 0;\n            }\n        }\n        proof.pc = encoded.toUint64(offset);\n        proof.opCode = encoded.toUint8(offset + 8);\n        proof.codeHash = encoded.toBytes32(offset + 9);\n        proof.stackSize = encoded.toUint64(offset + 41);\n        offset += 49;\n        if (proof.stackSize != 0) {\n            stateProofLen += 32;\n            require(remainLength >= stateProofLen, \"Proof Underflow (State)\");\n            proof.stackHash = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        proof.memSize = encoded.toUint64(offset);\n        offset += 8;\n        if (proof.memSize != 0) {\n            stateProofLen += 32;\n            require(remainLength >= stateProofLen, \"Proof Underflow (State)\");\n            proof.memRoot = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        if (proof.depth > 1) {\n            proof.inputDataSize = encoded.toUint64(offset);\n            offset += 8;\n            if (proof.inputDataSize != 0) {\n                stateProofLen += 32;\n                require(remainLength >= stateProofLen, \"Proof Underflow (State)\");\n                proof.inputDataRoot = encoded.toBytes32(offset);\n                offset += 32;\n            }\n        } else {\n            proof.inputDataSize = ctx.getInputSize();\n            proof.inputDataRoot = ctx.getInputRoot();\n        }\n        proof.returnDataSize = encoded.toUint64(offset);\n        offset += 8;\n        if (proof.returnDataSize != 0) {\n            stateProofLen += 32;\n            require(remainLength >= stateProofLen, \"Proof Underflow (State)\");\n            proof.returnDataRoot = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        proof.committedGlobalStateRoot = encoded.toBytes32(offset);\n        proof.globalStateRoot = encoded.toBytes32(offset + 32);\n        proof.selfDestructAcc = encoded.toBytes32(offset + 64);\n        proof.logAcc = encoded.toBytes32(offset + 96);\n        proof.blockHashRoot = encoded.toBytes32(offset + 128);\n        proof.accessListRoot = encoded.toBytes32(offset + 160);\n        return (offset + 192, proof);\n    }\n\n    function encodeStateProof(StateProof memory proof) internal pure returns (bytes memory encoded) {\n        encoded = encoded.concat(abi.encodePacked(proof.blockNumber));\n        encoded = encoded.concat(abi.encodePacked(proof.transactionIdx));\n        encoded = encoded.concat(abi.encodePacked(proof.depth));\n        encoded = encoded.concat(abi.encodePacked(proof.gas));\n        encoded = encoded.concat(abi.encodePacked(proof.refund));\n        encoded = encoded.concat(abi.encodePacked(proof.lastDepthHash));\n        if (proof.depth > 1) {\n            encoded = encoded.concat(abi.encodePacked(proof.contractAddress));\n            encoded = encoded.concat(abi.encodePacked(proof.caller));\n            encoded = encoded.concat(abi.encodePacked(proof.value));\n            encoded = encoded.concat(abi.encodePacked(proof.callFlag));\n            encoded = encoded.concat(abi.encodePacked(proof.out));\n            encoded = encoded.concat(abi.encodePacked(proof.outSize));\n        }\n        encoded = encoded.concat(abi.encodePacked(proof.pc));\n        encoded = encoded.concat(abi.encodePacked(proof.opCode));\n        encoded = encoded.concat(abi.encodePacked(proof.codeHash));\n        encoded = encoded.concat(abi.encodePacked(proof.stackSize));\n        if (proof.stackSize != 0) {\n            encoded = encoded.concat(abi.encodePacked(proof.stackHash));\n        }\n        encoded = encoded.concat(abi.encodePacked(proof.memSize));\n        if (proof.memSize != 0) {\n            encoded = encoded.concat(abi.encodePacked(proof.memRoot));\n        }\n        if (proof.depth > 1) {\n            encoded = encoded.concat(abi.encodePacked(proof.inputDataSize));\n            if (proof.inputDataSize != 0) {\n                encoded = encoded.concat(abi.encodePacked(proof.inputDataRoot));\n            }\n        }\n        encoded = encoded.concat(abi.encodePacked(proof.returnDataSize));\n        if (proof.returnDataSize != 0) {\n            encoded = encoded.concat(abi.encodePacked(proof.returnDataRoot));\n        }\n        encoded = encoded.concat(abi.encodePacked(proof.committedGlobalStateRoot));\n        encoded = encoded.concat(abi.encodePacked(proof.globalStateRoot));\n        encoded = encoded.concat(abi.encodePacked(proof.selfDestructAcc));\n        encoded = encoded.concat(abi.encodePacked(proof.logAcc));\n        encoded = encoded.concat(abi.encodePacked(proof.blockHashRoot));\n        encoded = encoded.concat(abi.encodePacked(proof.accessListRoot));\n    }\n\n    function hashStateProof(StateProof memory proof) internal pure returns (bytes32) {\n        if (proof.depth == 0) {\n            // When returning/reverting from depth 1, we can't directly return an InterStateProof\n            // Therefore we reuse some of the fields in the IntraStateProof to store an InterStateProof\n            // The field mappings are as follows:\n            InterStateProof memory interProof;\n            interProof.blockNumber = proof.blockNumber;\n            interProof.transactionIdx = proof.transactionIdx;\n            interProof.globalStateRoot = proof.globalStateRoot;\n            interProof.cumulativeGasUsed = proof.value;\n            interProof.blockGasUsed = uint256(proof.lastDepthHash);\n            interProof.blockHashRoot = proof.blockHashRoot;\n            interProof.transactionTrieRoot = proof.selfDestructAcc;\n            interProof.receiptTrieRoot = proof.logAcc;\n            return hashInterStateProof(interProof);\n        }\n        return keccak256(encodeStateProof(proof));\n    }\n\n    struct InterStateProof {\n        uint64 blockNumber;\n        uint64 transactionIdx;\n        bytes32 globalStateRoot;\n        uint256 cumulativeGasUsed;\n        uint256 blockGasUsed;\n        bytes32 blockHashRoot;\n        bytes32 transactionTrieRoot;\n        bytes32 receiptTrieRoot;\n        BloomLib.Bloom logsBloom;\n    }\n\n    function decodeInterStateProof(bytes calldata encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, InterStateProof memory proof)\n    {\n        require(encoded.length - offset >= 464, \"Proof Underflow (Inter)\");\n        proof.blockNumber = encoded.toUint64(offset);\n        proof.transactionIdx = encoded.toUint64(offset + 8);\n        proof.globalStateRoot = encoded.toBytes32(offset + 16);\n        proof.cumulativeGasUsed = encoded.toUint64(offset + 48);\n        proof.blockGasUsed = encoded.toUint64(offset + 80);\n        proof.blockHashRoot = encoded.toBytes32(offset + 112);\n        proof.transactionTrieRoot = encoded.toBytes32(offset + 144);\n        proof.receiptTrieRoot = encoded.toBytes32(offset + 176);\n        proof.logsBloom = BloomLib.decodeBloom(encoded, offset + 208);\n        return (offset + 464, proof);\n    }\n\n    function encodeInterStateProof(InterStateProof memory proof) internal pure returns (bytes memory encoded) {\n        encoded = encoded.concat(abi.encodePacked(proof.blockNumber));\n        encoded = encoded.concat(abi.encodePacked(proof.transactionIdx));\n        encoded = encoded.concat(abi.encodePacked(proof.globalStateRoot));\n        encoded = encoded.concat(abi.encodePacked(proof.cumulativeGasUsed));\n        encoded = encoded.concat(abi.encodePacked(proof.blockGasUsed));\n        encoded = encoded.concat(abi.encodePacked(proof.blockHashRoot));\n        encoded = encoded.concat(abi.encodePacked(proof.transactionTrieRoot));\n        encoded = encoded.concat(abi.encodePacked(proof.receiptTrieRoot));\n        encoded = encoded.concat(abi.encodePacked(proof.logsBloom.data));\n    }\n\n    function hashInterStateProof(InterStateProof memory proof) internal pure returns (bytes32) {\n        return keccak256(encodeInterStateProof(proof));\n    }\n\n    struct BlockStateProof {\n        uint64 blockNumber;\n        bytes32 globalStateRoot;\n        uint256 cumulativeGasUsed;\n        bytes32 blockHashRoot;\n    }\n\n    function decodeBlockStateProof(bytes calldata encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, BlockStateProof memory proof)\n    {\n        require(encoded.length - offset >= 104, \"Proof Underflow (Block)\");\n        proof.blockNumber = encoded.toUint64(offset);\n        proof.globalStateRoot = encoded.toBytes32(offset + 8);\n        proof.cumulativeGasUsed = encoded.toUint64(offset + 40);\n        proof.blockHashRoot = encoded.toBytes32(offset + 72);\n        return (offset + 104, proof);\n    }\n\n    function encodeBlockStateProof(BlockStateProof memory proof) internal pure returns (bytes memory encoded) {\n        encoded = encoded.concat(abi.encodePacked(proof.blockNumber));\n        encoded = encoded.concat(abi.encodePacked(proof.globalStateRoot));\n        encoded = encoded.concat(abi.encodePacked(proof.cumulativeGasUsed));\n        encoded = encoded.concat(abi.encodePacked(proof.blockHashRoot));\n    }\n\n    function hashBlockStateProof(BlockStateProof memory proof) internal pure returns (bytes32) {\n        return keccak256(encodeBlockStateProof(proof));\n    }\n\n    struct CodeProof {\n        uint64 ptr;\n        uint64 size;\n    }\n\n    function decodeCodeProof(bytes calldata encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, CodeProof memory proof)\n    {\n        require(encoded.length - offset >= 8, \"Proof Underflow (Code)\");\n        // Decode bytecode size in bytes\n        uint64 contentSize = encoded.toUint64(offset);\n        require(encoded.length - offset >= 8 + contentSize, \"Proof Underflow (Code)\");\n        offset += 8;\n        proof.ptr = offset;\n        proof.size = contentSize;\n        return (offset + contentSize, proof);\n    }\n\n    function getOpCodeAt(CodeProof memory proof, bytes calldata encoded, uint64 idx) internal pure returns (uint8) {\n        if (idx >= proof.size) {\n            return 0;\n        }\n        return uint8(encoded[proof.ptr + idx]);\n    }\n\n    function getCodeSlice(CodeProof memory proof, bytes calldata encoded, uint64 offset, uint64 size)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (offset + size > proof.size) {\n            return encoded.slice(proof.ptr + offset, size).concat(new bytes(size - (proof.size - offset)));\n        }\n        return encoded.slice(proof.ptr + offset, size);\n    }\n\n    function hashCodeProof(CodeProof memory proof, bytes calldata encoded) internal pure returns (bytes32) {\n        return keccak256(encoded[proof.ptr:proof.ptr + proof.size]);\n    }\n\n    struct StackProof {\n        // The elements popped in the step\n        uint256[] pops;\n        // The stack hash after popping above elements\n        bytes32 stackHashAfterPops;\n    }\n\n    function decodeStackProof(bytes calldata encoded, uint64 offset, uint64 popNum)\n        internal\n        pure\n        returns (uint64, StackProof memory proof)\n    {\n        if (popNum == 0) {\n            // No StackProof needed for popNum == 0\n            return (offset, proof);\n        }\n        require(encoded.length - offset >= 32 * (popNum + 1), \"Proof Underflow (Stack)\");\n        proof.pops = new uint256[](popNum);\n        // Decode popped elements\n        for (uint64 i = 0; i < popNum; i++) {\n            proof.pops[i] = encoded.toUint256(offset);\n            offset += 32;\n        }\n        // Decode stackHashAfterPops\n        proof.stackHashAfterPops = encoded.toBytes32(offset);\n        offset += 32;\n        return (offset, proof);\n    }\n\n    function encodeStackProof(StackProof memory proof) internal pure returns (bytes memory encoded) {\n        for (uint64 i = 0; i < proof.pops.length; i++) {\n            encoded = encoded.concat(abi.encodePacked(proof.pops[i]));\n        }\n        encoded = encoded.concat(abi.encodePacked(proof.stackHashAfterPops));\n    }\n\n    struct MemoryMerkleProof {\n        bytes32[] proof;\n    }\n\n    function decodeMemoryMerkleProof(bytes calldata encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, MemoryMerkleProof memory proof)\n    {\n        require(encoded.length - offset >= 8, \"Proof Underflow\");\n        uint64 len = encoded.toUint64(offset);\n        offset += 8;\n        require(encoded.length - offset >= 32 * len, \"Proof Underflow\");\n        proof.proof = new bytes32[](len);\n        for (uint64 i = 0; i < len; i++) {\n            proof.proof[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        return (offset, proof);\n    }\n\n    struct MemoryReadProof {\n        bytes32[] cells;\n    }\n\n    function decodeMemoryReadProof(bytes calldata encoded, uint64 offset, uint64 cellNum)\n        internal\n        pure\n        returns (uint64, MemoryReadProof memory proof)\n    {\n        require(encoded.length - offset >= 32 * cellNum, \"Proof Underflow\");\n        proof.cells = new bytes32[](cellNum);\n        for (uint64 i = 0; i < cellNum; i++) {\n            proof.cells[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        return (offset, proof);\n    }\n\n    struct MemoryWriteProof {\n        bytes32[] cells;\n        bytes32[] updatedCells;\n    }\n\n    function decodeMemoryWriteProof(bytes calldata encoded, uint64 offset, uint64 cellNum)\n        internal\n        pure\n        returns (uint64, MemoryWriteProof memory proof)\n    {\n        require(encoded.length - offset >= 64 * cellNum, \"Proof Underflow\");\n        proof.cells = new bytes32[](cellNum);\n        for (uint64 i = 0; i < cellNum; i++) {\n            proof.cells[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        proof.updatedCells = new bytes32[](cellNum);\n        for (uint64 i = 0; i < cellNum; i++) {\n            proof.updatedCells[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        return (offset, proof);\n    }\n\n    struct MemoryAppendProof {\n        bytes32[] appendCells;\n    }\n\n    function decodeMemoryAppendProof(bytes calldata encoded, uint64 offset, uint64 cellNum)\n        internal\n        pure\n        returns (uint64, MemoryAppendProof memory proof)\n    {\n        require(encoded.length - offset >= 32 * cellNum, \"Proof Underflow\");\n        proof.appendCells = new bytes32[](cellNum);\n        for (uint64 i = 0; i < cellNum; i++) {\n            proof.appendCells[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        return (offset, proof);\n    }\n\n    struct MemoryCombinedReadProof {\n        bytes32[] cells;\n        bytes32[] appendCells;\n    }\n\n    function decodeMemoryCombinedReadProof(bytes calldata encoded, uint64 offset, uint64 cellNum, uint64 appendCellNum)\n        internal\n        pure\n        returns (uint64, MemoryCombinedReadProof memory proof)\n    {\n        require(encoded.length - offset >= 32 * (cellNum + appendCellNum), \"Proof Underflow\");\n        proof.cells = new bytes32[](cellNum);\n        for (uint64 i = 0; i < cellNum; i++) {\n            proof.cells[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        proof.appendCells = new bytes32[](appendCellNum);\n        for (uint64 i = 0; i < appendCellNum; i++) {\n            proof.appendCells[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        return (offset, proof);\n    }\n\n    struct MemoryCombinedWriteProof {\n        bytes32[] cells;\n        bytes32[] updatedCells;\n        bytes32[] appendCells;\n    }\n\n    function decodeMemoryCombinedWriteProof(bytes calldata encoded, uint64 offset, uint64 cellNum, uint64 appendCellNum)\n        internal\n        pure\n        returns (uint64, MemoryCombinedWriteProof memory proof)\n    {\n        require(encoded.length - offset >= 32 * (2 * cellNum + appendCellNum), \"Proof Underflow\");\n        proof.cells = new bytes32[](cellNum);\n        for (uint64 i = 0; i < cellNum; i++) {\n            proof.cells[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        proof.updatedCells = new bytes32[](cellNum);\n        for (uint64 i = 0; i < cellNum; i++) {\n            proof.updatedCells[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        proof.appendCells = new bytes32[](appendCellNum);\n        for (uint64 i = 0; i < appendCellNum; i++) {\n            proof.appendCells[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        return (offset, proof);\n    }\n\n    // For MPT proof, receipt proof\n    struct RLPProof {\n        RLPReader.RLPItem proof;\n    }\n\n    function decodeRLPProof(bytes calldata encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, RLPProof memory proof)\n    {\n        require(encoded.length - offset >= 8, \"Proof Underflow\");\n        uint64 len = encoded.toUint64(offset);\n        offset += 8;\n        require(encoded.length - offset >= len, \"Proof Underflow\");\n        proof.proof = encoded.slice(offset, len).toRlpItem();\n        return (offset + len, proof);\n    }\n\n    struct BlockHashProof {\n        bytes32 blockHash;\n    }\n\n    function decodeBlockHashProof(bytes calldata encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, BlockHashProof memory proof)\n    {\n        require(encoded.length - offset >= 32, \"Proof Underflow\");\n        proof.blockHash = encoded.toBytes32(offset);\n        return (offset + 32, proof);\n    }\n\n    struct BlockHashMerkleProof {\n        uint64 path;\n        bytes32[] proof;\n    }\n\n    function decodeBlockHashMerkleProof(bytes memory encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, BlockHashMerkleProof memory proof)\n    {\n        require(encoded.length - offset >= 9, \"Proof Underflow\");\n        proof.path = encoded.toUint64(offset);\n        uint8 len = encoded.toUint8(offset + 8);\n        offset += 9;\n        require(encoded.length - offset >= 32 * len, \"Proof Underflow\");\n        proof.proof = new bytes32[](len);\n        for (uint64 i = 0; i < len; i++) {\n            proof.proof[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        return (offset, proof);\n    }\n\n    struct LogProof {\n        bytes32 accumulateHash;\n        BloomLib.Bloom bloom;\n    }\n\n    function decodeLogProof(bytes calldata encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, LogProof memory proof)\n    {\n        require(encoded.length - offset >= 288, \"Proof Underflow\");\n        proof.accumulateHash = encoded.toBytes32(offset);\n        proof.bloom = BloomLib.decodeBloom(encoded, offset + 32);\n        return (offset + 288, proof);\n    }\n\n    function hashLogProof(LogProof memory proof) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(proof.accumulateHash, proof.bloom.data));\n    }\n\n    struct SelfDestructSetProof {\n        address[] contracts;\n    }\n\n    function decodeSelfDestructSetProof(bytes calldata encoded, uint64 offset)\n        internal\n        pure\n        returns (uint64, SelfDestructSetProof memory proof)\n    {\n        require(encoded.length - offset >= 8, \"Proof Underflow\");\n        uint64 len = encoded.toUint64(offset);\n        offset += 8;\n        require(encoded.length - offset >= 20 * len, \"Proof Underflow\");\n        proof.contracts = new address[](len);\n        for (uint64 i = 0; i < len; i++) {\n            proof.contracts[i] = encoded.toAddress(offset);\n            offset += 20;\n        }\n        return (offset, proof);\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/libraries/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\n\npragma solidity ^0.8.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\n    * @param self The iterator.\n    * @return The next element in the iteration.\n    */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n    * @dev Returns true if the iteration has more elements.\n    * @param self The iterator.\n    * @return true if the iteration has more elements.\n    */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n    * @dev Create an iterator. Reverts if item is not a list.\n    * @param self The RLP item.\n    * @return An 'Iterator' over the item.\n    */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n    * @param the RLP item.\n    */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     * @return RLPItem of (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadToRlpItem(RLPItem memory item) internal pure returns (RLPItem memory) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return RLPItem(memPtr, len);\n    }\n\n    /*\n    * @param the RLP item.\n    */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n    * @param the RLP item containing the encoded list.\n    */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) {\n            return false;\n        }\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /**\n     * RLPItem conversions into data types *\n     */\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) { result := div(result, exp(256, sub(32, len))) }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n    * Private Helpers\n    */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (\n            byte0 < LIST_SHORT_START // being explicit\n        ) {\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/libraries/BloomLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BytesLib.sol\";\n\nlibrary BloomLib {\n    using BytesLib for bytes;\n\n    struct Bloom {\n        bytes32[8] data;\n    }\n\n    function emptyBloom() internal pure returns (Bloom memory b) {\n        return b;\n    }\n\n    function decodeBloom(bytes calldata encoded, uint64 offset) internal pure returns (Bloom memory) {\n        Bloom memory bloom;\n        for (uint256 i = 0; i < 8; i++) {\n            bloom.data[i] = encoded.toBytes32(offset);\n            offset += 32;\n        }\n        return bloom;\n    }\n\n    function addHash(Bloom memory bloom, bytes32 h) internal pure {\n        uint16 i1 = 255 - (uint16(uint256(h) >> 240) & 0x7ff) >> 3;\n        uint8 v1 = uint8(1 << (uint8(h[1]) & 0x7));\n        bloom.data[i1 >> 5] = bytes32(uint256(bloom.data[i1 >> 5]) | (uint256(v1) << 8 * (31 - (i1 & 0x1f))));\n        uint16 i2 = 255 - (uint16(uint256(h) >> 224) & 0x7ff) >> 3;\n        uint8 v2 = uint8(1 << (uint8(h[3]) & 0x7));\n        bloom.data[i2 >> 5] = bytes32(uint256(bloom.data[i2 >> 5]) | (uint256(v2) << 8 * (31 - (i2 & 0x1f))));\n        uint16 i3 = 255 - (uint16(uint256(h) >> 208) & 0x7ff) >> 3;\n        uint8 v3 = uint8(1 << (uint8(h[5]) & 0x7));\n        bloom.data[i3 >> 5] = bytes32(uint256(bloom.data[i3 >> 5]) | (uint256(v3) << 8 * (31 - (i3 & 0x1f))));\n    }\n\n    function add(Bloom memory bloom, bytes memory data) internal pure {\n        bytes32 h;\n        assembly {\n            h := keccak256(add(data, 0x20), mload(data))\n        }\n        addHash(bloom, h);\n    }\n\n    function add(Bloom memory bloom, address data) internal pure {\n        bytes32 h = keccak256(abi.encodePacked(data));\n        addHash(bloom, h);\n    }\n\n    function add(Bloom memory bloom, bytes32 data) internal pure {\n        bytes32 h = keccak256(abi.encodePacked(data));\n        addHash(bloom, h);\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/libraries/RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\n * @title RLPWriter\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\n *         modifications to improve legibility.\n */\nlibrary RLPWriter {\n    /**\n     * @notice RLP encodes a byte string.\n     *\n     * @param _in The byte string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\n     *\n     * @param _in The list of RLP encoded byte strings.\n     *\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * @notice RLP encodes a string.\n     *\n     * @param _in The string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * @notice RLP encodes an address.\n     *\n     * @param _in The address to encode.\n     *\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * @notice RLP encodes a uint.\n     *\n     * @param _in The uint256 to encode.\n     *\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * @notice RLP encodes a bool.\n     *\n     * @param _in The bool to encode.\n     *\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\n     *\n     * @param _len    The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes.\n     *\n     * @param _x The integer to encode.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\n     * @notice Copies a piece of memory to another location.\n     *\n     * @param _dest Destination location.\n     * @param _src  Source location.\n     * @param _len  Length of memory to copy.\n     */\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256 ** (32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\n     * @notice Flattens a list of byte strings into one byte string.\n     *\n     * @param _list List of byte strings to flatten.\n     *\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/test-driver/VerifierTestDriver.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../IVerifier.sol\";\nimport \"../libraries/Params.sol\";\nimport \"../libraries/EVMTypesLib.sol\";\nimport \"../libraries/VerificationContext.sol\";\n\ncontract VerifierTestDriver {\n    IVerifier blockInitiationVerifier;\n    IVerifier blockFinalizationVerifier;\n    IVerifier interTxVerifier;\n    IVerifier stackOpVerifier;\n    IVerifier environmentalOpVerifier;\n    IVerifier memoryOpVerifier;\n    IVerifier storageOpVerifier;\n    IVerifier callOpVerifier;\n    IVerifier invalidOpVerifier;\n\n    constructor(\n        address _blockInitiationVerifier,\n        address _blockFinalizationVerifier,\n        address _interTxVerifier,\n        address _stackOpVerifier,\n        address _environmentalOpVerifier,\n        address _memoryOpVerifier,\n        address _storageOpVerifier,\n        address _callOpVerifier,\n        address _invalidOpVerifier\n    ) {\n        blockInitiationVerifier = IVerifier(_blockInitiationVerifier);\n        blockFinalizationVerifier = IVerifier(_blockFinalizationVerifier);\n        interTxVerifier = IVerifier(_interTxVerifier);\n        stackOpVerifier = IVerifier(_stackOpVerifier);\n        environmentalOpVerifier = IVerifier(_environmentalOpVerifier);\n        memoryOpVerifier = IVerifier(_memoryOpVerifier);\n        storageOpVerifier = IVerifier(_storageOpVerifier);\n        callOpVerifier = IVerifier(_callOpVerifier);\n        invalidOpVerifier = IVerifier(_invalidOpVerifier);\n    }\n\n    function getVerifier(uint8 verifier) private view returns (IVerifier) {\n        if (verifier == Params.V_BLOCK_INIT) {\n            return blockInitiationVerifier;\n        } else if (verifier == Params.V_BLOCK_FINAL) {\n            return blockFinalizationVerifier;\n        } else if (verifier == Params.V_INTER_TX) {\n            return interTxVerifier;\n        } else if (verifier == Params.V_STACK_OP) {\n            return stackOpVerifier;\n        } else if (verifier == Params.V_ENVIRONMENTAL_OP) {\n            return environmentalOpVerifier;\n        } else if (verifier == Params.V_MEMORY_OP) {\n            return memoryOpVerifier;\n        } else if (verifier == Params.V_STORAGE_OP) {\n            return storageOpVerifier;\n        } else if (verifier == Params.V_CALL_OP) {\n            return callOpVerifier;\n        } else if (verifier == Params.V_INVALID_OP) {\n            return invalidOpVerifier;\n        } else {\n            revert(\"unreachable\");\n        }\n    }\n\n    function verifyProof(\n        address sequencerAddress,\n        uint256 timestamp,\n        uint256 number,\n        address origin,\n        bytes32 txHash,\n        EVMTypesLib.Transaction memory transaction,\n        uint8 verifier,\n        bytes32 currStateHash,\n        bytes calldata proof\n    ) external view returns (bytes32) {\n        VerificationContext.Context memory ctx =\n            VerificationContext.Context(sequencerAddress, timestamp, number, origin, transaction, bytes32(0), txHash);\n        bytes32 res = getVerifier(verifier).verifyOneStepProof(ctx, currStateHash, proof);\n        return res;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/subverifiers/InterTxVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BytesLib.sol\";\nimport \"../../libraries/MPT.sol\";\nimport \"../IVerifier.sol\";\nimport \"../libraries/VerificationContext.sol\";\nimport \"../libraries/OneStepProof.sol\";\nimport \"../libraries/Params.sol\";\nimport \"../libraries/GasTable.sol\";\nimport \"../libraries/VerifierHelper.sol\";\nimport \"../libraries/EVMTypesLib.sol\";\n\ncontract InterTxVerifier is IVerifier {\n    using BytesLib for bytes;\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n    using VerificationContext for VerificationContext.Context;\n    using OneStepProof for OneStepProof.InterStateProof;\n    using OneStepProof for EVMTypesLib.Account;\n\n    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        return OneStepProof.hashStateProof(executeOneStepProof(ctx, currStateHash, encoded));\n    }\n\n    function executeOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        public\n        pure\n        returns (OneStepProof.StateProof memory)\n    {\n        uint64 offset = 0;\n        // Decode inter-state proof\n        OneStepProof.InterStateProof memory stateProof;\n        (offset, stateProof) = OneStepProof.decodeInterStateProof(encoded, offset);\n        // Calculate the state hash from the submitted proof\n        bytes32 stateHashFromProof;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, encoded.offset, encoded.length)\n            stateHashFromProof := keccak256(ptr, offset)\n        }\n        // Ensure the state proof is valid\n        require(stateHashFromProof == currStateHash, \"Bad State Proof\");\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/libraries/MPT.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./RLPReader.sol\";\n\nlibrary MPT {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    /// @dev Validates a Merkle-Patricia-Trie proof.\n    ///      If the proof proves the inclusion of some key-value pair in the\n    ///      trie, the value is returned. Otherwise, i.e. if the proof proves\n    ///      the exclusion of a key from the trie, an empty byte array is\n    ///      returned.\n    /// @param rootHash is the Keccak-256 hash of the root node of the MPT.\n    /// @param path is the key of the node whose inclusion/exclusion we are\n    ///        proving.\n    /// @param stack is the stack of MPT nodes (starting with the root) that\n    ///        need to be traversed during verification.\n    /// @return value whose inclusion is proved or an empty byte array for\n    ///         a proof of exclusion\n    function extractProofValue(bytes32 rootHash, bytes memory path, RLPReader.RLPItem[] memory stack)\n        internal\n        pure\n        returns (bytes memory value)\n    {\n        bytes memory mptKey = _decodeNibbles(path, 0);\n        uint256 mptKeyOffset = 0;\n\n        bytes32 nodeHashHash;\n        RLPReader.RLPItem[] memory node;\n\n        RLPReader.RLPItem memory rlpValue;\n\n        if (stack.length == 0) {\n            // Root hash of empty Merkle-Patricia-Trie\n            require(rootHash == 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421);\n            return new bytes(0);\n        }\n\n        // Traverse stack of nodes starting at root.\n        for (uint256 i = 0; i < stack.length; i++) {\n            // We use the fact that an rlp encoded list consists of some\n            // encoding of its length plus the concatenation of its\n            // *rlp-encoded* items.\n\n            // The root node is hashed with Keccak-256 ...\n            if (i == 0 && rootHash != stack[i].rlpBytesKeccak256()) {\n                revert();\n            }\n            // ... whereas all other nodes are hashed with the MPT\n            // hash function.\n            if (i != 0 && nodeHashHash != _mptHashHash(stack[i])) {\n                revert();\n            }\n            // We verified that stack[i] has the correct hash, so we\n            // may safely decode it.\n            node = stack[i].toBytes().toRlpItem().toList();\n\n            if (node.length == 2) {\n                // Extension or Leaf node\n\n                bool isLeaf;\n                bytes memory nodeKey;\n                (isLeaf, nodeKey) = _merklePatriciaCompactDecode(node[0].toBytes());\n\n                uint256 prefixLength = _sharedPrefixLength(mptKeyOffset, mptKey, nodeKey);\n                mptKeyOffset += prefixLength;\n\n                if (prefixLength < nodeKey.length) {\n                    // Proof claims divergent extension or leaf. (Only\n                    // relevant for proofs of exclusion.)\n                    // An Extension/Leaf node is divergent iff it \"skips\" over\n                    // the point at which a Branch node should have been had the\n                    // excluded key been included in the trie.\n                    // Example: Imagine a proof of exclusion for path [1, 4],\n                    // where the current node is a Leaf node with\n                    // path [1, 3, 3, 7]. For [1, 4] to be included, there\n                    // should have been a Branch node at [1] with a child\n                    // at 3 and a child at 4.\n\n                    // Sanity check\n                    if (i < stack.length - 1) {\n                        // divergent node must come last in proof\n                        revert();\n                    }\n\n                    return new bytes(0);\n                }\n\n                if (isLeaf) {\n                    // Sanity check\n                    if (i < stack.length - 1) {\n                        // leaf node must come last in proof\n                        revert();\n                    }\n\n                    if (mptKeyOffset < mptKey.length) {\n                        return new bytes(0);\n                    }\n\n                    rlpValue = node[1];\n                    return rlpValue.toBytes();\n                } else {\n                    // extension\n                    // Sanity check\n                    if (i == stack.length - 1) {\n                        // shouldn't be at last level\n                        revert();\n                    }\n\n                    if (!node[1].isList()) {\n                        // rlp(child) was at least 32 bytes. node[1] contains\n                        // Keccak256(rlp(child)).\n                        nodeHashHash = node[1].payloadKeccak256();\n                    } else {\n                        // rlp(child) was less than 32 bytes. node[1] contains\n                        // rlp(child).\n                        nodeHashHash = node[1].rlpBytesKeccak256();\n                    }\n                }\n            } else if (node.length == 17) {\n                // Branch node\n\n                if (mptKeyOffset != mptKey.length) {\n                    // we haven't consumed the entire path, so we need to look at a child\n                    uint8 nibble = uint8(mptKey[mptKeyOffset]);\n                    mptKeyOffset += 1;\n                    if (nibble >= 16) {\n                        // each element of the path has to be a nibble\n                        revert();\n                    }\n\n                    if (_isEmptyBytesequence(node[nibble])) {\n                        // Sanity\n                        if (i != stack.length - 1) {\n                            // leaf node should be at last level\n                            revert();\n                        }\n\n                        return new bytes(0);\n                    } else if (!node[nibble].isList()) {\n                        nodeHashHash = node[nibble].payloadKeccak256();\n                    } else {\n                        nodeHashHash = node[nibble].rlpBytesKeccak256();\n                    }\n                } else {\n                    // we have consumed the entire mptKey, so we need to look at what's contained in this node.\n\n                    // Sanity\n                    if (i != stack.length - 1) {\n                        // should be at last level\n                        revert();\n                    }\n\n                    return node[16].toBytes();\n                }\n            }\n        }\n    }\n\n    function verifyAndUpdateProofValue(\n        bytes32 rootHash,\n        bytes memory path,\n        bytes memory oldValue,\n        bytes memory newValue,\n        bytes memory rawProof\n    ) internal pure returns (bytes32 newRoot) {\n        return 0;\n    }\n\n    /// @dev Computes the hash of the Merkle-Patricia-Trie hash of the RLP item.\n    ///      Merkle-Patricia-Tries use a weird \"hash function\" that outputs\n    ///      *variable-length* hashes: If the item is shorter than 32 bytes,\n    ///      the MPT hash is the item. Otherwise, the MPT hash is the\n    ///      Keccak-256 hash of the item.\n    ///      The easiest way to compare variable-length byte sequences is\n    ///      to compare their Keccak-256 hashes.\n    /// @param item The RLP item to be hashed.\n    /// @return Keccak-256(MPT-hash(item))\n    function _mptHashHash(RLPReader.RLPItem memory item) private pure returns (bytes32) {\n        if (item.len < 32) {\n            return item.rlpBytesKeccak256();\n        } else {\n            return keccak256(abi.encodePacked(item.rlpBytesKeccak256()));\n        }\n    }\n\n    function _isEmptyBytesequence(RLPReader.RLPItem memory item) private pure returns (bool) {\n        if (item.len != 1) {\n            return false;\n        }\n        uint8 b;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            b := byte(0, mload(memPtr))\n        }\n        return b == 0x80; /* empty byte string */\n    }\n\n    function _merklePatriciaCompactDecode(bytes memory compact)\n        private\n        pure\n        returns (bool isLeaf, bytes memory nibbles)\n    {\n        require(compact.length > 0);\n        uint256 first_nibble = uint8(compact[0]) >> 4 & 0xF;\n        uint256 skipNibbles;\n        if (first_nibble == 0) {\n            skipNibbles = 2;\n            isLeaf = false;\n        } else if (first_nibble == 1) {\n            skipNibbles = 1;\n            isLeaf = false;\n        } else if (first_nibble == 2) {\n            skipNibbles = 2;\n            isLeaf = true;\n        } else if (first_nibble == 3) {\n            skipNibbles = 1;\n            isLeaf = true;\n        } else {\n            // Not supposed to happen!\n            revert();\n        }\n        return (isLeaf, _decodeNibbles(compact, skipNibbles));\n    }\n\n    function _decodeNibbles(bytes memory compact, uint256 skipNibbles) private pure returns (bytes memory nibbles) {\n        require(compact.length > 0);\n\n        uint256 length = compact.length * 2;\n        require(skipNibbles <= length);\n        length -= skipNibbles;\n\n        nibbles = new bytes(length);\n        uint256 nibblesLength = 0;\n\n        for (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\n            if (i % 2 == 0) {\n                nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 4) & 0xF);\n            } else {\n                nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 0) & 0xF);\n            }\n            nibblesLength += 1;\n        }\n\n        assert(nibblesLength == nibbles.length);\n    }\n\n    function _sharedPrefixLength(uint256 xsOffset, bytes memory xs, bytes memory ys) private pure returns (uint256) {\n        uint256 i;\n        for (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\n            if (xs[i + xsOffset] != ys[i]) {\n                return i;\n            }\n        }\n        return i;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/libraries/GasTable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BitLen.sol\";\nimport \"./Params.sol\";\n\nlibrary GasTable {\n    using BitLen for uint256;\n\n    function costMemory(uint64 mwords) internal pure returns (uint64) {\n        return Params.G_MEMORY * mwords + mwords * mwords / 512;\n    }\n\n    function gasMemory(uint64 msize, uint64 offset, uint64 length) internal pure returns (uint64) {\n        if (length == 0) {\n            return 0;\n        }\n        uint64 newMwords = (offset + length + 31) / 32;\n        uint64 mwords = (msize + 31) / 32;\n        if (newMwords <= mwords) {\n            return 0;\n        }\n        return costMemory(newMwords) - costMemory(mwords);\n    }\n\n    function gasExp(uint256 exponent) internal pure returns (uint64) {\n        if (exponent == 0) {\n            return Params.G_EXP;\n        } else {\n            return Params.G_EXP + Params.G_EXPBYTE * ((exponent.bitLen() + 7) / 8);\n        }\n    }\n\n    function gasKeccak(uint64 msize, uint64 offset, uint64 length) internal pure returns (uint64) {\n        return gasMemory(msize, offset, length) + Params.G_KECCAK + Params.G_KECCAKWORD * ((length + 31) / 32);\n    }\n\n    function gasCopy(uint64 msize, uint64 offset, uint64 length) internal pure returns (uint64) {\n        return gasMemory(msize, offset, length) + Params.G_VERYLOW + Params.G_COPY * ((length + 31) / 32);\n    }\n\n    function gasExtCopy(uint64 msize, uint64 offset, uint64 length) internal pure returns (uint64) {\n        return gasMemory(msize, offset, length) + Params.G_EXTCODE + Params.G_COPY * ((length + 31) / 32);\n    }\n\n    function gasLog(uint64 msize, uint64 offset, uint64 length, uint64 topicNum) internal pure returns (uint64) {\n        return gasMemory(msize, offset, length) + Params.G_LOG + Params.G_LOGTOPIC * topicNum\n            + Params.G_LOGDATA * ((length + 31) / 32);\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/libraries/VerifierHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"./OneStepProof.sol\";\nimport \"./VerificationContext.sol\";\nimport \"./EVMTypesLib.sol\";\nimport \"./BloomLib.sol\";\nimport \"./Params.sol\";\n\nlibrary VerifierHelper {\n    using VerificationContext for VerificationContext.Context;\n    using BloomLib for BloomLib.Bloom;\n    using OneStepProof for OneStepProof.LogProof;\n\n    function decodeAndVerifyStackProof(\n        OneStepProof.StateProof memory stateProof,\n        uint64 popNum,\n        uint64 offset,\n        bytes calldata encoded\n    ) internal pure returns (uint64, OneStepProof.StackProof memory stackProof) {\n        // Decode StackProof\n        (offset, stackProof) = OneStepProof.decodeStackProof(encoded, offset, popNum);\n        if (popNum != 0) {\n            // Reconstruct the stack hash before pops\n            bytes32 h = stackProof.stackHashAfterPops;\n            for (uint8 i = uint8(stackProof.pops.length); i > 0; i--) {\n                h = keccak256(abi.encodePacked(h, stackProof.pops[i - 1]));\n            }\n            // Ensure the stack hash reconstructed is the same as the stack hash in stateProof\n            require(h == stateProof.stackHash, \"Bad StackProof\");\n        } else {\n            // If no pop, the stackHashAfterPops is just the current stack hash\n            stackProof.stackHashAfterPops = stateProof.stackHash;\n        }\n        return (offset, stackProof);\n    }\n\n    function decodeAndVerifyBlockHashProof(\n        uint64 offset,\n        bytes calldata encoded,\n        uint64 blockNumber,\n        bytes32 blockHashRoot\n    ) internal pure returns (uint64, bytes32) {\n        OneStepProof.BlockHashProof memory blockHashProof;\n        (offset, blockHashProof) = OneStepProof.decodeBlockHashProof(encoded, offset);\n        OneStepProof.BlockHashMerkleProof memory blockHashMerkleProof;\n        (offset, blockHashMerkleProof) = OneStepProof.decodeBlockHashMerkleProof(encoded, offset);\n        // Verify blockhash\n        bytes32 h = blockHashProof.blockHash;\n        uint64 path = blockHashMerkleProof.path;\n        uint64 num = 0;\n        for (uint8 i = 0; i < blockHashMerkleProof.proof.length; i++) {\n            if (path & 0x1 == 1) {\n                h = keccak256(abi.encodePacked(h, blockHashMerkleProof.proof[i]));\n                num |= uint64(1 << i);\n            } else {\n                h = keccak256(abi.encodePacked(blockHashMerkleProof.proof[i], h));\n            }\n            path = path >> 1;\n        }\n        require(h == blockHashRoot, \"Bad BlockHashProof\");\n        require(num == blockNumber, \"Bad BlockHashProof\");\n\n        return (offset, blockHashProof.blockHash);\n    }\n\n    function decodeAndInsertBlockHashProof(\n        uint64 offset,\n        bytes calldata encoded,\n        uint64 blockNumber,\n        bytes32 blockHashRoot,\n        bytes32 newBlockHash\n    ) internal pure returns (uint64, bytes32) {\n        OneStepProof.BlockHashProof memory blockHashProof;\n        (offset, blockHashProof) = OneStepProof.decodeBlockHashProof(encoded, offset);\n        OneStepProof.BlockHashMerkleProof memory blockHashMerkleProof;\n        (offset, blockHashMerkleProof) = OneStepProof.decodeBlockHashMerkleProof(encoded, offset);\n        // Verify blockhash\n        bytes32 h = blockHashProof.blockHash;\n        uint64 path = blockHashMerkleProof.path;\n        uint64 num = 0;\n        for (uint8 i = 0; i < blockHashMerkleProof.proof.length; i++) {\n            if (path & 0x1 == 1) {\n                h = keccak256(abi.encodePacked(h, blockHashMerkleProof.proof[i]));\n                num |= uint64(1 << i);\n            } else {\n                h = keccak256(abi.encodePacked(blockHashMerkleProof.proof[i], h));\n            }\n            path = path >> 1;\n        }\n        require(h == blockHashRoot, \"Bad BlockHashProof\");\n        require(num == blockNumber, \"Bad BlockHashProof\");\n\n        h = newBlockHash;\n        path = blockHashMerkleProof.path;\n        for (uint8 i = 0; i < blockHashMerkleProof.proof.length; i++) {\n            if (path & 0x1 == 1) {\n                h = keccak256(abi.encodePacked(h, blockHashMerkleProof.proof[i]));\n            } else {\n                h = keccak256(abi.encodePacked(blockHashMerkleProof.proof[i], h));\n            }\n            path = path >> 1;\n        }\n        // h is the new root now\n        return (offset, h);\n    }\n\n    function updateAndHashLogProof(\n        OneStepProof.LogProof memory logProof,\n        address addr,\n        uint256[] memory topics,\n        bytes memory data\n    ) internal pure returns (bytes32) {\n        bytes32 logHash = EVMTypesLib.hashLogEntry(addr, topics, data);\n        logProof.accumulateHash = keccak256(abi.encodePacked(logProof.accumulateHash, logHash));\n        logProof.bloom.add(addr);\n        for (uint8 i = 0; i < topics.length; i++) {\n            logProof.bloom.add(bytes32(topics[i]));\n        }\n        return logProof.hashLogProof();\n    }\n\n    function verifyRevertByError(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n        returns (OneStepProof.StateProof memory)\n    {\n        bytes32 lastDepthHash = stateProof.lastDepthHash;\n        if (stateProof.depth == 1) {}\n        // require(offset == encoded.length, \"Proof Overflow\");\n        return stateProof;\n    }\n\n    function verifyTransfer(bytes32 worldState, uint256 value, uint64 offset, bytes calldata encoded)\n        internal\n        pure\n        returns (bytes32)\n    {}\n\n    function verifyTransactionInitiation(\n        VerificationContext.Context memory ctx,\n        OneStepProof.InterStateProof memory stateProof,\n        EVMTypesLib.Account memory senderAccountProof,\n        uint64 offset,\n        bytes calldata encoded\n    ) internal pure returns (bytes32) {}\n\n    function hashBlockHeader(\n        VerificationContext.Context memory ctx,\n        bytes32 parentBlockHash,\n        OneStepProof.InterStateProof memory stateProof\n    ) internal pure returns (bytes32) {\n        EVMTypesLib.BlockHeader memory blockHeader;\n        blockHeader.parentHash = parentBlockHash;\n        blockHeader.ommerHash = Params.EMPTY_UNCLE_HASH;\n        blockHeader.beneficiary = ctx.getCoinbase();\n        blockHeader.stateRoot = stateProof.globalStateRoot;\n        blockHeader.transactionRoot = stateProof.transactionTrieRoot;\n        blockHeader.receiptsRoot = stateProof.receiptTrieRoot;\n        blockHeader.difficulty = ctx.getDifficulty();\n        blockHeader.number = stateProof.blockNumber;\n        blockHeader.gasLimit = ctx.getGasLimit();\n        blockHeader.gasUsed = uint64(stateProof.blockGasUsed);\n        blockHeader.timestamp = uint64(ctx.getTimestamp());\n        blockHeader.logsBloom = stateProof.logsBloom;\n        return EVMTypesLib.hashBlockHeader(blockHeader);\n    }\n\n    function BuildCreateState(\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StackProof memory stackProof,\n        EVMTypesLib.Account memory accountProof,\n        OneStepProof.MemoryReadProof memory memoryReadProof\n    ) internal pure {}\n\n    function BuildCreate2State(\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StackProof memory stackProof,\n        EVMTypesLib.Account memory accountProof,\n        OneStepProof.MemoryReadProof memory memoryReadProof\n    ) internal pure {}\n\n    function BuildCallState(\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StackProof memory stackProof,\n        EVMTypesLib.Account memory accountProof,\n        OneStepProof.MemoryReadProof memory memoryReadProof\n    ) internal pure {}\n\n    function BuildCallCodeState(\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StackProof memory stackProof,\n        EVMTypesLib.Account memory accountProof,\n        OneStepProof.MemoryReadProof memory memoryReadProof\n    ) internal pure {}\n\n    function BuildDelegateCallState(\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StackProof memory stackProof,\n        EVMTypesLib.Account memory accountProof,\n        OneStepProof.MemoryReadProof memory memoryReadProof\n    ) internal pure {}\n\n    function BuildStaticCallState(\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StackProof memory stackProof,\n        EVMTypesLib.Account memory accountProof,\n        OneStepProof.MemoryReadProof memory memoryReadProof\n    ) internal pure {}\n\n    function BuildIntraReturnState(\n        VerificationContext.Context memory ctx,\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StateProof memory lastStateProof,\n        OneStepProof.StackProof memory stackProof,\n        OneStepProof.MemoryReadProof memory memoryReadProof,\n        OneStepProof.MemoryWriteProof memory memoryWriteProof\n    ) internal pure {}\n\n    function BuildInterReturnState(\n        VerificationContext.Context memory ctx,\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.InterStateProof memory lastStateProof,\n        OneStepProof.StackProof memory stackProof\n    ) internal pure {}\n\n    function BuildIntraRevertState(\n        VerificationContext.Context memory ctx,\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StateProof memory lastStateProof,\n        OneStepProof.StackProof memory stackProof,\n        OneStepProof.MemoryReadProof memory memoryReadProof,\n        OneStepProof.MemoryWriteProof memory memoryWriteProof\n    ) internal pure {}\n\n    function BuildInterRevertState(\n        VerificationContext.Context memory ctx,\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.InterStateProof memory lastStateProof,\n        OneStepProof.StackProof memory stackProof\n    ) internal pure {}\n\n    function BuildIntraSuicideState(\n        VerificationContext.Context memory ctx,\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StateProof memory lastStateProof,\n        OneStepProof.StackProof memory stackProof,\n        OneStepProof.MemoryReadProof memory memoryReadProof,\n        OneStepProof.MemoryWriteProof memory memoryWriteProof\n    ) internal pure {}\n\n    function BuildInterSuicideState(\n        VerificationContext.Context memory ctx,\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.InterStateProof memory lastStateProof,\n        OneStepProof.StackProof memory stackProof\n    ) internal pure {}\n}\n"
    },
    "contracts/L1/fraud-proof/libraries/BitLen.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\n// For EXP opcode gas calculation\n// Based on go packages `math/bits` and `holiman/uint256`\n// TODO: seems for EXP we only need bytelen\nlibrary BitLen {\n    uint64 constant UINT16_MINIMUM = 1 << 8;\n    uint64 constant UINT32_MINIMUM = 1 << 16;\n    uint64 constant UINT64_MINIMUM = 1 << 32;\n    uint256 constant UINT128_MINIMUM = 1 << 64;\n    uint256 constant UINT192_MINIMUM = 1 << 128;\n    uint256 constant UINT256_MINIMUM = 1 << 192;\n\n    function len8(uint8 x) internal pure returns (uint64 n) {\n        if (x == 0) {\n            return 0;\n        } else if (x == 1) {\n            return 1;\n        } else if (x <= 3) {\n            return 2;\n        } else if (x <= 7) {\n            return 3;\n        } else if (x <= 15) {\n            return 4;\n        } else if (x <= 31) {\n            return 5;\n        } else if (x <= 63) {\n            return 6;\n        } else if (x <= 127) {\n            return 7;\n        }\n        return 8;\n    }\n\n    function len64(uint64 x) internal pure returns (uint64 n) {\n        if (x >= UINT64_MINIMUM) {\n            x >>= 32;\n            n = 32;\n        }\n        if (x >= UINT32_MINIMUM) {\n            x >>= 16;\n            n += 16;\n        }\n        if (x >= UINT16_MINIMUM) {\n            x >>= 8;\n            n += 8;\n        }\n        return n + len8(uint8(x));\n    }\n\n    function bitLen(uint256 x) internal pure returns (uint64) {\n        if (x >= UINT256_MINIMUM) {\n            return 192 + len64(uint64(x >> 192));\n        } else if (x >= UINT192_MINIMUM) {\n            return 128 + len64(uint64(x >> 128));\n        } else if (x >= UINT128_MINIMUM) {\n            return 64 + len64(uint64(x >> 64));\n        }\n        return len64(uint64(x));\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/subverifiers/StackOpVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BytesLib.sol\";\nimport \"../IVerifier.sol\";\nimport \"../libraries/VerificationContext.sol\";\nimport \"../libraries/OneStepProof.sol\";\nimport \"../libraries/Params.sol\";\nimport \"../libraries/GasTable.sol\";\nimport \"../libraries/VerifierHelper.sol\";\n\ncontract StackOpVerifier is IVerifier {\n    using BytesLib for bytes;\n    using VerificationContext for VerificationContext.Context;\n    using OneStepProof for OneStepProof.CodeProof;\n\n    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        return OneStepProof.hashStateProof(executeOneStepProof(ctx, currStateHash, encoded));\n    }\n\n    function executeOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        public\n        pure\n        returns (OneStepProof.StateProof memory)\n    {\n        uint64 offset = 0;\n        // Decode state proof\n        OneStepProof.StateProof memory stateProof;\n        (offset, stateProof) = OneStepProof.decodeStateProof(ctx, encoded, offset);\n        // Calculate the state hash from the submitted proof\n        bytes32 stateHashFromProof;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, encoded.offset, offset)\n            stateHashFromProof := keccak256(ptr, offset)\n        }\n        // Ensure the state proof is valid\n        require(stateHashFromProof == currStateHash, \"Bad State Proof\");\n\n        // Decode the code proof\n        OneStepProof.CodeProof memory codeProof;\n        (offset, codeProof) = OneStepProof.decodeCodeProof(encoded, offset);\n\n        // Simulate EVM one-step execution based on the opcode\n        uint8 opCode = stateProof.opCode;\n        if (opCode == 0x01) {\n            // ADD\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x02) {\n            // MUL\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x03) {\n            // SUB\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x04) {\n            // DIV\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x05) {\n            // SDIV\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x06) {\n            // MOD\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x07) {\n            // SMOD\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x08) {\n            // ADDMOD\n            verifyTrinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x09) {\n            // MULMOD\n            verifyTrinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x0a) {\n            // EXP\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x0b) {\n            // SIGNEXTEND\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x10) {\n            // LT\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x11) {\n            // GT\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x12) {\n            // SLT\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x13) {\n            // SGT\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x14) {\n            // EQ\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x15) {\n            // ISZERO\n            verifyUnaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x16) {\n            // AND\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x17) {\n            // OR\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x18) {\n            // XOR\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x19) {\n            // NOT\n            verifyUnaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x1a) {\n            // BYTE\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x1b) {\n            // SHL\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x1c) {\n            // SHR\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x1d) {\n            // SAR\n            verifyBinaryOpCode(offset, stateProof, encoded);\n        } else if (opCode == 0x50) {\n            // POP\n            verifyOpPOP(offset, stateProof, encoded);\n        } else if (opCode == 0x56) {\n            // JUMP\n            verifyOpJUMP(offset, stateProof, encoded);\n        } else if (opCode == 0x57) {\n            // JUMPI\n            verifyOpJUMPI(offset, stateProof, encoded);\n        } else if (opCode == 0x58) {\n            // PC\n            verifyOpPC(offset, stateProof, encoded);\n        } else if (opCode == 0x59) {\n            // MSIZE\n            verifyOpMSIZE(offset, stateProof, encoded);\n        } else if (opCode == 0x5a) {\n            // GAS\n            verifyOpJUMPDEST(offset, stateProof, encoded);\n        } else if (opCode == 0x5b) {\n            // JUMPDEST\n            verifyOpJUMPDEST(offset, stateProof, encoded);\n        } else if (opCode >= 0x60 && opCode <= 0x7f) {\n            // PUSH\n            verifyPushOpCode(offset, stateProof, codeProof, encoded);\n        } else if (opCode >= 0x80 && opCode <= 0x8f) {\n            // DUP\n            verifyDupOpCode(offset, stateProof, encoded);\n        } else if (opCode >= 0x90 && opCode <= 0x9f) {\n            // SWAP\n            verifySwapOpCode(offset, stateProof, encoded);\n        } else {\n            revert(\"Unreachable\");\n        }\n\n        // Obtain the opcode at new pc\n        if (stateProof.depth > 0) {\n            if (codeProof.size > uint256(stateProof.pc)) {\n                stateProof.opCode = codeProof.getOpCodeAt(encoded, stateProof.pc);\n            } else {\n                stateProof.opCode = 0x00;\n            }\n        }\n        // Return the state hash after one-step execution\n        return stateProof;\n    }\n\n    function verifyStackOnlyOpcode(\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.StackProof memory stackProof,\n        uint256 push\n    ) internal pure {\n        // Simulate pushing the `push` element to the stack\n        bytes32 h = keccak256(abi.encodePacked(stackProof.stackHashAfterPops, push));\n        stateProof.stackHash = h;\n        stateProof.stackSize += 1;\n        // Increment pc\n        stateProof.pc += 1;\n    }\n\n    function verifyUnaryOpCode(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize < 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        // Decode StackProof\n        OneStepProof.StackProof memory stackProof;\n        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n\n        uint8 opCode = stateProof.opCode;\n        uint64 gasCost;\n        // Get the operand from stackProof\n        uint256 a = stackProof.pops[0];\n        // Simulate the opcode execution, get result and gas cost\n        uint256 expected;\n        if (opCode == 0x15) {\n            assembly {\n                expected := iszero(a)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x19) {\n            assembly {\n                expected := not(a)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else {\n            revert(\"Unreachable\");\n        }\n        // Consume gas cost\n        if (stateProof.gas < gasCost) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= gasCost;\n        // Simulate stack pop\n        stateProof.stackSize -= 1;\n        // Verify the stack proof and reconstruct the state after one-step execution\n        verifyStackOnlyOpcode(stateProof, stackProof, expected);\n    }\n\n    function verifyBinaryOpCode(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize < 2) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        // Decode StackProof\n        OneStepProof.StackProof memory stackProof;\n        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 2, offset, encoded);\n\n        uint8 opCode = stateProof.opCode;\n        uint64 gasCost;\n        // Get operands from stackProof\n        uint256 a = stackProof.pops[0];\n        uint256 b = stackProof.pops[1];\n        // Simulate the opcode execution, get result and gas cost\n        uint256 expected;\n        if (opCode == 0x01) {\n            assembly {\n                expected := add(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x02) {\n            assembly {\n                expected := mul(a, b)\n            }\n            gasCost = Params.G_LOW;\n        } else if (opCode == 0x03) {\n            assembly {\n                expected := sub(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x04) {\n            assembly {\n                expected := div(a, b)\n            }\n            gasCost = Params.G_LOW;\n        } else if (opCode == 0x05) {\n            assembly {\n                expected := sdiv(a, b)\n            }\n            gasCost = Params.G_LOW;\n        } else if (opCode == 0x06) {\n            assembly {\n                expected := mod(a, b)\n            }\n            gasCost = Params.G_LOW;\n        } else if (opCode == 0x07) {\n            assembly {\n                expected := smod(a, b)\n            }\n            gasCost = Params.G_LOW;\n        } else if (opCode == 0x0a) {\n            assembly {\n                expected := exp(a, b)\n            }\n            gasCost = GasTable.gasExp(b);\n        } else if (opCode == 0x0b) {\n            assembly {\n                expected := signextend(a, b)\n            }\n            gasCost = Params.G_LOW;\n        } else if (opCode == 0x10) {\n            assembly {\n                expected := lt(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x11) {\n            assembly {\n                expected := gt(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x12) {\n            assembly {\n                expected := slt(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x13) {\n            assembly {\n                expected := sgt(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x14) {\n            assembly {\n                expected := eq(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x16) {\n            assembly {\n                expected := and(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x17) {\n            assembly {\n                expected := or(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x18) {\n            assembly {\n                expected := xor(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x1a) {\n            assembly {\n                expected := byte(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x1b) {\n            assembly {\n                expected := shl(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x1c) {\n            assembly {\n                expected := shr(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else if (opCode == 0x1d) {\n            assembly {\n                expected := sar(a, b)\n            }\n            gasCost = Params.G_VERYLOW;\n        } else {\n            revert(\"Unreachable\");\n        }\n        // Consume gas cost\n        if (stateProof.gas < gasCost) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= gasCost;\n        // Simulate stack pop\n        stateProof.stackSize -= 2;\n        // Verify the stack proof and reconstruct the state after one-step execution\n        verifyStackOnlyOpcode(stateProof, stackProof, expected);\n    }\n\n    function verifyTrinaryOpCode(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize < 3) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        // Decode StackProof\n        OneStepProof.StackProof memory stackProof;\n        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 3, offset, encoded);\n\n        uint8 opCode = stateProof.opCode;\n        uint64 gasCost;\n        // Get operands from stackProof\n        uint256 a = stackProof.pops[0];\n        uint256 b = stackProof.pops[1];\n        uint256 c = stackProof.pops[2];\n        // Simulate the opcode execution, get result and gas cost\n        uint256 expected;\n        if (opCode == 0x08) {\n            assembly {\n                expected := addmod(a, b, c)\n            }\n            gasCost = Params.G_MID;\n        } else if (opCode == 0x09) {\n            assembly {\n                expected := mulmod(a, b, c)\n            }\n            gasCost = Params.G_MID;\n        } else {\n            revert(\"Unreachable\");\n        }\n        // Consume gas cost\n        if (stateProof.gas < gasCost) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= gasCost;\n        // Simulate stack pop\n        stateProof.stackSize -= 3;\n        // Verify the stack proof and reconstruct the state after one-step execution\n        verifyStackOnlyOpcode(stateProof, stackProof, expected);\n    }\n\n    function verifyPushOpCode(\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.CodeProof memory codeProof,\n        bytes calldata encoded\n    ) internal pure {\n        if (stateProof.stackSize >= Params.STACK_LIMIT - 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        uint8 opCode = stateProof.opCode;\n        // Get the number of bytes to push\n        uint8 pushBytes = opCode - 0x5f;\n\n        // Slice out the push bytes from the bytecode\n        uint256 expected = 0;\n        // TODO: optimize this with assembly\n        for (uint64 i = 1; i <= pushBytes; i++) {\n            expected *= 256;\n            uint64 pushOffset = stateProof.pc + i;\n            if (pushOffset + 1 <= codeProof.size) {\n                expected += codeProof.getOpCodeAt(encoded, pushOffset);\n            }\n        }\n        // Simulate pushing the content to the stack\n        bytes32 h = keccak256(abi.encodePacked(stateProof.stackHash, expected));\n        stateProof.stackHash = h;\n        stateProof.stackSize += 1;\n\n        // Consume the gas\n        if (stateProof.gas < Params.G_VERYLOW) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_VERYLOW;\n        // Skip the opcode and content, jump to the correct pc\n        stateProof.pc += 1 + pushBytes;\n    }\n\n    function verifyDupOpCode(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        uint8 opCode = stateProof.opCode;\n        // Get the stack duplication position\n        uint8 dupPos = opCode - 0x80 + 1;\n        if (stateProof.stackSize >= Params.STACK_LIMIT - 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        if (stateProof.stackSize < dupPos) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n\n        // Decode the stack proof\n        OneStepProof.StackProof memory stackProof;\n        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, dupPos, offset, encoded);\n\n        // Simulate duplicating the stack content\n        // pops[0] is the element to be duplicated\n        bytes32 h = keccak256(abi.encodePacked(stateProof.stackHash, stackProof.pops[0]));\n        stateProof.stackHash = h;\n        stateProof.stackSize += 1;\n\n        // Consume the gas\n        if (stateProof.gas < Params.G_VERYLOW) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_VERYLOW;\n        // Increment the pc\n        stateProof.pc += 1;\n    }\n\n    function verifySwapOpCode(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        uint8 opCode = stateProof.opCode;\n        // Get the stack swap position\n        uint8 swapPos = opCode - 0x90 + 2;\n        if (stateProof.stackSize >= Params.STACK_LIMIT - 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        if (stateProof.stackSize < swapPos) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n\n        // Decode the stack proof\n        OneStepProof.StackProof memory stackProof;\n        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, swapPos, offset, encoded);\n\n        // Simulate pushing the first swapped element\n        bytes32 h = keccak256(abi.encodePacked(stackProof.stackHashAfterPops, stackProof.pops[swapPos - 1]));\n        // Simulate pushing the intermediate unchanged elements\n        for (uint8 i = swapPos - 1; i > 1; i--) {\n            h = keccak256(abi.encodePacked(h, stackProof.pops[i - 1]));\n        }\n        // Simulate pushing the last swapped element\n        h = keccak256(abi.encodePacked(h, stackProof.pops[0]));\n        stateProof.stackHash = h;\n\n        // Consume the gas\n        if (stateProof.gas < Params.G_VERYLOW) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_VERYLOW;\n        // Increment the pc\n        stateProof.pc += 1;\n    }\n\n    function verifyOpPOP(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize < 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n\n        // Decode the stack proof\n        OneStepProof.StackProof memory stackProof;\n        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n\n        // `stackHashAfterPops` is the exact stack hash in the next step state\n        stateProof.stackHash = stackProof.stackHashAfterPops;\n        stateProof.stackSize -= 1;\n\n        // Consume the gas\n        if (stateProof.gas < Params.G_BASE) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_BASE;\n        // Increment the pc\n        stateProof.pc += 1;\n    }\n\n    function verifyOpJUMP(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize < 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        // Decode the stack proof\n        OneStepProof.StackProof memory stackProof;\n        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n\n        // `stackHashAfterPops` is the exact stack hash in the next step state\n        stateProof.stackHash = stackProof.stackHashAfterPops;\n        stateProof.stackSize -= 1;\n\n        // Consume the gas\n        if (stateProof.gas < Params.G_MID) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_MID;\n        // Jump the pc according to the popped element from the stack\n        uint64 nextPc = uint64(stackProof.pops[0]);\n        stateProof.pc = nextPc;\n    }\n\n    function verifyOpJUMPI(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize < 2) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n\n        // Decode the stack proof\n        OneStepProof.StackProof memory stackProof;\n        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 2, offset, encoded);\n\n        // `stackHashAfterPops` is the exact stack hash in the next step state\n        stateProof.stackHash = stackProof.stackHashAfterPops;\n        stateProof.stackSize -= 2;\n\n        // Calculate the correct next pc\n        uint64 nextPc = stateProof.pc + 1;\n        if (stackProof.pops[0] != 0) {\n            nextPc = uint64(stackProof.pops[1]);\n        }\n\n        // Consume the gas\n        if (stateProof.gas < Params.G_HIGH) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_HIGH;\n        // Jump the pc\n        stateProof.pc = nextPc;\n    }\n\n    function verifyOpPC(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize >= Params.STACK_LIMIT - 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n\n        // Consume the gas\n        if (stateProof.gas < Params.G_BASE) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_BASE;\n        // Simulate pushing `pc` to the stack\n        stateProof.stackHash = keccak256(abi.encodePacked(stateProof.stackHash, uint256(stateProof.pc)));\n        stateProof.stackSize += 1;\n        // Increment the pc\n        stateProof.pc += 1;\n    }\n\n    function verifyOpMSIZE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize >= Params.STACK_LIMIT - 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n\n        // Consume the gas\n        if (stateProof.gas < Params.G_BASE) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_BASE;\n        // Simulate pushing `msize` to the stack\n        stateProof.stackHash = keccak256(abi.encodePacked(stateProof.stackHash, uint256(stateProof.memSize)));\n        stateProof.stackSize += 1;\n        // Increment the pc\n        stateProof.pc += 1;\n    }\n\n    function verifyOpGAS(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize >= Params.STACK_LIMIT - 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n\n        // Consume the gas\n        if (stateProof.gas < Params.G_BASE) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_BASE;\n        // Simulate pushing `gas` to the stack\n        stateProof.stackHash = keccak256(abi.encodePacked(stateProof.stackHash, uint256(stateProof.gas)));\n        stateProof.stackSize += 1;\n        // Increment the pc\n        stateProof.pc += 1;\n    }\n\n    function verifyOpJUMPDEST(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        // Consume the gas\n        if (stateProof.gas < Params.G_JUMPDEST) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= Params.G_JUMPDEST;\n        // Increment the pc\n        stateProof.pc += 1;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/subverifiers/InvalidOpVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BytesLib.sol\";\nimport \"../IVerifier.sol\";\nimport \"../libraries/VerificationContext.sol\";\nimport \"../libraries/OneStepProof.sol\";\nimport \"../libraries/Params.sol\";\nimport \"../libraries/GasTable.sol\";\nimport \"../libraries/VerifierHelper.sol\";\n\ncontract InvalidOpVerifier is IVerifier {\n    using BytesLib for bytes;\n    using VerificationContext for VerificationContext.Context;\n    using OneStepProof for OneStepProof.CodeProof;\n\n    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        return OneStepProof.hashStateProof(executeOneStepProof(ctx, currStateHash, encoded));\n    }\n\n    function executeOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        public\n        pure\n        returns (OneStepProof.StateProof memory endState)\n    {\n        uint64 offset = 0;\n        // Decode state proof\n        OneStepProof.StateProof memory stateProof;\n        (offset, stateProof) = OneStepProof.decodeStateProof(ctx, encoded, offset);\n        // Calculate the state hash from the submitted proof\n        bytes32 stateHashFromProof;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, encoded.offset, offset)\n            stateHashFromProof := keccak256(ptr, offset)\n        }\n        // Ensure the state proof is valid\n        require(stateHashFromProof == currStateHash, \"Bad State Proof\");\n\n        // Decode the code proof\n        OneStepProof.CodeProof memory codeProof;\n        (offset, codeProof) = OneStepProof.decodeCodeProof(encoded, offset);\n\n        // Simulate EVM one-step execution based on the opcode\n        uint8 opCode = stateProof.opCode;\n        if (!isInvalidOp(opCode)) {\n            revert(\"Unreachable\");\n        }\n\n        VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n\n        // Obtain the opcode at new pc\n        if (stateProof.depth > 0) {\n            if (codeProof.size > uint256(stateProof.pc)) {\n                stateProof.opCode = codeProof.getOpCodeAt(encoded, stateProof.pc);\n            } else {\n                stateProof.opCode = 0x00;\n            }\n        }\n        // Return the state hash after one-step execution\n        return stateProof;\n    }\n\n    function isInvalidOp(uint8 opCode) internal pure returns (bool) {\n        if (opCode == 0xfe) {\n            // INVALID\n            return true;\n        }\n        if (opCode >= 0x0c && opCode <= 0x0f) {\n            return true;\n        }\n        if (opCode >= 0x1e && opCode <= 0x1f) {\n            return true;\n        }\n        if (opCode >= 0x21 && opCode <= 0x2f) {\n            return true;\n        }\n        if (opCode >= 0x47 && opCode <= 0x4f) {\n            return true; // BASEFEE not supported in Istanbul protocol\n        }\n        if (opCode >= 0x5c && opCode <= 0x5f) {\n            return true;\n        }\n        if (opCode >= 0xa5 && opCode <= 0xef) {\n            return true;\n        }\n        if (opCode >= 0xf6 && opCode <= 0xf9 || opCode == 0xfb || opCode == 0xfc) {\n            return true;\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/subverifiers/EnvironmentalOpVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BytesLib.sol\";\nimport \"../IVerifier.sol\";\nimport \"../libraries/VerificationContext.sol\";\nimport \"../libraries/VerifierHelper.sol\";\nimport \"../libraries/OneStepProof.sol\";\nimport \"../libraries/Params.sol\";\nimport \"../libraries/GasTable.sol\";\n\ncontract EnvironmentalOpVerifier is IVerifier {\n    using BytesLib for bytes;\n    using VerificationContext for VerificationContext.Context;\n    using OneStepProof for OneStepProof.CodeProof;\n\n    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        return OneStepProof.hashStateProof(executeOneStepProof(ctx, currStateHash, encoded));\n    }\n\n    function executeOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        public\n        pure\n        returns (OneStepProof.StateProof memory)\n    {\n        uint64 offset = 0;\n        // Decode state proof\n        OneStepProof.StateProof memory stateProof;\n        (offset, stateProof) = OneStepProof.decodeStateProof(ctx, encoded, offset);\n        // Calculate the state hash from the submitted proof\n        bytes32 stateHashFromProof;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, encoded.offset, offset)\n            stateHashFromProof := keccak256(ptr, offset)\n        }\n        // Ensure the state proof is valid\n        require(stateHashFromProof == currStateHash, \"Bad State Proof\");\n\n        // Decode the code proof\n        OneStepProof.CodeProof memory codeProof;\n        (offset, codeProof) = OneStepProof.decodeCodeProof(encoded, offset);\n\n        // Simulate EVM one-step execution based on the opcode\n        uint8 opCode = stateProof.opCode;\n        if (opCode == 0x30) {\n            // ADDRESS\n            verifyOpADDRESS(offset, stateProof, encoded);\n        } else if (opCode == 0x32) {\n            // ORIGIN\n            verifyOpORIGIN(ctx, offset, stateProof, encoded);\n        } else if (opCode == 0x33) {\n            // CALLER\n            verifyOpCALLER(offset, stateProof, encoded);\n        } else if (opCode == 0x34) {\n            // CALLVALUE\n            verifyOpCALLVALUE(offset, stateProof, encoded);\n        } else if (opCode == 0x38) {\n            // CODESIZE\n            verifyOpCODESIZE(offset, stateProof, codeProof, encoded);\n        } else if (opCode == 0x36) {\n            // CALLDATASIZE\n            verifyOpCALLDATASIZE(offset, stateProof, encoded);\n        } else if (opCode == 0x3a) {\n            // GASPRICE\n            verifyOpGASPRICE(ctx, offset, stateProof, encoded);\n        } else if (opCode == 0x3d) {\n            // RETURNDATASIZE\n            verifyOpRETURNDATASIZE(offset, stateProof, encoded);\n        } else if (opCode == 0x40) {\n            // BLOCKHASH\n            verifyOpBLOCKHASH(offset, stateProof, encoded);\n        } else if (opCode == 0x41) {\n            // COINBASE\n            verifyOpCOINBASE(ctx, offset, stateProof, encoded);\n        } else if (opCode == 0x42) {\n            // TIMESTAMP\n            verifyOpTIMESTAMP(ctx, offset, stateProof, encoded);\n        } else if (opCode == 0x43) {\n            // NUMBER\n            verifyOpNUMBER(ctx, offset, stateProof, encoded);\n        } else if (opCode == 0x44) {\n            // DIFFICULTY\n            verifyOpDIFFICULTY(ctx, offset, stateProof, encoded);\n        } else if (opCode == 0x45) {\n            // GASLIMIT\n            verifyOpGASLIMIT(ctx, offset, stateProof, encoded);\n        } else if (opCode == 0x46) {\n            // CHAINID\n            verifyOpCHAINID(ctx, offset, stateProof, encoded);\n        } else {\n            revert(\"Unreachable\");\n        }\n\n        // Obtain the opcode at new pc\n        if (stateProof.depth > 0) {\n            if (codeProof.size > uint256(stateProof.pc)) {\n                stateProof.opCode = codeProof.getOpCodeAt(encoded, stateProof.pc);\n            } else {\n                stateProof.opCode = 0x00;\n            }\n        }\n        // Return the state hash after one-step execution\n        return stateProof;\n    }\n\n    function verifyOnePushOpcode(\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        uint64 gas,\n        uint256 push,\n        bytes calldata encoded\n    ) internal pure {\n        if (stateProof.stackSize >= Params.STACK_LIMIT - 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        // Consume the gas\n        if (stateProof.gas < gas) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= gas;\n\n        // Simulate pushing `push` to the stack\n        stateProof.stackHash = keccak256(abi.encodePacked(stateProof.stackHash, push));\n        stateProof.stackSize += 1;\n        // Increment the pc\n        stateProof.pc += 1;\n    }\n\n    function verifyOpADDRESS(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(uint160(stateProof.contractAddress)), encoded);\n    }\n\n    function verifyOpORIGIN(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(uint160(ctx.getOrigin())), encoded);\n    }\n\n    function verifyOpCALLER(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(uint160(stateProof.caller)), encoded);\n    }\n\n    function verifyOpCALLVALUE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(uint160(stateProof.value)), encoded);\n    }\n\n    function verifyOpCODESIZE(\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        OneStepProof.CodeProof memory codeProof,\n        bytes calldata encoded\n    ) internal pure {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(codeProof.size), encoded);\n    }\n\n    function verifyOpCALLDATASIZE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(stateProof.inputDataSize), encoded);\n    }\n\n    function verifyOpGASPRICE(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, ctx.getGasPrice(), encoded);\n    }\n\n    function verifyOpRETURNDATASIZE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(stateProof.returnDataSize), encoded);\n    }\n\n    function verifyOpBLOCKHASH(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {\n        if (stateProof.stackSize < 1) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        OneStepProof.StackProof memory stackProof;\n        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n\n        // Consume the gas\n        uint64 gas = Params.G_BLOCKHASH;\n        if (stateProof.gas < gas) {\n            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n            return;\n        }\n        stateProof.gas -= gas;\n\n        uint64 num = uint64(stackProof.pops[0]);\n        bytes32 bhash;\n        if (stateProof.blockNumber >= num || stateProof.blockNumber < num - Params.RECENT_BLOCK_HASHES_LENGTH) {\n            bhash = 0x00;\n        } else {\n            (offset, bhash) =\n                VerifierHelper.decodeAndVerifyBlockHashProof(offset, encoded, num, stateProof.blockHashRoot);\n        }\n\n        // Simulate pushing `bhash` to the stack\n        stateProof.stackHash = keccak256(abi.encodePacked(stackProof.stackHashAfterPops, bhash));\n        // Increment the pc\n        stateProof.pc += 1;\n    }\n\n    function verifyOpCOINBASE(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(uint160(ctx.getCoinbase())), encoded);\n    }\n\n    function verifyOpTIMESTAMP(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, ctx.getTimestamp(), encoded);\n    }\n\n    function verifyOpNUMBER(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, ctx.getBlockNumber(), encoded);\n    }\n\n    function verifyOpDIFFICULTY(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, ctx.getDifficulty(), encoded);\n    }\n\n    function verifyOpGASLIMIT(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(ctx.getGasLimit()), encoded);\n    }\n\n    function verifyOpCHAINID(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {\n        verifyOnePushOpcode(offset, stateProof, Params.G_BASE, uint256(ctx.getChainID()), encoded);\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/subverifiers/CallOpVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BytesLib.sol\";\nimport \"../../libraries/MPT.sol\";\nimport \"../IVerifier.sol\";\nimport \"../libraries/VerificationContext.sol\";\nimport \"../libraries/OneStepProof.sol\";\nimport \"../libraries/Params.sol\";\nimport \"../libraries/GasTable.sol\";\nimport \"../libraries/VerifierHelper.sol\";\nimport \"../libraries/EVMTypesLib.sol\";\n\ncontract CallOpVerifier is IVerifier {\n    using BytesLib for bytes;\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for RLPReader.Iterator;\n    using VerificationContext for VerificationContext.Context;\n    using OneStepProof for OneStepProof.CodeProof;\n\n    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        return OneStepProof.hashStateProof(executeOneStepProof(ctx, currStateHash, encoded));\n    }\n\n    function executeOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        public\n        pure\n        returns (OneStepProof.StateProof memory endState)\n    {\n        uint64 offset = 0;\n        // Decode state proof\n        OneStepProof.StateProof memory stateProof;\n        (offset, stateProof) = OneStepProof.decodeStateProof(ctx, encoded, offset);\n        // Calculate the state hash from the submitted proof\n        bytes32 stateHashFromProof;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, encoded.offset, offset)\n            stateHashFromProof := keccak256(ptr, offset)\n        }\n        // Ensure the state proof is valid\n        require(stateHashFromProof == currStateHash, \"Bad State Proof\");\n\n        // Simulate EVM one-step execution based on the opcode\n        uint8 opCode = stateProof.opCode;\n        if (opCode == 0xf0) {\n            // CREATE\n            verifyOpCREATE(offset, stateProof, encoded);\n        } else if (opCode == 0xf1) {\n            // CALL\n            verifyOpCALL(offset, stateProof, encoded);\n        } else if (opCode == 0xf3) {\n            // RETURN\n            verifyOpRETURN(ctx, offset, stateProof, encoded);\n        } else if (opCode == 0xf2) {\n            // CALLCODE\n            verifyOpCALLCODE(offset, stateProof, encoded);\n        } else if (opCode == 0xf4) {\n            // DELEGATECALL\n            verifyOpDELEGATECALL(offset, stateProof, encoded);\n        } else if (opCode == 0xf5) {\n            // CREATE2\n            verifyOpCREATE2(offset, stateProof, encoded);\n        } else if (opCode == 0xfa) {\n            // STATICCALL\n            verifyOpSTATICCALL(offset, stateProof, encoded);\n        } else if (opCode == 0xfd) {\n            // REVERT\n            verifyOpREVERT(ctx, offset, stateProof, encoded);\n        } else if (opCode == 0xff) {\n            // SELFDESTRUCT\n            verifyOpSELFDESTRUCT(ctx, offset, stateProof, encoded);\n        } else {\n            revert(\"Unreachable\");\n        }\n\n        // Return the state hash after one-step execution\n        return stateProof;\n    }\n\n    function verifyOpCREATE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {}\n\n    function verifyOpCALL(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {}\n\n    function verifyOpRETURN(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {}\n\n    function verifyOpCALLCODE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {}\n\n    function verifyOpDELEGATECALL(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {}\n\n    function verifyOpCREATE2(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {}\n\n    function verifyOpSTATICCALL(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n        internal\n        pure\n    {}\n\n    function verifyOpREVERT(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {}\n\n    function verifyOpSELFDESTRUCT(\n        VerificationContext.Context memory ctx,\n        uint64 offset,\n        OneStepProof.StateProof memory stateProof,\n        bytes calldata encoded\n    ) internal pure {}\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/subverifiers/BlockInitiationVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BytesLib.sol\";\nimport \"../../libraries/MPT.sol\";\nimport \"../IVerifier.sol\";\nimport \"../libraries/VerificationContext.sol\";\nimport \"../libraries/OneStepProof.sol\";\nimport \"../libraries/Params.sol\";\nimport \"../libraries/GasTable.sol\";\nimport \"../libraries/VerifierHelper.sol\";\nimport \"../libraries/EVMTypesLib.sol\";\nimport \"../libraries/BloomLib.sol\";\n\ncontract BlockInitiationVerifier is IVerifier {\n    function verifyOneStepProof(VerificationContext.Context memory, bytes32 currStateHash, bytes calldata encoded)\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        return OneStepProof.hashInterStateProof(executeOneStepProof(currStateHash, encoded));\n    }\n\n    function executeOneStepProof(bytes32 currStateHash, bytes calldata encoded)\n        public\n        pure\n        returns (OneStepProof.InterStateProof memory endState)\n    {\n        uint64 offset = 0;\n        // Decode block state proof\n        OneStepProof.BlockStateProof memory blockStateProof;\n        (offset, blockStateProof) = OneStepProof.decodeBlockStateProof(encoded, offset);\n\n        // Calculate the state hash from the submitted proof\n        bytes32 stateHashFromProof;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, encoded.offset, offset)\n            stateHashFromProof := keccak256(ptr, offset)\n        }\n        // Ensure the block state proof is valid\n        require(stateHashFromProof == currStateHash, \"Bad State Proof\");\n\n        // Create the first inter-state in the block using block state proof\n        endState.blockNumber = blockStateProof.blockNumber + 1;\n        endState.transactionIdx = 0;\n        endState.globalStateRoot = blockStateProof.globalStateRoot;\n        endState.cumulativeGasUsed = blockStateProof.cumulativeGasUsed;\n        endState.blockHashRoot = blockStateProof.blockHashRoot;\n        endState.transactionTrieRoot = Params.EMPTY_TRIE_ROOT;\n        endState.receiptTrieRoot = Params.EMPTY_TRIE_ROOT;\n        endState.logsBloom = BloomLib.emptyBloom();\n        return endState;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/subverifiers/BlockFinalizationVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/BytesLib.sol\";\nimport \"../../libraries/MPT.sol\";\nimport \"../IVerifier.sol\";\nimport \"../libraries/VerificationContext.sol\";\nimport \"../libraries/OneStepProof.sol\";\nimport \"../libraries/Params.sol\";\nimport \"../libraries/GasTable.sol\";\nimport \"../libraries/VerifierHelper.sol\";\nimport \"../libraries/EVMTypesLib.sol\";\nimport \"../libraries/BloomLib.sol\";\n\ncontract BlockFinalizationVerifier is IVerifier {\n    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        external\n        pure\n        override\n        returns (bytes32)\n    {\n        return OneStepProof.hashBlockStateProof(executeOneStepProof(ctx, currStateHash, encoded));\n    }\n\n    function executeOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n        public\n        pure\n        returns (OneStepProof.BlockStateProof memory endState)\n    {\n        uint64 offset = 0;\n        // Decode inter-state proof\n        OneStepProof.InterStateProof memory stateProof;\n        (offset, stateProof) = OneStepProof.decodeInterStateProof(encoded, offset);\n\n        // Calculate the state hash from the submitted proof\n        bytes32 stateHashFromProof;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, encoded.offset, encoded.length)\n            stateHashFromProof := keccak256(ptr, offset)\n        }\n        // Ensure the state proof is valid\n        require(stateHashFromProof == currStateHash, \"Bad State Proof\");\n\n        // Obtain the parent block hash from the block hash tree\n        bytes32 parentBlockHash;\n        (offset, parentBlockHash) = VerifierHelper.decodeAndVerifyBlockHashProof(\n            offset, encoded, stateProof.blockNumber - 1, stateProof.blockHashRoot\n        );\n        // Update the current block hash to the block hash tree\n        bytes32 currentBlockHash = VerifierHelper.hashBlockHeader(ctx, parentBlockHash, stateProof);\n\n        // Create the finalized block state using last inter-state proof\n        (offset, endState.blockHashRoot) = VerifierHelper.decodeAndInsertBlockHashProof(\n            offset, encoded, stateProof.blockNumber, stateProof.blockHashRoot, currentBlockHash\n        );\n        endState.blockNumber = stateProof.blockNumber;\n        endState.globalStateRoot = stateProof.globalStateRoot;\n        endState.cumulativeGasUsed = stateProof.cumulativeGasUsed;\n        return endState;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/Rollup.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Modifications Copyright 2022, Specular contributors\n *\n * This file was changed in accordance to Apache License, Version 2.0.\n *\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./challenge/Challenge.sol\";\nimport \"./challenge/ChallengeLib.sol\";\nimport \"./AssertionMap.sol\";\nimport \"./IRollup.sol\";\nimport \"./RollupLib.sol\";\nimport \"./WhiteList.sol\";\nimport \"./verifier/IVerifier.sol\";\nimport {Lib_AddressResolver} from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport {Lib_AddressManager} from \"../../libraries/resolver/Lib_AddressManager.sol\";\nimport {Lib_BVMCodec} from \"../../libraries/codec/Lib_BVMCodec.sol\";\n\n\nabstract contract RollupBase is IRollup, Initializable {\n    // Config parameters\n    uint256 public minimumAssertionPeriod; // number of L1 blocks\n    uint256 public baseStakeAmount; // number of stake tokens\n\n    IERC20 public stakeToken;\n    AssertionMap public override assertions;\n    IVerifierEntry public verifier;\n\n    // slot place hold\n    uint256[50] rollupBaseGap;\n\n    struct Staker {\n        bool isStaked;\n        uint256 amountStaked;\n        uint256 assertionID; // latest staked assertion ID\n        address operator; // operator\n        address currentChallenge; // address(0) if none\n    }\n\n    struct Zombie {\n        address stakerAddress;\n        uint256 lastAssertionID;\n    }\n\n    struct ChallengeCtx {\n        bool completed;\n        address challengeAddress;\n        address defenderAddress;\n        address challengerAddress;\n        uint256 defenderAssertionID;\n        uint256 challengerAssertionID;\n    }\n}\n\ncontract Rollup is Lib_AddressResolver, RollupBase, Whitelist {\n    modifier stakedOnly() {\n        if (!isStaked(msg.sender)) {\n            revert(\"NotStaked\");\n        }\n        _;\n    }\n\n    modifier operatorOnly() {\n        if (registers[msg.sender] == address(0)) {\n            revert(\"NotOperator\");\n        }\n        _;\n    }\n\n    // Assertion state\n    uint256 public lastResolvedAssertionID;\n    uint256 public lastConfirmedAssertionID;\n    uint256 public lastCreatedAssertionID;\n\n    // Staking state\n    uint256 public numStakers; // current total number of stakers\n    mapping(address => Staker) public stakers; // mapping from staker addresses to corresponding stakers\n    mapping(address => address) public registers; // register info for operator => staker\n    mapping(address => uint256) public withdrawableFunds; // mapping from addresses to withdrawable funds (won in challenge)\n    Zombie[] public zombies; // stores stakers that lost a challenge\n    ChallengeCtx public challengeCtx;  // stores challenge context\n    constructor() Lib_AddressResolver(address(0)) {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _verifier,\n        address _stakeToken,\n        address _libAddressManager,\n        address _assertionMap,\n        uint256 _minimumAssertionPeriod,\n        uint256 _baseStakeAmount,\n        bytes32 _initialVMhash,\n        address[] calldata stakerWhitelists,\n        address[] calldata operatorWhitelists\n    ) public initializer {\n        if (_owner == address(0) || _verifier == address(0)) {\n            revert(\"ZeroAddress\");\n        }\n        owner = _owner;\n        stakeToken = IERC20(_stakeToken);\n        verifier = IVerifierEntry(_verifier);\n\n        if (address(libAddressManager) != address(0)) {\n            revert(\"RedundantInitialized\");\n        }\n        libAddressManager = Lib_AddressManager(_libAddressManager);\n\n        if (address(assertions) != address(0)) {\n            revert(\"RedundantInitialized\");\n        }\n        assertions = AssertionMap(_assertionMap);\n\n        minimumAssertionPeriod = _minimumAssertionPeriod;\n        baseStakeAmount = _baseStakeAmount;\n\n        assertions.setRollupAddress(address(this));\n        lastResolvedAssertionID = 0;\n        lastConfirmedAssertionID = 0;\n        lastCreatedAssertionID = 0;\n\n        assertions.createAssertion(\n            lastResolvedAssertionID, // assertionID\n            _initialVMhash,\n            0, // inboxSize (genesis)\n            0, // parentID\n            block.number // deadline (unchallengeable)\n        );\n\n        addToStakerWhitelist(stakerWhitelists);\n        addToOperatorWhitelist(operatorWhitelists);\n    }\n\n    /// @inheritdoc IRollup\n    function isStaked(address addr) public view override returns (bool) {\n        return stakers[addr].isStaked;\n    }\n\n    /// @inheritdoc IRollup\n    function currentRequiredStake() public view override returns (uint256) {\n        return baseStakeAmount;\n    }\n\n    /// @inheritdoc IRollup\n    function confirmedInboxSize() public view override returns (uint256) {\n        return assertions.getInboxSize(lastConfirmedAssertionID);\n    }\n\n    /// @inheritdoc IRollup\n    function stake(uint256 stakeAmount, address operator) external override\n        stakerWhitelistOnly(msg.sender)\n        operatorWhitelistOnly(operator)\n    {\n        // send erc20 token to staking contract, need user approve first\n        require(\n            IERC20(stakeToken).transferFrom(msg.sender, address(this), stakeAmount),\n            \"transfer erc20 token failed\"\n        );\n\n        if (isStaked(msg.sender)) {\n            require(\n            stakers[msg.sender].operator == operator,\n                \"staker => operator mapping not unique\"\n            );\n            stakers[msg.sender].amountStaked += stakeAmount;\n        } else {\n            require(registers[operator] == address(0), \"operator is occupied\");\n\n            if (stakeAmount < baseStakeAmount) {\n                revert(\"InsufficientStake\");\n            }\n\n            stakers[msg.sender] = Staker(true, stakeAmount, 0, operator, address(0));\n            registers[operator] = msg.sender;\n            numStakers++;\n            stakeOnAssertion(msg.sender, lastConfirmedAssertionID);\n        }\n    }\n\n    /// @inheritdoc IRollup\n    function unstake(uint256 stakeAmount) external override {\n        requireStaked(msg.sender);\n        // Require that staker is staked on a confirmed assertion.\n        Staker storage staker = stakers[msg.sender];\n        if (staker.assertionID > lastConfirmedAssertionID) {\n            revert(\"StakedOnUnconfirmedAssertion\");\n        }\n        if (stakeAmount > staker.amountStaked - currentRequiredStake()) {\n            revert(\"InsufficientStake\");\n        }\n        staker.amountStaked -= stakeAmount;\n        // send erc20 token to user\n        require(\n            IERC20(stakeToken).transfer(msg.sender, stakeAmount),\n            \"transfer erc20 token failed\"\n        );\n    }\n\n    /// @inheritdoc IRollup\n    function removeStake(address stakerAddress) onlyOwner external override {\n        requireStaked(stakerAddress);\n        // Require that staker is staked on a confirmed assertion.\n        Staker storage staker = stakers[stakerAddress];\n        if (staker.assertionID > lastConfirmedAssertionID) {\n            revert(\"StakedOnUnconfirmedAssertion\");\n        }\n        uint256 amountToSent = staker.amountStaked;\n        deleteStaker(stakerAddress);\n        // send erc20 token to user\n        require(\n            IERC20(stakeToken).transfer(stakerAddress, amountToSent),\n            \"transfer erc20 token failed\"\n        );\n    }\n\n    /// @inheritdoc IRollup\n    function advanceStake(uint256 assertionID) external override operatorOnly {\n        address stakerAddr = registers[msg.sender];\n        Staker storage staker = stakers[stakerAddr];\n        if (assertionID <= staker.assertionID || assertionID > lastCreatedAssertionID) {\n            revert(\"AssertionOutOfRange\");\n        }\n        // TODO: allow arbitrary descendant of current staked assertionID, not just child.\n        if (staker.assertionID != assertions.getParentID(assertionID)) {\n            revert(\"ParentAssertionUnstaked\");\n        }\n        stakeOnAssertion(stakerAddr, assertionID);\n    }\n\n    /// @inheritdoc IRollup\n    function withdraw() external override operatorOnly {\n        uint256 withdrawableFund = withdrawableFunds[msg.sender];\n        withdrawableFunds[msg.sender] = 0;\n        require(\n            IERC20(stakeToken).transfer(msg.sender, withdrawableFund),\n            \"transfer erc20 token failed\"\n        );\n    }\n\n    /// @inheritdoc IRollup\n    function createAssertion(\n        bytes32 vmHash,\n        uint256 inboxSize\n    ) public override operatorOnly {\n        address stakerAddr = registers[msg.sender];\n        require(stakers[stakerAddr].currentChallenge == address(0),\"can not create assertion when staker in challenge\");\n        uint256 parentID = stakers[stakerAddr].assertionID;\n        // Require that enough time has passed since the last assertion.\n        if (block.number - assertions.getProposalTime(parentID) < minimumAssertionPeriod) {\n            revert(\"MinimumAssertionPeriodNotPassed\");\n        }\n        // Require that the assertion at least includes one transaction\n        if (inboxSize <= assertions.getInboxSize(parentID)) {\n            revert(\"EmptyAssertion\");\n        }\n\n        // Initialize assertion.\n        lastCreatedAssertionID++;\n        emit AssertionCreated(lastCreatedAssertionID, msg.sender, vmHash, inboxSize);\n        assertions.createAssertion(\n            lastCreatedAssertionID, vmHash, inboxSize, parentID, newAssertionDeadline()\n        );\n\n        // Update stake.\n        stakeOnAssertion(stakerAddr, lastCreatedAssertionID);\n        // confirmed this assertion instantly\n        lastResolvedAssertionID++;\n        lastConfirmedAssertionID = lastResolvedAssertionID;\n        emit AssertionConfirmed(lastResolvedAssertionID);\n    }\n\n    /// @inheritdoc IRollup\n    function createAssertionWithStateBatch(\n        bytes32 vmHash,\n        uint256 inboxSize,\n        bytes32[] calldata _batch,\n        uint256 _shouldStartAtElement,\n        bytes calldata _signature\n        ) external override operatorOnly {\n        // permissions only allow rollup proposer to submit assertion, only allow RollupContract to append new batch\n        require(msg.sender == resolve(\"BVM_Rolluper\"), \"msg.sender is not rollup proposer, can't append batch\");\n        // create assertion\n        createAssertion(vmHash, inboxSize);\n        // append state batch\n        address scc = resolve(\"StateCommitmentChain\");\n        (bool success, ) = scc.call(\n            abi.encodeWithSignature(\"appendStateBatch(bytes32[],uint256,bytes)\", _batch, _shouldStartAtElement, _signature)\n        );\n        require(success, \"scc append state batch failed, revert all\");\n    }\n\n    function challengeAssertion(address[2] calldata players, uint256[2] calldata assertionIDs)\n        external\n        override\n        operatorOnly\n        returns (address)\n    {\n        uint256 defenderAssertionID = assertionIDs[0];\n        uint256 challengerAssertionID = assertionIDs[1];\n        // Require IDs ordered and in-range.\n        if (defenderAssertionID >= challengerAssertionID) {\n            revert(\"WrongOrder\");\n        }\n        if (challengerAssertionID > lastCreatedAssertionID) {\n            revert(\"UnproposedAssertion\");\n        }\n        if (lastConfirmedAssertionID >= defenderAssertionID) {\n            revert(\"AssertionAlreadyResolved\");\n        }\n        // Require that players have attested to sibling assertions.\n        uint256 parentID = assertions.getParentID(defenderAssertionID);\n        if (parentID != assertions.getParentID(challengerAssertionID)) {\n            revert(\"DifferentParent\");\n        }\n        // Require that neither player is currently engaged in a challenge.\n        address defender = players[0];\n        address challenger = players[1];\n        require(defender != challenger, \"defender and challenge must not equal\");\n        address defenderStaker = registers[defender];\n        address challengerStaker = registers[challenger];\n        requireUnchallengedStaker(defenderStaker);\n        requireUnchallengedStaker(challengerStaker);\n\n        // TODO: Calculate upper limit for allowed node proposal time.\n\n        // Initialize challenge.\n        Challenge challenge = new Challenge();\n        address challengeAddr = address(challenge);\n        stakers[challengerStaker].currentChallenge = challengeAddr;\n        stakers[defenderStaker].currentChallenge = challengeAddr;\n\n        challengeCtx = ChallengeCtx(false,challengeAddr,defender,challenger,defenderAssertionID,challengerAssertionID);\n        emit AssertionChallenged(defenderAssertionID, challengeAddr);\n        uint256 inboxSize = assertions.getInboxSize(parentID);\n        bytes32 parentStateHash = assertions.getStateHash(parentID);\n        bytes32 defenderStateHash = assertions.getStateHash(defenderAssertionID);\n        challenge.initialize(\n            defender,\n            challenger,\n            verifier,\n            address(this),\n            inboxSize,\n            parentStateHash,\n            defenderStateHash\n        );\n        return challengeAddr;\n    }\n\n    /// @inheritdoc IRollup\n    function confirmFirstUnresolvedAssertion() public override operatorOnly {\n        if (lastResolvedAssertionID >= lastCreatedAssertionID) {\n            revert(\"NoUnresolvedAssertion\");\n        }\n\n        // (1) there is at least one staker, and\n        if (numStakers <= 0) revert(\"NoStaker\");\n\n        uint256 lastUnresolvedID = lastResolvedAssertionID + 1;\n\n        // (2) challenge period has passed\n        if (block.timestamp < assertions.getDeadline(lastUnresolvedID)) {\n            revert(\"ChallengePeriodPending\");\n        }\n\n        // (3) predecessor has been confirmed\n        if (assertions.getParentID(lastUnresolvedID) != lastConfirmedAssertionID) {\n            revert(\"InvalidParent\");\n        }\n\n        // Remove old zombies\n        // removeOldZombies();\n\n        // (4) all stakers are staked on the block.\n        // if (assertions.getNumStakers(lastUnresolvedID) != numStakers) {\n        //    revert(\"NotAllStaked\");\n        // }\n\n        // there is no slashing mechanism currently,\n        // we can not handle offline staker if we sum up zombies and numStakers,\n        // in which case a offline validator can block confirmation progress.\n        // if (assertions.getNumStakers(lastUnresolvedID) != countStakedZombies(lastUnresolvedID) + numStakers) {\n        //    revert NotAllStaked();\n        // }\n\n        // Confirm assertion.\n        // assertions.deleteAssertion(lastConfirmedAssertionID);\n        lastResolvedAssertionID++;\n        lastConfirmedAssertionID = lastResolvedAssertionID;\n        emit AssertionConfirmed(lastResolvedAssertionID);\n    }\n\n    /// @inheritdoc IRollup\n    function rejectFirstUnresolvedAssertion() external override operatorOnly {\n        if (lastResolvedAssertionID >= lastCreatedAssertionID) {\n            revert(\"NoUnresolvedAssertion\");\n        }\n\n        uint256 firstUnresolvedAssertionID = lastResolvedAssertionID + 1;\n\n        // First case - parent of first unresolved is last confirmed (`if` condition below). e.g.\n        // [1] <- [3]           | valid chain ([1] is last confirmed, [3] is stakerAddress's unresolved assertion)\n        //  ^---- [2]           | invalid chain ([2] is firstUnresolved)\n        // Second case (trivial) - parent of first unresolved is not last confirmed. i.e.:\n        //   parent is previous rejected, e.g.\n        //   [1] <- [4]           | valid chain ([1] is last confirmed, [4] is stakerAddress's unresolved assertion)\n        //   [2] <- [3]           | invalid chain ([3] is firstUnresolved)\n        //   OR\n        //   parent is previous confirmed, e.g.\n        //   [1] <- [2] <- [4]    | valid chain ([2] is last confirmed, [4] is stakerAddress's unresolved assertion)\n        //    ^---- [3]           | invalid chain ([3] is firstUnresolved)\n        if (assertions.getParentID(firstUnresolvedAssertionID) == lastConfirmedAssertionID) {\n            // 1a. challenge period has passed.\n            if (block.timestamp < assertions.getDeadline(firstUnresolvedAssertionID)) {\n                revert(\"ChallengePeriodPending\");\n            }\n            // 1b. at least one staker exists (on a sibling)\n            // - stakerAddress is indeed a staker\n            // requireStaked(stakerAddress);\n            // - staker's assertion can't be a ancestor of firstUnresolved (because staker's assertion is also unresolved)\n            // if (stakers[stakerAddress].assertionID < firstUnresolvedAssertionID) {\n            //    revert(\"AssertionAlreadyResolved\");\n            // }\n            // - staker's assertion can't be a descendant of firstUnresolved (because staker has never staked on firstUnresolved)\n            // if (assertions.isStaker(firstUnresolvedAssertionID, stakerAddress)) {\n            //    revert(\"StakerStakedOnTarget\");\n            // }\n            // If a staker is staked on an assertion that is neither an ancestor nor a descendant of firstUnresolved, it must be a sibling, QED\n\n            // 1c. no staker is staked on this assertion\n            // removeOldZombies();\n            if (assertions.getNumStakers(firstUnresolvedAssertionID) != countStakedZombies(firstUnresolvedAssertionID))\n            {\n                revert(\"StakersPresent\");\n            }\n        }\n\n        // Reject assertion.\n        lastResolvedAssertionID++;\n        emit AssertionRejected(lastResolvedAssertionID);\n        assertions.deleteAssertion(lastResolvedAssertionID);\n    }\n\n/// @inheritdoc IRollup\n    function rejectLatestCreatedAssertionWithBatch(Lib_BVMCodec.ChainBatchHeader memory _batchHeader) external override onlyOwner {\n        address scc = resolve(\"StateCommitmentChain\");\n\n        // batch shift\n        (, bytes memory data) = scc.call(\n            abi.encodeWithSignature(\"getTotalBatches()\")\n        );\n        uint256 totalBatches = uint256(bytes32(data));\n        require(totalBatches-_batchHeader.batchIndex == 1, \"delete batch with gap is not allowed\");\n\n        // Delete state batch\n        (bool success, ) = scc.call(\n            abi.encodeWithSignature(\"deleteStateBatch((uint256,bytes32,uint256,uint256,bytes,bytes))\", _batchHeader)\n        );\n        require(success, \"scc delete state batch failed, revert all\");\n\n        // Reject assertion.\n        require(lastCreatedAssertionID >= lastResolvedAssertionID, \"delete assertion before last resolved in error\");\n        emit AssertionRejected(lastCreatedAssertionID);\n        assertions.deleteAssertionForBatch(lastCreatedAssertionID);\n        lastCreatedAssertionID--;\n        lastResolvedAssertionID--;\n        lastConfirmedAssertionID--;\n\n        // Revert status\n        for (uint i = 0; i < stakerslist.length; i++) {\n            if (stakers[stakerslist[i]].assertionID > lastCreatedAssertionID) {\n                stakers[stakerslist[i]].assertionID = lastCreatedAssertionID;\n            }\n        }\n    }\n\n    /// @inheritdoc IRollup\n    function completeChallenge(address winner, address loser) external override operatorOnly {\n        address winnerStaker = registers[winner];\n        address loserStaker = registers[loser];\n        requireStaked(loserStaker);\n\n        address challenge = getChallenge(winnerStaker, loserStaker);\n        if (msg.sender != challenge) {\n            revert(\"NotChallenge\");\n        }\n        uint256 amountWon;\n        uint256 loserStake = stakers[loserStaker].amountStaked;\n        // uint256 winnerStake = stakers[winnerStaker].amountStaked;\n        if (loserStake > baseStakeAmount) {\n            // If loser has a higher stake than the base stake amount, refund the difference.\n            // Loser gets deleted anyways, so maybe unnecessary to set amountStaked.\n            // stakers[loser].amountStaked = winnerStake;\n            withdrawableFunds[loserStaker] += (loserStake - baseStakeAmount);\n            amountWon = baseStakeAmount;\n        } else {\n            amountWon = loserStake;\n        }\n        // Reward the winner with winner amount\n        stakers[winnerStaker].amountStaked += amountWon; // why +stake instead of +withdrawable?\n        stakers[winnerStaker].currentChallenge = address(0);\n        // Turning loser into zombie renders the loser's remaining stake inaccessible.\n        uint256 assertionID = stakers[loserStaker].assertionID;\n        deleteStaker(loserStaker);\n        // Track as zombie so we can account for it during assertion resolution.\n        zombies.push(Zombie(loserStaker, assertionID));\n        challengeCtx.completed = true;\n    }\n\n    /// @inheritdoc IRollup\n    function rollbackL2Chain(uint256 _shouldRollBack, uint256 _shouldStartAtElement, bytes memory _signature) external override onlyOwner {\n        address scc = resolve(\"StateCommitmentChain\");\n\n        // batch shift\n        (bool success, ) = scc.call(\n            abi.encodeWithSignature(\"rollBackL2Chain(uint256,uint256,bytes)\", _shouldRollBack, _shouldStartAtElement, _signature)\n        );\n        require(success, \"call rollBackL2Chain failed\");\n    }\n\n    /**\n     * @notice Updates staker and assertion metadata.\n     * @param stakerAddress Address of existing staker.\n     * @param assertionID ID of existing assertion to stake on.\n     */\n    function stakeOnAssertion(address stakerAddress, uint256 assertionID) private {\n        stakers[stakerAddress].assertionID = assertionID;\n        assertions.stakeOnAssertion(assertionID, stakerAddress);\n        emit StakerStaked(stakerAddress, assertionID);\n    }\n\n    /**\n     * @notice Deletes the staker from global state. Does not touch assertion staker state.\n     * @param stakerAddress Address of the staker to delete\n     */\n    function deleteStaker(address stakerAddress) private {\n        numStakers--;\n        address operator = stakers[stakerAddress].operator;\n        delete stakers[stakerAddress];\n        delete registers[operator];\n    }\n\n    /**\n     * @notice Checks to see whether the two stakers are in the same challenge\n     * @param staker1Address Address of the first staker\n     * @param staker2Address Address of the second staker\n     * @return Address of the challenge that the two stakers are in\n     */\n    function getChallenge(address staker1Address, address staker2Address) private view returns (address) {\n        Staker storage staker1 = stakers[staker1Address];\n        Staker storage staker2 = stakers[staker2Address];\n        address challenge = staker1.currentChallenge;\n        if (challenge == address(0)) {\n            revert(\"NotInChallenge\");\n        }\n        if (challenge != staker2.currentChallenge) {\n            revert(\"InDifferentChallenge\");\n        }\n        return challenge;\n    }\n\n    function newAssertionDeadline() private returns (uint256) {\n        // TODO: account for prev assertion, gas\n        // return block.number + confirmationPeriod;\n        address scc = resolve(\"StateCommitmentChain\");\n        (bool success, bytes memory data) = scc.call(\n            abi.encodeWithSignature(\"FRAUD_PROOF_WINDOW()\")\n        );\n        require(success,\"call FRAUD_PROOF_WINDOW() failed\");\n        uint256 confirmationWindow = uint256(bytes32(data));\n        return block.timestamp + confirmationWindow;\n    }\n\n    // *****************\n    // zombie processing\n    // *****************\n\n    function removeOldZombies() external operatorOnly {\n        delete zombies;\n    }\n    /**\n     * @notice Removes any zombies whose latest stake is earlier than the first unresolved assertion.\n     * @dev Uses pop() instead of delete to prevent gaps, although order is not preserved\n     */\n    // function removeOldZombies() private {\n    // }\n\n    /**\n     * @notice Counts the number of zombies staked on an assertion.\n     * @dev O(n), where n is # of zombies (but is expected to be small).\n     * This function could be uncallable if there are too many zombies. However,\n     * removeOldZombies() can be used to remove any zombies that exist so that this\n     * will then be callable.\n     * @param assertionID The assertion on which to count staked zombies\n     * @return The number of zombies staked on the assertion\n     */\n    function countStakedZombies(uint256 assertionID) private view returns (uint256) {\n        uint256 numStakedZombies = 0;\n        for (uint256 i = 0; i < zombies.length; i++) {\n            if (assertions.isStaker(assertionID, zombies[i].stakerAddress)) {\n                numStakedZombies++;\n            }\n        }\n        return numStakedZombies;\n    }\n\n    // ************\n    // requirements\n    // ************\n\n    function requireStaked(address stakerAddress) private view {\n        if (!isStaked(stakerAddress)) {\n            revert(\"NotStaked\");\n        }\n    }\n\n    function requireUnchallengedStaker(address stakerAddress) private view {\n        requireStaked(stakerAddress);\n        if (stakers[stakerAddress].currentChallenge != address(0)) {\n            revert(\"ChallengedStaker\");\n        }\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/challenge/Challenge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Modifications Copyright 2022, Specular contributors\n *\n * This file was changed in accordance to Apache License, Version 2.0.\n *\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IChallenge.sol\";\nimport \"./ChallengeLib.sol\";\nimport \"../IRollup.sol\";\n\ncontract Challenge is IChallenge {\n    struct BisectedStore {\n        bytes32 startState;\n        bytes32 midState;\n        bytes32 endState;\n        uint256 blockNum;\n        uint256 blockTime;\n        uint256 challengedSegmentStart;\n        uint256 challengedSegmentLength;\n    }\n\n    enum Turn {\n        NoChallenge,\n        Challenger,\n        Defender\n    }\n\n    // Error codes\n\n    // Can only initialize once\n    string private constant CHAL_INIT_STATE = \"CHAL_INIT_STATE\";\n    // deadline expired\n    string private constant BIS_DEADLINE = \"BIS_DEADLINE\";\n    // Only original asserter can continue bisect\n    string private constant BIS_SENDER = \"BIS_SENDER\";\n    // Incorrect previous state\n    string private constant BIS_PREV = \"BIS_PREV\";\n    // Can't timeout before deadline\n    string private constant TIMEOUT_DEADLINE = \"TIMEOUT_DEADLINE\";\n\n    bytes32 private constant UNREACHABLE_ASSERTION = bytes32(uint256(0));\n\n    uint256 private constant MAX_BISECTION_DEGREE = 2;\n\n    // Other contracts\n    address internal resultReceiver;\n    IVerifierEntry internal verifier;\n\n    // Challenge state\n    address public defender;\n    address public challenger;\n    uint256 public lastMoveBlockTime;\n    uint256 public defenderTimeLeft;\n    uint256 public challengerTimeLeft;\n\n    Turn public turn;\n    // See `ChallengeLib.computeBisectionHash` for the format of this commitment.\n    bytes32 public bisectionHash;\n    bytes32[3] public prevBisection;\n\n    // Initial state used to initialize bisectionHash (write-once).\n    bytes32 private startStateHash;\n    bytes32 private endStateHash;\n\n    address public winner;\n\n    bool public rollback;\n    uint256 public startInboxSize;\n\n    BisectedStore public currentBisected;\n\n    /**\n     * @notice Pre-condition: `msg.sender` is correct and still has time remaining.\n     * Post-condition: `turn` changes and `lastMoveBlock` set to current `block.number`.\n     */\n    modifier onlyOnTurn() {\n        require(msg.sender == currentResponder(), BIS_SENDER);\n        require(block.timestamp - lastMoveBlockTime <= currentResponderTimeLeft(), BIS_DEADLINE);\n\n        _;\n\n        if (turn == Turn.Challenger) {\n            challengerTimeLeft = challengerTimeLeft - (block.timestamp- lastMoveBlockTime);\n            turn = Turn.Defender;\n        } else if (turn == Turn.Defender) {\n            defenderTimeLeft = defenderTimeLeft - (block.timestamp - lastMoveBlockTime);\n            turn = Turn.Challenger;\n        }\n        lastMoveBlockTime = block.timestamp;\n    }\n\n    /**\n     * @notice Ensures challenge has been initialized.\n     */\n    modifier postInitialization() {\n        require(bisectionHash != 0, \"NOT_INITIALIZED\");\n        _;\n    }\n\n    modifier onlyDefender(){\n        require(defender != address(0),\"Defender not set\");\n        require(msg.sender==defender,\"Caller not defender\");\n        _;\n    }\n\n    function initialize(\n        address _defender,\n        address _challenger,\n        IVerifierEntry _verifier,\n        address _resultReceiver,\n        uint256 _startInboxSize,\n        bytes32 _startStateHash,\n        bytes32 _endStateHash\n    ) external override {\n        require(turn == Turn.NoChallenge, CHAL_INIT_STATE);\n        require(_defender != address(0) && _challenger != address(0) && _resultReceiver != address(0), \"ZERO_ADDRESS\");\n        defender = _defender;\n        challenger = _challenger;\n        verifier = _verifier;\n        resultReceiver = _resultReceiver;\n        startStateHash = _startStateHash;\n        endStateHash = _endStateHash;\n\n        turn = Turn.Defender;\n        lastMoveBlockTime = block.timestamp;\n        // TODO(ujval): initialize timeout\n        defenderTimeLeft = 150;\n        challengerTimeLeft = 150;\n        prevBisection[0] = _startStateHash;\n        prevBisection[1] = bytes32(0);\n        prevBisection[2] = _endStateHash;\n\n        startInboxSize = _startInboxSize;\n    }\n\n    function initializeChallengeLength(bytes32 checkStateHash, uint256 _numSteps) external override onlyOnTurn {\n        require(bisectionHash == 0, CHAL_INIT_STATE);\n        require(_numSteps > 0, \"INVALID_NUM_STEPS\");\n        bisectionHash = ChallengeLib.computeBisectionHash(0, _numSteps);\n        // TODO: consider emitting a different event?\n        currentBisected = BisectedStore(startStateHash, checkStateHash, endStateHash, block.number, block.timestamp, 0, _numSteps);\n        emit Bisected(startStateHash, checkStateHash, endStateHash, block.number, block.timestamp, 0, _numSteps);\n    }\n\n    function bisectExecution(\n        bytes32[3] calldata bisection,\n        uint256 challengedSegmentIndex,\n        uint256 challengedSegmentStart,\n        uint256 challengedSegmentLength,\n        uint256 prevChallengedSegmentStart,\n        uint256 prevChallengedSegmentLength\n    ) external override onlyOnTurn postInitialization {\n        // Verify provided prev bisection.\n        bytes32 prevHash = ChallengeLib.computeBisectionHash(prevChallengedSegmentStart, prevChallengedSegmentLength);\n        require(prevHash == bisectionHash, BIS_PREV);\n\n        // Require agreed upon start state hash and disagreed upon end state hash.\n        if (prevBisection[1] != bytes32(0)) {\n            require(bisection[0] == prevBisection[0] || bisection[0] == prevBisection[1], \"AMBIGUOUS_START\");\n        }\n        require(bisection[2] != prevBisection[2], \"INVALID_END\");\n\n        // Compute segment start/length.\n        require(challengedSegmentLength > 0, \"TOO_SHORT\");\n\n        // Compute new challenge state.\n        prevBisection[0] = bisection[0];\n        prevBisection[1] = bisection[1];\n        prevBisection[2] = bisection[2];\n        bisectionHash = ChallengeLib.computeBisectionHash(challengedSegmentStart, challengedSegmentLength);\n        currentBisected = BisectedStore(bisection[0], bisection[1], bisection[2], block.number, block.timestamp, challengedSegmentStart, challengedSegmentLength);\n        emit Bisected(bisection[0], bisection[1], bisection[2], block.number, block.timestamp, challengedSegmentStart, challengedSegmentLength);\n    }\n\n    function verifyOneStepProof(\n        VerificationContext.Context calldata ctx,\n        uint8 verifyType,\n        bytes calldata proof,\n        uint256 challengedStepIndex,\n        uint256 prevChallengedSegmentStart,\n        uint256 prevChallengedSegmentLength\n    ) external override onlyOnTurn {\n         // Verify provided prev bisection.\n         bytes32 prevHash =\n            ChallengeLib.computeBisectionHash(prevChallengedSegmentStart, prevChallengedSegmentLength);\n         require(prevHash == bisectionHash, BIS_PREV);\n         // require(challengedStepIndex > 0 && challengedStepIndex < prevBisection.length, \"INVALID_INDEX\");\n         // Require that this is the last round.\n         require(prevChallengedSegmentLength / MAX_BISECTION_DEGREE <= 1, \"BISECTION_INCOMPLETE\");\n\n         // verify OSP\n         // IVerificationContext ctx = <get ctx from sequenced txs>;\n\n         bytes32 nextStateHash = verifier.verifyOneStepProof(\n             ctx,\n             verifyType,\n             prevBisection[challengedStepIndex-1],\n             proof\n         );\n         if (nextStateHash == prevBisection[challengedStepIndex]) {\n             // osp verified, current win\n             _currentWin(CompletionReason.OSP_VERIFIED);\n         } else {\n             _currentLose(CompletionReason.OSP_VERIFIED);\n         }\n    }\n\n    function setRollback() public {\n        if (rollback) {\n            revert(\"ALREADY_SET_ROLLBACK\");\n        }\n        rollback = true;\n    }\n\n    function timeout() external override {\n        require(block.timestamp - lastMoveBlockTime > currentResponderTimeLeft(), TIMEOUT_DEADLINE);\n        if (turn == Turn.Defender) {\n            _challengerWin(CompletionReason.TIMEOUT);\n        } else {\n            _asserterWin(CompletionReason.TIMEOUT);\n        }\n    }\n\n    function currentResponder() public view override returns (address) {\n        if (turn == Turn.Defender) {\n            return defender;\n        } else if (turn == Turn.Challenger) {\n            return challenger;\n        } else {\n            revert(\"NO_TURN\");\n        }\n    }\n\n    function currentResponderTimeLeft() public view override returns (uint256) {\n        if (turn == Turn.Defender) {\n            return defenderTimeLeft;\n        } else if (turn == Turn.Challenger) {\n            return challengerTimeLeft;\n        } else {\n            revert(\"NO_TURN\");\n        }\n    }\n\n    function _currentWin(CompletionReason reason) private {\n        if (turn == Turn.Defender) {\n            _asserterWin(reason);\n        } else {\n            winner = challenger;\n            _challengerWin(reason);\n        }\n    }\n\n    function _currentLose(CompletionReason reason) private {\n        if (turn == Turn.Defender) {\n            _challengerWin(reason);\n        } else {\n            _asserterWin(reason);\n        }\n    }\n\n    function _asserterWin(CompletionReason reason) private {\n        winner = defender;\n        emit ChallengeCompleted(defender, challenger, reason);\n    }\n\n    function _challengerWin(CompletionReason reason) private {\n        winner = challenger;\n        emit ChallengeCompleted(challenger, defender, reason);\n    }\n\n    function completeChallenge(bool result) external onlyDefender{\n        require(winner != address(0),\"Do not have winner\");\n\n        if (winner == challenger) {\n            if (result) {\n                IRollup(resultReceiver).completeChallenge(challenger, defender);\n                return;\n            }\n            winner = defender;\n        }\n        IRollup(resultReceiver).completeChallenge(defender, challenger);\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/challenge/ChallengeLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Modifications Copyright 2022, Specular contributors\n *\n * This file was changed in accordance to Apache License, Version 2.0.\n *\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nlibrary ChallengeLib {\n    /**\n     * @notice Computes the initial bisection hash.\n     * @param numSteps Number of steps from the end of `startState` to the end of `endState`.\n     */\n    function initialBisectionHash(uint256 numSteps)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return ChallengeLib.computeBisectionHash(0, numSteps);\n    }\n\n    /**\n     * @notice Computes H(bisection || segmentStart || segmentLength)\n     * @param challengedSegmentStart The number of steps preceding `bisection[1]`, relative to the assertion being challenged.\n     * @param challengedSegmentLength Length of bisected segment (in steps), from the start of bisection[1] to the end of bisection[-1].\n     */\n    function computeBisectionHash(\n        uint256 challengedSegmentStart,\n        uint256 challengedSegmentLength\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(challengedSegmentStart, challengedSegmentLength));\n    }\n\n    /**\n     * @notice Returns length of first segment in a bisection.\n     */\n    function firstSegmentLength(uint256 length, uint256 bisectionDegree) internal pure returns (uint256) {\n        return length / bisectionDegree + length % bisectionDegree;\n    }\n\n    /**\n     * @notice Returns length of a segment (after first) in a bisection.\n     */\n    function otherSegmentLength(uint256 length, uint256 bisectionDegree) internal pure returns (uint256) {\n        return length / bisectionDegree;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/AssertionMap.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Modifications Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./libraries/Errors.sol\";\n\n// Exists only to reduce size of Rollup contract (maybe revert since Rollup fits under optimized compilation).\ncontract AssertionMap is Initializable {\n    error ChildInboxSizeMismatch();\n\n    error SiblingStateHashExists();\n\n    struct Assertion {\n        bytes32 stateHash; // Hash of execution state associated with assertion (see `RollupLib.stateHash`)\n        uint256 inboxSize; // Inbox size this assertion advanced to\n        uint256 parent; // Parent assertion ID\n        uint256 deadline; // Confirmation deadline (L1 block timestamp)\n        uint256 proposalTime; // L1 block number at which assertion was proposed\n        // Staking state\n        uint256 numStakers; // total number of stakers that have ever staked on this assertion. increasing only.\n        // Child state\n        uint256 childInboxSize; // child assertion inbox state\n    }\n\n    struct AssertionState {\n        mapping(address => bool) stakers; // all stakers that have ever staked on this assertion.\n        mapping(bytes32 => bool) childStateHashes; // child assertion vm hashes\n    }\n\n    mapping(uint256 => Assertion) public assertions;\n    mapping(uint256 => AssertionState) private assertionStates; // mapping from assertionID to assertion state\n    address public rollupAddress;\n\n    modifier rollupOnly() {\n        if (msg.sender != rollupAddress) {\n            revert NotRollup(msg.sender, rollupAddress);\n        }\n        _;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize() public initializer {}\n\n    function setRollupAddress(address _rollupAddress) public {\n        require(\n            address(rollupAddress) == address(0),\n            \"rollupAddress already initialized.\"\n        );\n        require(_rollupAddress != address(0), \"ZERO_ADDRESS\");\n        rollupAddress = _rollupAddress;\n    }\n\n    function getStateHash(uint256 assertionID) external view returns (bytes32) {\n        return assertions[assertionID].stateHash;\n    }\n\n    function getInboxSize(uint256 assertionID) external view returns (uint256) {\n        return assertions[assertionID].inboxSize;\n    }\n\n    function getParentID(uint256 assertionID) external view returns (uint256) {\n        return assertions[assertionID].parent;\n    }\n\n    function getDeadline(uint256 assertionID) external view returns (uint256) {\n        return assertions[assertionID].deadline;\n    }\n\n    function getProposalTime(uint256 assertionID) external view returns (uint256) {\n        return assertions[assertionID].proposalTime;\n    }\n\n    function getNumStakers(uint256 assertionID) external view returns (uint256) {\n        return assertions[assertionID].numStakers;\n    }\n\n    function isStaker(uint256 assertionID, address stakerAddress) external view returns (bool) {\n        return assertionStates[assertionID].stakers[stakerAddress];\n    }\n\n    function createAssertion(\n        uint256 assertionID,\n        bytes32 stateHash,\n        uint256 inboxSize,\n        uint256 parentID,\n        uint256 deadline\n    ) external rollupOnly {\n        Assertion storage parentAssertion = assertions[parentID];\n        AssertionState storage parentAssertionState = assertionStates[parentID];\n        // Child assertions must have same inbox size\n        uint256 parentChildInboxSize = parentAssertion.childInboxSize;\n        if (parentChildInboxSize == 0) {\n            parentAssertion.childInboxSize = inboxSize;\n        } else {\n            if (inboxSize != parentChildInboxSize) {\n                revert(\"ChildInboxSizeMismatch\");\n            }\n        }\n        if (parentAssertionState.childStateHashes[stateHash]) {\n            revert(\"SiblingStateHashExists\");\n        }\n\n        parentAssertionState.childStateHashes[stateHash] = true;\n\n        assertions[assertionID] = Assertion(\n            stateHash,\n            inboxSize,\n            parentID,\n            deadline,\n            block.number, // proposal time\n            0, // numStakers\n            0 // childInboxSize\n        );\n    }\n\n    function stakeOnAssertion(uint256 assertionID, address stakerAddress) external rollupOnly {\n        Assertion storage assertion = assertions[assertionID];\n        assertionStates[assertionID].stakers[stakerAddress] = true;\n        assertion.numStakers++;\n    }\n\n    function deleteAssertion(uint256 assertionID) external rollupOnly {\n        delete assertions[assertionID];\n    }\n\n    function deleteAssertionForBatch(uint256 assertionID) external rollupOnly {\n        bytes32 stateHash = assertions[assertionID].stateHash;\n        uint256 parentID = assertions[assertionID].parent;\n        delete assertions[assertionID];\n        assertions[parentID].childInboxSize = 0;\n        assertionStates[parentID].childStateHashes[stateHash] = false;\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/IRollup.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Modifications Copyright 2022, Specular contributors\n *\n * This file was changed in accordance to Apache License, Version 2.0.\n *\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"./AssertionMap.sol\";\nimport {Lib_BVMCodec} from \"../../libraries/codec/Lib_BVMCodec.sol\";\n\ninterface IRollup {\n    event AssertionCreated(\n        uint256 assertionID, address asserterAddr, bytes32 vmHash, uint256 inboxSize\n    );\n\n    event AssertionChallenged(uint256 assertionID, address challengeAddr);\n\n    event AssertionConfirmed(uint256 assertionID);\n\n    event AssertionRejected(uint256 assertionID);\n\n    event StakerStaked(address stakerAddr, uint256 assertionID);\n\n    /// @dev Thrown when address that have not staked any token calls a only-staked function\n    error NotStaked();\n\n    /// @dev Thrown when the function is called with Insufficient Stake\n    error InsufficientStake();\n\n    /// @dev Thrown when the caller is staked on unconfirmed assertion.\n    error StakedOnUnconfirmedAssertion();\n\n    /// @dev Thrown when transfer fails\n    error TransferFailed();\n\n    /// @dev Thrown when a staker tries to advance stake to invalid assertionId.\n    error AssertionOutOfRange();\n\n    /// @dev Thrown when a staker tries to advance stake to non-child assertion\n    error ParentAssertionUnstaked();\n\n    /// @dev Thrown when a sender tries to create assertion before the minimum assertion time period\n    error MinimumAssertionPeriodNotPassed();\n\n    /// @dev Thrown when parent's statehash is not equal to the start state(or previous state)/\n    error PreviousStateHash();\n\n    /// @dev Thrown when a sender tries to create assertion without any tx.\n    error EmptyAssertion();\n\n    /// @dev Thrown when the requested assertion read past the end of current Inbox.\n    error InboxReadLimitExceeded();\n\n    /// @dev Thrown when the challenge assertion Id is not ordered or in range.\n    error WrongOrder();\n\n    /// @dev Thrown when the challenger tries to challenge an unproposed assertion\n    error UnproposedAssertion();\n\n    /// @dev Thrown when the assertion is already resolved\n    error AssertionAlreadyResolved();\n\n    /// @dev Thrown when there is no unresolved assertion\n    error NoUnresolvedAssertion();\n\n    /// @dev Thrown when the challenge period has not passed\n    error ChallengePeriodPending();\n\n    /// @dev Thrown when the challenger and defender didn't attest to sibling assertions\n    error DifferentParent();\n\n    /// @dev Thrown when the assertion's parent is not the last confirmed assertion\n    error InvalidParent();\n\n    /// @dev Thrown when the staker is not in a challenge\n    error NotInChallenge();\n\n    /// @dev Thrown when the two stakers are in different challenge\n    /// @param staker1Challenge challenge address of staker 1\n    /// @param staker2Challenge challenge address of staker 2\n    error InDifferentChallenge(address staker1Challenge, address staker2Challenge);\n\n    /// @dev Thrown when the staker is currently in Challenge\n    error ChallengedStaker();\n\n    /// @dev Thrown when all the stakers are not staked\n    error NotAllStaked();\n\n    /// @dev Thrown staker's assertion is descendant of firstUnresolved assertion\n    error StakerStakedOnTarget();\n\n    /// @dev Thrown when there are staker's present on the assertion\n    error StakersPresent();\n\n    /// @dev Thrown when there are zero stakers\n    error NoStaker();\n\n    /// @dev Thrown when slot is not blank in initialize step\n    error RedundantInitialized();\n\n    /// @dev Thrown when function is called with a zero address argument\n    error ZeroAddress();\n\n    function assertions() external view returns (AssertionMap);\n\n    /**\n     * @param addr User address.\n     * @return True if address is staked, else False.\n     */\n    function isStaked(address addr) external view returns (bool);\n\n    /**\n     * @return The current required stake amount.\n     */\n    function currentRequiredStake() external view returns (uint256);\n\n    /**\n     * @return confirmedInboxSize size of inbox confirmed\n     */\n    function confirmedInboxSize() external view returns (uint256);\n\n    /**\n     * @notice Deposits stake on staker's current assertion (or the last confirmed assertion if not currently staked).\n     * @notice currently use MNT to stake; stakeAmount Token amount to deposit. Must be > than defined threshold if this is a new stake.\n     */\n     function stake(uint256 stakeAmount, address operator) external;\n\n    /**\n     * @notice Withdraws stakeAmount from staker's stake by if assertion it is staked on is confirmed.\n     * @param stakeAmount Token amount to withdraw. Must be <= sender's current stake minus the current required stake.\n     */\n    function unstake(uint256 stakeAmount) external;\n\n    /**\n     * @notice Removes stakerAddress from the set of stakers and withdraws the full stake amount to stakerAddress.\n     * This can be called by anyone since it is currently necessary to keep the chain progressing.\n     * @param stakerAddress Address of staker for which to unstake.\n     */\n    function removeStake(address stakerAddress) external;\n\n    /**\n     * @notice Advances msg.sender's existing sake to assertionID.\n     * @param assertionID ID of assertion to advance stake to. Currently this must be a child of the current assertion.\n     * TODO: generalize to arbitrary descendants.\n     */\n    function advanceStake(uint256 assertionID) external;\n\n    /**\n     * @notice Withdraws all of msg.sender's withdrawable funds.\n     */\n    function withdraw() external;\n\n    /**\n     * @notice Creates a new DA representing the rollup state after executing a block of transactions (sequenced in SequencerInbox).\n     * Block is represented by all transactions in range [prevInboxSize, inboxSize]. The latest staked DA of the sender\n     * is considered to be the predecessor. Moves sender stake onto the new DA.\n     *\n     * The new DA stores the hash of the parameters: vmHash\n     *\n     * @param vmHash New VM hash.\n     * @param inboxSize Size of inbox corresponding to assertion (number of transactions).\n     */\n    function createAssertion(\n        bytes32 vmHash,\n        uint256 inboxSize\n    ) external;\n\n    /**\n     *\n     * @notice create assertion with scc state batch\n     *\n     * @param vmHash New VM hash.\n     * @param inboxSize Size of inbox corresponding to assertion (number of transactions).\n     * @param _batch Batch of state roots.\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\n     * @param _signature tss group signature of state batches.\n     */\n    function createAssertionWithStateBatch(\n        bytes32 vmHash,\n        uint256 inboxSize,\n        bytes32[] calldata _batch,\n        uint256 _shouldStartAtElement,\n        bytes calldata _signature\n    ) external;\n\n\n    /**\n     * @notice Initiates a dispute between a defender and challenger on an unconfirmed DA.\n     * @param players Defender (first) and challenger (second) addresses. Must be staked on DAs on different branches.\n     * @param assertionIDs Assertion IDs of the players engaged in the challenge. The first ID should be the earlier-created and is the one being challenged.\n     * @return Newly created challenge contract address.\n     */\n    function challengeAssertion(address[2] calldata players, uint256[2] calldata assertionIDs)\n        external\n        returns (address);\n\n    /**\n     * @notice Confirms first unresolved assertion. Assertion is confirmed if and only if:\n     * (1) there is at least one staker, and\n     * (2) challenge period has passed, and\n     * (3) predecessor has been confirmed, and\n     * (4) all stakers are staked on the assertion.\n     */\n    function confirmFirstUnresolvedAssertion() external;\n\n    /**\n     * @notice Rejects first unresolved assertion. Assertion is rejected if and only if:\n     * (1) all of the following are true:\n     * (a) challenge period has passed, and\n     * (b) at least one staker exists, and\n     * (c) no staker remains staked on the assertion (all have been destroyed).\n     * OR\n     * (2) predecessor has been rejected\n     */\n    function rejectFirstUnresolvedAssertion() external;\n\n    //* @param stakerAddress Address of a staker staked on a different branch to the first unresolved assertion.\n    //* If the first unresolved assertion's parent is confirmed, this parameter is used to establish that a staker exists\n    //* on a different branch of the assertion chain. This parameter is ignored when the parent of the first unresolved\n    //* assertion is not the last confirmed assertion.\n    function rejectLatestCreatedAssertionWithBatch(Lib_BVMCodec.ChainBatchHeader memory _batchHeader) external;\n\n    /**\n     * @notice Completes ongoing challenge. Callback, called by a challenge contract.\n     * @param winner Address of winning staker.\n     * @param loser Address of losing staker.\n     */\n    function completeChallenge(address winner, address loser) external;\n\n    /**\n     * Emit event to notify sequencers to roll back.\n     * @param _shouldRollBack roll back to should start.\n     * @param _shouldStartAtElement Index of the element at which this batch should start\n     * @param _signature signature of rollback message\n     */\n    function rollbackL2Chain(uint256 _shouldRollBack, uint256 _shouldStartAtElement, bytes memory _signature) external;\n}\n"
    },
    "contracts/L1/fraud-proof/RollupLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Modifications Copyright 2022, Specular contributors\n *\n * This file was changed in accordance to Apache License, Version 2.0.\n *\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"./challenge/ChallengeLib.sol\";\n\n// TODO: move into ChallengeLib.\nlibrary RollupLib {\n    struct ExecutionState {\n        bytes32 vmHash;\n    }\n\n    /**\n     * @notice Computes the hash of `execState`.\n     */\n    function stateHash(ExecutionState memory execState) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(execState.vmHash));\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/WhiteList.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\nabstract contract Whitelist {\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    modifier stakerWhitelistOnly(address _checkAddress) {\n        require(stakerslist[stakerWhitelist[_checkAddress]] == _checkAddress, \"NOT_IN_STAKER_WHITELIST\");\n        _;\n    }\n\n    modifier operatorWhitelistOnly(address _checkAddress) {\n        require(operatorslist[operatorWhitelist[_checkAddress]] == _checkAddress, \"NOT_IN_OPERATOR_WHITELIST\");\n        _;\n    }\n\n    address public owner;\n    mapping(address => uint256) public stakerWhitelist;\n    address[] public stakerslist;\n    mapping(address => uint256) public operatorWhitelist;\n    address[] public operatorslist;\n\n    // slot place hold\n    uint256[50] whitelistGap;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice Add to staker whitelist\n     */\n    function addToStakerWhitelist(address[] calldata toAddAddresses) public onlyOwner {\n        uint256 lens = stakerslist.length;\n        for (uint i = 0; i < toAddAddresses.length; i++) {\n            stakerWhitelist[toAddAddresses[i]] = lens+i;\n            stakerslist.push(toAddAddresses[i]);\n        }\n    }\n\n    /**\n     * @notice Remove from whitelist\n     */\n    function removeFromStakerWhitelist(address[] calldata toRemoveAddresses) public onlyOwner {\n        for (uint i = 0; i < toRemoveAddresses.length; i++) {\n            uint256 index = stakerWhitelist[toRemoveAddresses[i]];\n            stakerWhitelist[stakerslist[stakerslist.length-1]] = index;\n            stakerslist[index] = stakerslist[stakerslist.length-1];\n            stakerslist.pop();\n            delete stakerWhitelist[toRemoveAddresses[i]];\n        }\n    }\n\n    /**\n * @notice Add to whitelist\n     */\n    function addToOperatorWhitelist(address[] calldata toAddAddresses) public onlyOwner {\n        uint256 lens = operatorslist.length;\n        for (uint i = 0; i < toAddAddresses.length; i++) {\n            operatorWhitelist[toAddAddresses[i]] = lens+i;\n            operatorslist.push(toAddAddresses[i]);\n        }\n    }\n\n    /**\n     * @notice Remove from whitelist\n     */\n    function removeFromOperatorWhitelist(address[] calldata toRemoveAddresses) public onlyOwner {\n        for (uint i = 0; i < toRemoveAddresses.length; i++) {\n            uint256 index = operatorWhitelist[toRemoveAddresses[i]];\n            operatorWhitelist[operatorslist[operatorslist.length-1]] = index;\n            operatorslist[index] = operatorslist[operatorslist.length-1];\n            operatorslist.pop();\n            delete operatorWhitelist[toRemoveAddresses[i]];\n        }\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/L1/fraud-proof/challenge/IChallenge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Modifications Copyright 2022, Specular contributors\n *\n * This file was changed in accordance to Apache License, Version 2.0.\n *\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nimport \"../verifier/IVerifierEntry.sol\";\n\n/**\n * @notice Protocol execution:\n * `initialize` (challenger, via Rollup) ->\n * `initializeChallengeLength` (defender) ->\n * `bisectExecution` (challenger, defender -- alternating) ->\n * `verifyOneStepProof`\n */\ninterface IChallenge {\n    enum CompletionReason {\n        OSP_VERIFIED, // OSP verified by winner.\n        TIMEOUT // Loser timed out before completing their round.\n    }\n\n    event ChallengeCompleted(address winner, address loser, CompletionReason reason);\n\n    event Bisected(bytes32 startState, bytes32 midState, bytes32 endState, uint256 blockNum, uint256 blockTime, uint256 challengedSegmentStart, uint256 challengedSegmentLength);\n\n    /**\n     * @notice Initializes contract.\n     * @param _defender Defending party.\n     * @param _challenger Challenging party. Challenger starts.\n     * @param _verifier Address of the verifier contract.\n     * @param _resultReceiver Address of contract that will receive the outcome (via callback `completeChallenge`).\n     * @param _startStateHash Bisection root being challenged.\n     * @param _endStateHash Bisection root being challenged.\n     */\n    function initialize(\n        address _defender,\n        address _challenger,\n        IVerifierEntry _verifier,\n        address _resultReceiver,\n        uint256 _startInboxSize,\n        bytes32 _startStateHash,\n        bytes32 _endStateHash\n    ) external;\n\n    /**\n     * @notice Initializes the length of the challenge. Must be called by defender before bisection rounds begin.\n     * @param _numSteps Number of steps executed from the start of the assertion to its end.\n     * If this parameter is incorrect, the defender will be slashed (assuming successful execution of the protocol by the challenger).\n     */\n    function initializeChallengeLength(bytes32 checkStateHash, uint256 _numSteps) external;\n\n    /**\n     * @notice Bisects a segment. The challenged segment is defined by: {`challengedSegmentStart`, `challengedSegmentLength`, `bisection[0]`, `oldEndHash`}\n     * @param bisection Bisection of challenged segment. Each element is a state hash (see `ChallengeLib.stateHash`).\n     * The first element is the last agreed upon state hash. Must be of length MAX_BISECTION_LENGTH for all rounds except the last.\n     * In the last round, the bisection segments must be single steps.\n     * @param challengedSegmentIndex Index into `prevBisection`. Must be greater than 0 (since the first is agreed upon).\n     * @param challengedSegmentStart Offset of the segment challenged in the preceding round (in steps).\n     * @param challengedSegmentLength Length of the segment challenged in the preceding round (in steps).\n     * @param prevChallengedSegmentStart Offset of the segment challenged in the preceding round (in steps).\n     * Note: this is relative to the assertion being challenged (i.e. always between 0 and the initial `numSteps`).\n     * @param prevChallengedSegmentLength Length of the segment challenged in the preceding round (in steps).\n     */\n    function bisectExecution(\n        bytes32[3] calldata bisection,\n        uint256 challengedSegmentIndex,\n        uint256 challengedSegmentStart,\n        uint256 challengedSegmentLength,\n        uint256 prevChallengedSegmentStart,\n        uint256 prevChallengedSegmentLength\n    ) external;\n\n    /**\n     * @notice Verifies one step proof and completes challenge protocol.\n     * @param ctx execution context.\n     * @param verifyType Index into `prevBisection`. Must be greater than 0 (since the first is agreed upon).\n     * @param proof one step proof.\n     * @param prevChallengedSegmentStart Offset of the segment challenged in the preceding round (in steps).\n     * Note: this is relative to the assertion being challenged (i.e. always between 0 and the initial `numSteps`).\n     * @param prevChallengedSegmentLength Length of the segment challenged in the preceding round (in steps).\n     */\n    function verifyOneStepProof(\n        VerificationContext.Context calldata ctx,\n        uint8 verifyType,\n        bytes calldata proof,\n        uint256 challengedStepIndex,\n        uint256 prevChallengedSegmentStart,\n        uint256 prevChallengedSegmentLength\n    ) external;\n\n    function setRollback() external;\n\n    /**\n     * @notice Triggers completion of challenge protocol if a responder timed out.\n     */\n    function timeout() external;\n\n    function currentResponder() external view returns (address);\n\n    function currentResponderTimeLeft() external view returns (uint256);\n\n    function completeChallenge(bool) external;\n}\n"
    },
    "contracts/L1/fraud-proof/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\n/// @dev Thrown when unauthorized (!rollup) address calls an only-rollup function\n/// @param sender Address of the caller\n/// @param rollup The rollup address authorized to call this function\nerror NotRollup(address sender, address rollup);\n\n/// @dev Thrown when unauthorized (!challenge) address calls an only-challenge function\n/// @param sender Address of the caller\n/// @param challenge The challenge address authorized to call this function\nerror NotChallenge(address sender, address challenge);\n\n/// @dev Thrown when unauthorized (!sequencer) address calls an only-sequencer function\n/// @param sender Address of the caller\n/// @param sequencer The sequencer address authorized to call this function\nerror NotSequencer(address sender, address sequencer);\n\n/// @dev Thrown when function is called with a zero address argument\nerror ZeroAddress();\n\n/// @dev Thrown when function is called with a zero address argument\nerror RedundantInitialized();\n"
    },
    "contracts/test-libraries/codec/TestLib_BVMCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_BVMCodec } from \"../../libraries/codec/Lib_BVMCodec.sol\";\n\n/**\n * @title TestLib_BVMCodec\n */\ncontract TestLib_BVMCodec {\n    function encodeTransaction(Lib_BVMCodec.Transaction memory _transaction)\n        public\n        pure\n        returns (bytes memory _encoded)\n    {\n        return Lib_BVMCodec.encodeTransaction(_transaction);\n    }\n\n    function hashTransaction(Lib_BVMCodec.Transaction memory _transaction)\n        public\n        pure\n        returns (bytes32 _hash)\n    {\n        return Lib_BVMCodec.hashTransaction(_transaction);\n    }\n}\n"
    },
    "contracts/test-libraries/utils/TestLib_Bytes32Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_Bytes32Utils } from \"../../libraries/utils/Lib_Bytes32Utils.sol\";\n\n/**\n * @title TestLib_Byte32Utils\n */\ncontract TestLib_Bytes32Utils {\n    function toBool(bytes32 _in) public pure returns (bool _out) {\n        return Lib_Bytes32Utils.toBool(_in);\n    }\n\n    function fromBool(bool _in) public pure returns (bytes32 _out) {\n        return Lib_Bytes32Utils.fromBool(_in);\n    }\n\n    function toAddress(bytes32 _in) public pure returns (address _out) {\n        return Lib_Bytes32Utils.toAddress(_in);\n    }\n\n    function fromAddress(address _in) public pure returns (bytes32 _out) {\n        return Lib_Bytes32Utils.fromAddress(_in);\n    }\n}\n"
    },
    "contracts/test-libraries/utils/TestLib_BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_BytesUtils } from \"../../libraries/utils/Lib_BytesUtils.sol\";\nimport { TestERC20 } from \"../../test-helpers/TestERC20.sol\";\n\n/**\n * @title TestLib_BytesUtils\n */\ncontract TestLib_BytesUtils {\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(_preBytes, _postBytes);\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) public pure returns (bytes memory) {\n        return Lib_BytesUtils.slice(_bytes, _start, _length);\n    }\n\n    function toBytes32(bytes memory _bytes) public pure returns (bytes32) {\n        return Lib_BytesUtils.toBytes32(_bytes);\n    }\n\n    function toUint256(bytes memory _bytes) public pure returns (uint256) {\n        return Lib_BytesUtils.toUint256(_bytes);\n    }\n\n    function toNibbles(bytes memory _bytes) public pure returns (bytes memory) {\n        return Lib_BytesUtils.toNibbles(_bytes);\n    }\n\n    function fromNibbles(bytes memory _bytes) public pure returns (bytes memory) {\n        return Lib_BytesUtils.fromNibbles(_bytes);\n    }\n\n    function equal(bytes memory _bytes, bytes memory _other) public pure returns (bool) {\n        return Lib_BytesUtils.equal(_bytes, _other);\n    }\n\n    function sliceWithTaintedMemory(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) public returns (bytes memory) {\n        new TestERC20();\n        return Lib_BytesUtils.slice(_bytes, _start, _length);\n    }\n}\n"
    },
    "contracts/test-helpers/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestERC20 is ERC20 {\n    constructor() ERC20(\"TEST\", \"TST\") {}\n\n    function mint(address to, uint256 value) public {\n        _mint(to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/test-libraries/rlp/TestLib_RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_RLPWriter } from \"../../libraries/rlp/Lib_RLPWriter.sol\";\nimport { TestERC20 } from \"../../test-helpers/TestERC20.sol\";\n\n/**\n * @title TestLib_RLPWriter\n */\ncontract TestLib_RLPWriter {\n    function writeBytes(bytes memory _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeBytes(_in);\n    }\n\n    function writeList(bytes[] memory _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeList(_in);\n    }\n\n    function writeString(string memory _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeString(_in);\n    }\n\n    function writeAddress(address _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeAddress(_in);\n    }\n\n    function writeUint(uint256 _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeUint(_in);\n    }\n\n    function writeBool(bool _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeBool(_in);\n    }\n\n    function writeAddressWithTaintedMemory(address _in) public returns (bytes memory _out) {\n        new TestERC20();\n        return Lib_RLPWriter.writeAddress(_in);\n    }\n}\n"
    },
    "contracts/test-libraries/trie/TestLib_MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_MerkleTrie } from \"../../libraries/trie/Lib_MerkleTrie.sol\";\n\n/**\n * @title TestLib_MerkleTrie\n */\ncontract TestLib_MerkleTrie {\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bool) {\n        return Lib_MerkleTrie.verifyInclusionProof(_key, _value, _proof, _root);\n    }\n\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bool, bytes memory) {\n        return Lib_MerkleTrie.get(_key, _proof, _root);\n    }\n}\n"
    },
    "contracts/test-libraries/trie/TestLib_SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_SecureMerkleTrie } from \"../../libraries/trie/Lib_SecureMerkleTrie.sol\";\n\n/**\n * @title TestLib_SecureMerkleTrie\n */\ncontract TestLib_SecureMerkleTrie {\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bool) {\n        return Lib_SecureMerkleTrie.verifyInclusionProof(_key, _value, _proof, _root);\n    }\n\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bool, bytes memory) {\n        return Lib_SecureMerkleTrie.get(_key, _proof, _root);\n    }\n}\n"
    },
    "contracts/test-libraries/rlp/TestLib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_RLPReader } from \"../../libraries/rlp/Lib_RLPReader.sol\";\n\n/**\n * @title TestLib_RLPReader\n */\ncontract TestLib_RLPReader {\n    function readList(bytes memory _in) public pure returns (bytes[] memory) {\n        Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_in);\n        bytes[] memory out = new bytes[](decoded.length);\n        for (uint256 i = 0; i < out.length; i++) {\n            out[i] = Lib_RLPReader.readRawBytes(decoded[i]);\n        }\n        return out;\n    }\n\n    function readString(bytes memory _in) public pure returns (string memory) {\n        return Lib_RLPReader.readString(_in);\n    }\n\n    function readBytes(bytes memory _in) public pure returns (bytes memory) {\n        return Lib_RLPReader.readBytes(_in);\n    }\n\n    function readBytes32(bytes memory _in) public pure returns (bytes32) {\n        return Lib_RLPReader.readBytes32(_in);\n    }\n\n    function readUint256(bytes memory _in) public pure returns (uint256) {\n        return Lib_RLPReader.readUint256(_in);\n    }\n\n    function readBool(bytes memory _in) public pure returns (bool) {\n        return Lib_RLPReader.readBool(_in);\n    }\n\n    function readAddress(bytes memory _in) public pure returns (address) {\n        return Lib_RLPReader.readAddress(_in);\n    }\n}\n"
    },
    "contracts/libraries/resolver/Lib_ResolvedDelegateProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_AddressManager } from \"./Lib_AddressManager.sol\";\n\n/**\n * @title Lib_ResolvedDelegateProxy\n */\ncontract Lib_ResolvedDelegateProxy {\n    /*************\n     * Variables *\n     *************/\n\n    // Using mappings to store fields to avoid overwriting storage slots in the\n    // implementation contract. For example, instead of storing these fields at\n    // storage slot `0` & `1`, they are stored at `keccak256(key + slot)`.\n    // See: https://solidity.readthedocs.io/en/v0.7.0/internals/layout_in_storage.html\n    // NOTE: Do not use this code in your own contract system.\n    //      There is a known flaw in this contract, and we will remove it from the repository\n    //      in the near future. Due to the very limited way that we are using it, this flaw is\n    //      not an issue in our system.\n    mapping(address => string) private implementationName;\n    mapping(address => Lib_AddressManager) private addressManager;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Lib_AddressManager.\n     * @param _implementationName implementationName of the contract to proxy to.\n     */\n    constructor(address _libAddressManager, string memory _implementationName) {\n        addressManager[address(this)] = Lib_AddressManager(_libAddressManager);\n        implementationName[address(this)] = _implementationName;\n    }\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback() external payable {\n        address target = addressManager[address(this)].getAddress(\n            (implementationName[address(this)])\n        );\n\n        require(target != address(0), \"Target address must be initialized.\");\n\n        // slither-disable-next-line controlled-delegatecall\n        (bool success, bytes memory returndata) = target.delegatecall(msg.data);\n\n        if (success == true) {\n            assembly {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n"
    },
    "contracts/L1/verification/BondManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { IBondManager } from \"./IBondManager.sol\";\n\n/* Contract Imports */\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\n\n/**\n * @title BondManager\n * @dev This contract is, for now, a stub of the \"real\" BondManager that does nothing but\n * allow the \"BVM_Proposer\" to submit state root batches.\n *\n */\ncontract BondManager is IBondManager, Lib_AddressResolver {\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    constructor(address _libAddressManager) Lib_AddressResolver(_libAddressManager) {}\n\n    /**\n     * Checks whether a given address is properly collateralized and can perform actions within\n     * the system.\n     * @param _who Address to check.\n     * @return true if the address is properly collateralized, false otherwise.\n     */\n    // slither-disable-next-line external-function\n    function isCollateralized(address _who) public view returns (bool) {\n        // Only authenticate sequencer to submit state root batches.\n        return _who == resolve(\"BVM_Proposer\");\n    }\n}\n"
    },
    "contracts/L1/verification/IBondManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title IBondManager\n */\ninterface IBondManager {\n    /********************\n     * Public Functions *\n     ********************/\n\n    function isCollateralized(address _who) external view returns (bool);\n}\n"
    },
    "contracts/L1/rollup/StateCommitmentChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport {Lib_BVMCodec} from \"../../libraries/codec/Lib_BVMCodec.sol\";\nimport {Lib_AddressResolver} from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport {Lib_MerkleTree} from \"../../libraries/utils/Lib_MerkleTree.sol\";\nimport {CrossDomainEnabled} from \"../../libraries/bridge/CrossDomainEnabled.sol\";\n\n/* Interface Imports */\nimport {IStateCommitmentChain} from \"./IStateCommitmentChain.sol\";\nimport {ICanonicalTransactionChain} from \"./ICanonicalTransactionChain.sol\";\nimport {IBondManager} from \"../verification/IBondManager.sol\";\nimport {IChainStorageContainer} from \"./IChainStorageContainer.sol\";\nimport {ITssGroupManager} from \"../tss/ITssGroupManager.sol\";\nimport {ITssRewardContract} from \"../../L2/predeploys/iTssRewardContract.sol\";\n\n/**\n * @title StateCommitmentChain\n * @dev The State Commitment Chain (SCC) contract contains a list of proposed state roots which\n * Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC).\n * Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique\n * state root calculated off-chain by applying the canonical transactions one by one.\n *\n */\ncontract StateCommitmentChain is IStateCommitmentChain, Lib_AddressResolver, CrossDomainEnabled {\n    /*************\n     * Constants *\n     *************/\n\n    uint256 public FRAUD_PROOF_WINDOW;\n    uint256 public SEQUENCER_PUBLISH_WINDOW;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    constructor(\n        address _libAddressManager,\n        address _l1messenger,\n        uint256 _fraudProofWindow,\n        uint256 _sequencerPublishWindow\n    ) Lib_AddressResolver(_libAddressManager) CrossDomainEnabled(address(0)) {\n        messenger = _l1messenger;\n        FRAUD_PROOF_WINDOW = _fraudProofWindow;\n        SEQUENCER_PUBLISH_WINDOW = _sequencerPublishWindow;\n    }\n\n    function setFraudProofWindow(uint256 _fraudProofWindow) public {\n        require(msg.sender == libAddressManager.owner(), \"Only callable by the libAddressManager owner.\");\n        FRAUD_PROOF_WINDOW = _fraudProofWindow;\n    }\n\n    function getFraudProofWindow() public view returns (uint256 _fraudProofWindow) {\n        return uint256(FRAUD_PROOF_WINDOW);\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches() public view returns (IChainStorageContainer) {\n        return IChainStorageContainer(resolve(\"ChainStorageContainer-SCC-batches\"));\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    function getTotalElements() public view returns (uint256 _totalElements) {\n        (uint40 totalElements,) = _getBatchExtraData();\n        return uint256(totalElements);\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    function getTotalBatches() public view returns (uint256 _totalBatches) {\n        return batches().length();\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    // slither-disable-next-line external-function\n    function getLastSequencerTimestamp() public view returns (uint256 _lastSequencerTimestamp) {\n        (, uint40 lastSequencerTimestamp) = _getBatchExtraData();\n        return uint256(lastSequencerTimestamp);\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    // slither-disable-next-line external-function\n    function appendStateBatch(bytes32[] memory _batch, uint256 _shouldStartAtElement, bytes memory _signature) public {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            IBondManager(resolve(\"BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        require(_batch.length > 0, \"Cannot submit an empty state batch.\");\n\n        require(\n            getTotalElements() + _batch.length <=\n            ICanonicalTransactionChain(resolve(\"CanonicalTransactionChain\")).getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );\n\n        // Call tss group register contract to verify the signature\n        _checkClusterSignature(_batch, _shouldStartAtElement, _signature);\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\n        _appendBatch(_batch, _signature, abi.encode(block.timestamp, msg.sender));\n\n        // Update distributed state batch, and emit message\n        _distributeTssReward(_batch.length, _shouldStartAtElement);\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    // slither-disable-next-line external-function\n    function deleteStateBatch(Lib_BVMCodec.ChainBatchHeader memory _batchHeader) public {\n        require(\n            msg.sender == resolve(\"BVM_FraudVerifier\"),\n            \"State batches can only be deleted by the BVM_FraudVerifier.\"\n        );\n\n        require(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");\n\n        require(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );\n\n        _deleteBatch(_batchHeader);\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    // slither-disable-next-line external-function\n    function verifyStateCommitment(\n        bytes32 _element,\n        Lib_BVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_BVMCodec.ChainInclusionProof memory _proof\n    ) public view returns (bool) {\n        require(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");\n\n        require(\n            Lib_MerkleTree.verify(\n                _batchHeader.batchRoot,\n                _element,\n                _proof.index,\n                _proof.siblings,\n                _batchHeader.batchSize\n            ),\n            \"Invalid inclusion proof.\"\n        );\n\n        return true;\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    function insideFraudProofWindow(Lib_BVMCodec.ChainBatchHeader memory _batchHeader)\n    public\n    view\n    returns (bool _inside)\n    {\n        (uint256 timestamp,) = abi.decode(_batchHeader.extraData, (uint256, address));\n\n        require(timestamp != 0, \"Batch header timestamp cannot be zero\");\n        return (timestamp + FRAUD_PROOF_WINDOW) > block.timestamp;\n    }\n\n    /**\n    * @inheritdoc IStateCommitmentChain\n     */\n    // slither-disable-next-line external-function\n    function rollBackL2Chain(uint256 _shouldRollBack, uint256 _shouldStartAtElement, bytes memory _signature) public {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            IBondManager(resolve(\"BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        _checkRollBackSignature(_shouldRollBack,_signature);\n\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Parses the batch context from the extra data.\n     * @return Total number of elements submitted.\n     * @return Timestamp of the last batch submitted by the sequencer.\n     */\n    function _getBatchExtraData() internal view returns (uint40, uint40) {\n        bytes27 extraData = batches().getGlobalMetadata();\n\n        // solhint-disable max-line-length\n        uint40 totalElements;\n        uint40 lastSequencerTimestamp;\n        assembly {\n            extraData := shr(40, extraData)\n            totalElements := and(\n            extraData,\n            0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\n            )\n            lastSequencerTimestamp := shr(\n            40,\n            and(extraData, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000)\n            )\n        }\n        // solhint-enable max-line-length\n\n        return (totalElements, lastSequencerTimestamp);\n    }\n\n    /**\n     * Encodes the batch context for the extra data.\n     * @param _totalElements Total number of elements submitted.\n     * @param _lastSequencerTimestamp Timestamp of the last batch submitted by the sequencer.\n     * @return Encoded batch context.\n     */\n    function _makeBatchExtraData(uint40 _totalElements, uint40 _lastSequencerTimestamp)\n    internal\n    pure\n    returns (bytes27)\n    {\n        bytes27 extraData;\n        assembly {\n            extraData := _totalElements\n            extraData := or(extraData, shl(40, _lastSequencerTimestamp))\n            extraData := shl(40, extraData)\n        }\n\n        return extraData;\n    }\n\n    /**\n     * Appends a batch to the chain.\n     * @param _batch Elements within the batch.\n     * @param _shouldStartAtElement Relative rollup block height.\n     * @param _signature Signature of batch roots and rollup start height.\n     */\n    function _checkClusterSignature(bytes32[] memory _batch, uint256 _shouldStartAtElement, bytes memory _signature)\n    internal\n    {\n        // abi hash encode to bytes\n        require(\n            ITssGroupManager(resolve(\"Proxy__TSS_GroupManager\")).verifySign(\n                keccak256(abi.encode(_batch, _shouldStartAtElement)), _signature),\n            \"verify signature failed\"\n        );\n    }\n\n    /**\n     * Appends a batch to the chain.\n     * @param _batch Elements within the batch.\n     * @param _extraData Any extra data to append to the batch.\n     */\n    function _appendBatch(bytes32[] memory _batch, bytes memory _signature, bytes memory _extraData) internal {\n        address sequencer = resolve(\"BVM_Proposer\");\n        (uint40 totalElements, uint40 lastSequencerTimestamp) = _getBatchExtraData();\n\n        if (msg.sender == sequencer) {\n            lastSequencerTimestamp = uint40(block.timestamp);\n        } else {\n            // We keep track of the last batch submitted by the sequencer so there's a window in\n            // which only the sequencer can publish state roots. A window like this just reduces\n            // the chance of \"system breaking\" state roots being published while we're still in\n            // testing mode. This window should be removed or significantly reduced in the future.\n            require(\n                lastSequencerTimestamp + SEQUENCER_PUBLISH_WINDOW < block.timestamp,\n                \"Cannot publish state roots within the sequencer publication window.\"\n            );\n        }\n        // For efficiency reasons getMerkleRoot modifies the `_batch` argument in place\n        // while calculating the root hash therefore any arguments passed to it must not\n        // be used again afterwards\n        Lib_BVMCodec.ChainBatchHeader memory batchHeader = Lib_BVMCodec.ChainBatchHeader({\n            batchIndex : getTotalBatches(),\n            batchRoot : Lib_MerkleTree.getMerkleRoot(_batch),\n            batchSize : _batch.length,\n            prevTotalElements : totalElements,\n            signature : _signature,\n            extraData : _extraData\n        });\n\n        emit StateBatchAppended(\n            batchHeader.batchIndex,\n            batchHeader.batchRoot,\n            batchHeader.batchSize,\n            batchHeader.prevTotalElements,\n            batchHeader.signature,\n            batchHeader.extraData\n        );\n\n        batches().push(\n            Lib_BVMCodec.hashBatchHeader(batchHeader),\n            _makeBatchExtraData(\n                uint40(batchHeader.prevTotalElements + batchHeader.batchSize),\n                lastSequencerTimestamp\n            )\n        );\n    }\n\n    /**\n     * Removes a batch and all subsequent batches from the chain.\n     * @param _batchHeader Header of the batch to remove.\n     */\n    function _deleteBatch(Lib_BVMCodec.ChainBatchHeader memory _batchHeader) internal {\n        require(_batchHeader.batchIndex < batches().length(), \"Invalid batch index.\");\n\n        require(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");\n\n        // slither-disable-next-line reentrancy-events\n        batches().deleteElementsAfterInclusive(\n            _batchHeader.batchIndex,\n            _makeBatchExtraData(uint40(_batchHeader.prevTotalElements), 0)\n        );\n\n        // slither-disable-next-line reentrancy-events\n        emit StateBatchDeleted(_batchHeader.batchIndex, _batchHeader.batchRoot);\n    }\n\n    /**\n     * Distribute Reward to tss node.\n     * @param _batch_length rollup batch.\n     * @param  _shouldStartAtElement.\n     */\n    function _distributeTssReward(uint256 _batch_length, uint256 _shouldStartAtElement) internal {\n        // get address of tss group member\n        address[] memory tssMembers = ITssGroupManager(resolve(\"Proxy__TSS_GroupManager\")).getTssGroupUnJailMembers();\n        require(tssMembers.length > 0, \"get tss members in error\");\n\n        // construct calldata for claimReward call\n        bytes memory message = abi.encodeWithSelector(\n            ITssRewardContract.claimReward.selector,\n            _shouldStartAtElement,\n            _batch_length,\n            block.timestamp,\n            tssMembers\n        );\n\n        // send call data into L2, hardcode address\n        sendCrossDomainMessage(\n            address(0x4200000000000000000000000000000000000020),\n            2000000,\n            message\n        );\n\n        // emit message\n        emit DistributeTssReward(\n            _shouldStartAtElement,\n            _batch_length,\n            block.timestamp,\n            tssMembers\n        );\n    }\n\n    /**\n     * Checks that a batch header matches the stored hash for the given index.\n     * @param _batchHeader Batch header to validate.\n     * @return Whether or not the header matches the stored one.\n     */\n    function _isValidBatchHeader(Lib_BVMCodec.ChainBatchHeader memory _batchHeader)\n    internal\n    view\n    returns (bool)\n    {\n        return Lib_BVMCodec.hashBatchHeader(_batchHeader) == batches().get(_batchHeader.batchIndex);\n    }\n\n\n    /**\n     * roll back l2 chain to should start block number.\n     * @param _shouldRollBack roll back number.\n     * @param _signature Signature of roll back number.\n     */\n    function _checkRollBackSignature(uint256 _shouldRollBack, bytes memory _signature)\n    internal\n    {\n        // abi hash encode to bytes\n        require(\n            ITssGroupManager(resolve(\"Proxy__TSS_GroupManager\")).verifySign(\n                keccak256(abi.encode(_shouldRollBack)), _signature),\n            \"verify signature failed\"\n        );\n\n\n        bytes memory message = abi.encodeWithSignature(\n            \"rollBackMessage(uint256)\",\n            _shouldRollBack\n        );\n\n        // send call data into L2, hardcode address\n        sendCrossDomainMessage(\n            address(0xDeADdeaDdEaDdeADdEaDDeADDEaddEaDDEad2222),\n            2000000,\n            message\n        );\n\n        //emit roll back l2chain from block number\n        emit RollBackL2Chain(_shouldRollBack);\n    }\n}\n"
    },
    "contracts/libraries/utils/Lib_MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_MerkleTree\n * @author River Keefer\n */\nlibrary Lib_MerkleTree {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\n     * If you do not know the original length of elements for the tree you are verifying, then\n     * this may allow empty leaves past _elements.length to pass a verification check down the line.\n     * Note that the _elements argument is modified, therefore it must not be used again afterwards\n     * @param _elements Array of hashes from which to generate a merkle root.\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\n     */\n    function getMerkleRoot(bytes32[] memory _elements) internal pure returns (bytes32) {\n        require(_elements.length > 0, \"Lib_MerkleTree: Must provide at least one leaf hash.\");\n\n        if (_elements.length == 1) {\n            return _elements[0];\n        }\n\n        uint256[16] memory defaults = [\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\n        ];\n\n        // Reserve memory space for our hashes.\n        bytes memory buf = new bytes(64);\n\n        // We'll need to keep track of left and right siblings.\n        bytes32 leftSibling;\n        bytes32 rightSibling;\n\n        // Number of non-empty nodes at the current depth.\n        uint256 rowSize = _elements.length;\n\n        // Current depth, counting from 0 at the leaves\n        uint256 depth = 0;\n\n        // Common sub-expressions\n        uint256 halfRowSize; // rowSize / 2\n        bool rowSizeIsOdd; // rowSize % 2 == 1\n\n        while (rowSize > 1) {\n            halfRowSize = rowSize / 2;\n            rowSizeIsOdd = rowSize % 2 == 1;\n\n            for (uint256 i = 0; i < halfRowSize; i++) {\n                leftSibling = _elements[(2 * i)];\n                rightSibling = _elements[(2 * i) + 1];\n                assembly {\n                    mstore(add(buf, 32), leftSibling)\n                    mstore(add(buf, 64), rightSibling)\n                }\n\n                _elements[i] = keccak256(buf);\n            }\n\n            if (rowSizeIsOdd) {\n                leftSibling = _elements[rowSize - 1];\n                rightSibling = bytes32(defaults[depth]);\n                assembly {\n                    mstore(add(buf, 32), leftSibling)\n                    mstore(add(buf, 64), rightSibling)\n                }\n\n                _elements[halfRowSize] = keccak256(buf);\n            }\n\n            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\n            depth++;\n        }\n\n        return _elements[0];\n    }\n\n    /**\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\n     * of leaves generated is a known, correct input, and does not return true for indices\n     * extending past that index (even if _siblings would be otherwise valid.)\n     * @param _root The Merkle root to verify against.\n     * @param _leaf The leaf hash to verify inclusion of.\n     * @param _index The index in the tree of this leaf.\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0\n     * (bottom of the tree).\n     * @param _totalLeaves The total number of leaves originally passed into.\n     * @return Whether or not the merkle branch and leaf passes verification.\n     */\n    function verify(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32[] memory _siblings,\n        uint256 _totalLeaves\n    ) internal pure returns (bool) {\n        require(_totalLeaves > 0, \"Lib_MerkleTree: Total leaves must be greater than zero.\");\n\n        require(_index < _totalLeaves, \"Lib_MerkleTree: Index out of bounds.\");\n\n        require(\n            _siblings.length == _ceilLog2(_totalLeaves),\n            \"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\"\n        );\n\n        bytes32 computedRoot = _leaf;\n\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            if ((_index & 1) == 1) {\n                computedRoot = keccak256(abi.encodePacked(_siblings[i], computedRoot));\n            } else {\n                computedRoot = keccak256(abi.encodePacked(computedRoot, _siblings[i]));\n            }\n\n            _index >>= 1;\n        }\n\n        return _root == computedRoot;\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Calculates the integer ceiling of the log base 2 of an input.\n     * @param _in Unsigned input to calculate the log.\n     * @return ceil(log_base_2(_in))\n     */\n    function _ceilLog2(uint256 _in) private pure returns (uint256) {\n        require(_in > 0, \"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\");\n\n        if (_in == 1) {\n            return 0;\n        }\n\n        // Find the highest set bit (will be floor(log_2)).\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\n        uint256 val = _in;\n        uint256 highest = 0;\n        for (uint256 i = 128; i >= 1; i >>= 1) {\n            if (val & (((uint256(1) << i) - 1) << i) != 0) {\n                highest += i;\n                val >>= i;\n            }\n        }\n\n        // Increment by one if this is not a perfect logarithm.\n        if ((uint256(1) << highest) != _in) {\n            highest += 1;\n        }\n\n        return highest;\n    }\n}\n"
    },
    "contracts/L2/predeploys/TssRewardContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {ITssRewardContract} from  \"./iTssRewardContract.sol\";\nimport {IBVM_GasPriceOracle} from \"./iBVM_GasPriceOracle.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Lib_PredeployAddresses} from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\nimport { CrossDomainEnabled } from \"../../libraries/bridge/CrossDomainEnabled.sol\";\n\n/* Library Imports */\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/* Interface Imports */\n\n/* External Imports */\n\n/**\n * @title TssRewardContract\n * @dev Release to batch roll up tss members.\n */\ncontract TssRewardContract is Ownable,ITssRewardContract,CrossDomainEnabled,ReentrancyGuardUpgradeable {\n    using SafeMath for uint256;\n\n    uint256 public lastBatchTime;\n    uint256 public sendAmountPerYear;\n\n    address public sccAddress;\n    uint256 public waitingTime;\n    // operator => tssreward\n    mapping(address => uint256) public rewardDetails;\n    //operator => claimer\n    mapping(address => address) public operators;\n    //claimer => operator\n    mapping(address => address) public claimers;\n    //operator => timestamp\n    mapping(address => uint256) public claimTimes;\n    //operator => claim number\n    mapping(address => uint256) public claimAmout;\n    address public stakeSlashAddress;\n\n\n    // set call address\n    constructor(address _owner, uint256 _sendAmountPerYear,address _l2CrossDomainMessenger, address _sccAddress, uint256 _waitingTime, address _ssAddr)\n    Ownable() CrossDomainEnabled(_l2CrossDomainMessenger)\n    {\n        transferOwnership(_owner);\n        sendAmountPerYear = _sendAmountPerYear;\n        sccAddress = _sccAddress;\n        waitingTime = _waitingTime;\n        stakeSlashAddress = _sccAddress;\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {}\n\n    modifier onlyAuthorized() {\n        address operator = claimers[msg.sender];\n        require(operator != address(0),\n        \"The msg sender is not authorized by the validator\"\n        );\n        _;\n    }\n\n    function setSendAmountPerYear(uint256 _sendAmountPerYear) public onlyOwner {\n        sendAmountPerYear = _sendAmountPerYear;\n    }\n\n    function setWaitingTime(uint256 _waitingTime) public onlyOwner {\n        waitingTime = _waitingTime;\n    }\n\n    function setSccAddr(address _sccAddress) public onlyOwner {\n        sccAddress = _sccAddress;\n    }\n\n    function setStakeSlashAddr(address _ssAddre) public onlyOwner {\n        stakeSlashAddress = _ssAddre;\n    }\n\n    function querySendAmountPerSecond() public view returns (uint256){\n        return (sendAmountPerYear * 10 ** 18).div(365 * 24 * 60 * 60);\n    }\n\n    /**\n     * @dev return the total undistributed amount\n     */\n    function queryReward() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev claimReward distribute reward to tss member.\n     * @param _blockStartHeight L2 rollup batch block start height.\n     * @param _batchTime Batch corresponds to L1 Block Timestamp\n     * @param _length The distribute batch block number\n     * @param _tssMembers The address array of tss group members\n     */\n    function claimReward(uint256 _blockStartHeight, uint32 _length, uint256 _batchTime, address[] calldata _tssMembers)\n    external\n    virtual\n    onlyFromCrossDomainAccount(sccAddress)\n    {\n        uint256 batchAmount = 0;\n        // sendAmount\n        if (lastBatchTime == 0) {\n            lastBatchTime = _batchTime;\n            return;\n        }\n        require(_batchTime > lastBatchTime,\"args _batchTime must gther than last lastBatchTime\");\n        batchAmount = (_batchTime - lastBatchTime) * querySendAmountPerSecond();\n        _distributeReward(batchAmount, _tssMembers);\n        emit DistributeTssReward(\n            lastBatchTime,\n            _batchTime,\n            batchAmount,\n            _tssMembers\n        );\n        lastBatchTime = _batchTime;\n    }\n\n    /**\n     * @dev clear balance\n     */\n    function withdraw() external onlyOwner {\n        if (address(this).balance > 0) {\n            (bool success, ) = owner().call{ value: address(this).balance }(new bytes(0));\n            require(success, \"TssReward withdraw: MNT transfer failed\");\n        }\n    }\n\n    function requestClaim() external onlyAuthorized returns (bool) {\n        address operator = claimers[msg.sender];\n        uint256 time = claimTimes[operator];\n        require(time == 0,\n        \"You have already initiated a request to claim, please wait for the waiting period to pass\"\n        );\n        claimTimes[operator] = block.timestamp;\n        claimAmout[operator] = rewardDetails[operator];\n        return true;\n    }\n\n    function queryClaimTime() external view returns (uint256) {\n        address operator = claimers[msg.sender];\n        uint256 remainTime = _remainTime(operator);\n        return remainTime;\n    }\n\n    /**\n     * @dev Claim reward\n     */\n    function claim() external onlyAuthorized nonReentrant {\n        address operator = claimers[msg.sender];\n        uint256 remainTime = _remainTime(operator);\n        require(remainTime == 0,\n        \"please wait for the waiting period to pass\"\n        );\n        _claim(operator);\n        delete claimTimes[operator];\n    }\n\n    function setClaimer(address _operator, address _claimer)\n    external\n    virtual\n    onlyFromCrossDomainAccount(stakeSlashAddress)\n    {\n        if (operators[_operator] != address(0)) {\n            delete claimers[operators[_operator]];\n        }\n        claimers[_claimer] = _operator;\n        operators[_operator] = _claimer;\n    }\n\n    function _remainTime(address operator) internal view returns (uint256) {\n        uint256 time = claimTimes[operator];\n        require(time != 0,\n        \"please initiate a request to claim first\"\n        );\n        uint256 last = time + waitingTime;\n        uint256 remaining;\n        if ( last > block.timestamp ) {\n            remaining = last - block.timestamp;\n        }else {\n            remaining = 0;\n        }\n        return remaining;\n    }\n\n\n    function _claim(address _operator) internal {\n        uint256 claimNumber = claimAmout[_operator];\n        uint256 amount = rewardDetails[_operator];\n        require(amount >= claimNumber,\"The numerical value is incorrect\");\n        require(address(this).balance >= claimNumber,\"The contract balance is insufficient to pay the reward value\");\n        if (claimNumber > 0) {\n            address claimer = operators[_operator];\n            delete claimAmout[_operator];\n            rewardDetails[_operator] = rewardDetails[_operator] - claimNumber;\n            (bool success, ) = claimer.call{ value: claimNumber }(new bytes(0));\n            require(success, \"TssReward claim: MNT transfer failed\");\n            emit Claim(_operator, claimNumber);\n        }\n    }\n\n\n    function _distributeReward(uint256 amount, address[] calldata _tssMembers) internal {\n        if (amount > 0) {\n            for (uint i = 0; i < _tssMembers.length; i++) {\n                address operator = _tssMembers[i];\n                rewardDetails[operator] += amount;\n            }\n        }\n    }\n\n}\n"
    },
    "contracts/L2/predeploys/iBVM_GasPriceOracle.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IBVM_GasPriceOracle {\n    function IsBurning()external view returns(uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/test-helpers/L1StandardBridgeUpgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { IL1StandardBridge } from \"../L1/messaging/IL1StandardBridge.sol\";\nimport { IL1ERC20Bridge } from \"../L1/messaging/IL1ERC20Bridge.sol\";\nimport { IL2ERC20Bridge } from \"../L2/messaging/IL2ERC20Bridge.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* Library Imports */\nimport { CrossDomainEnabled } from \"../libraries/bridge/CrossDomainEnabled.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/constants/Lib_PredeployAddresses.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title L1StandardBridge\n * @dev The L1 ETH and ERC20 Bridge is a contract which stores deposited L1 funds and standard\n * tokens that are in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\n * and listening to it for newly finalized withdrawals.\n *\n */\ncontract L1StandardBridgeUpgrade is IL1StandardBridge, CrossDomainEnabled {\n    using SafeERC20 for IERC20;\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    address public l2TokenBridge;\n    address public l1MantleAddress;\n\n    // Maps L1 token to L2 token to balance of the L1 token deposited\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    // This contract lives behind a proxy, so the constructor parameters will go unused.\n    constructor() CrossDomainEnabled(address(0)) {}\n\n    function getVersion() public pure returns (int32) {\n        return 2;\n    }\n\n    /******************\n     * Initialization *\n     ******************/\n\n    /**\n     * @param _l1messenger L1 Messenger address being used for cross-chain communications.\n     * @param _l2TokenBridge L2 standard bridge address.\n     * @param _l1MantleAddress initialize L1 mantle address\n     */\n    // slither-disable-next-line external-function\n    function initialize(\n        address _l1messenger,\n        address _l2TokenBridge,\n        address _l1MantleAddress\n    ) public {\n        require(messenger == address(0), \"Contract has already been initialized.\");\n        messenger = _l1messenger;\n        l2TokenBridge = _l2TokenBridge;\n        l1MantleAddress = _l1MantleAddress;\n    }\n\n    /**************\n     * Depositing *\n     **************/\n\n    /** @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious\n     *  contract via initcode, but it takes care of the user error we want to avoid.\n     */\n    modifier onlyEOA() {\n        // Used to stop deposits from contracts (avoid accidentally lost tokens)\n        require(!Address.isContract(msg.sender), \"Account not EOA\");\n        _;\n    }\n\n    /**\n     * @dev This function can be called with no data\n     * to deposit an amount of ETH to the caller's balance on L2.\n     * Since the receive function doesn't take data, a conservative\n     * default amount is forwarded to L2.\n     */\n    receive() external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, 200_000, bytes(\"\"));\n    }\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, _l2Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable {\n        _initiateETHDeposit(msg.sender, _to, _l2Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by storing the ETH and informing the L2 ETH Gateway of\n     * the deposit.\n     * @param _from Account to pull the deposit from on L1.\n     * @param _to Account to give the deposit to on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateETHDeposit(\n        address _from,\n        address _to,\n        uint32 _l2Gas,\n        bytes memory _data\n    ) internal {\n        // Construct calldata for finalizeDeposit call\n        bytes memory message = abi.encodeWithSelector(\n            IL2ERC20Bridge.finalizeDeposit.selector,\n            address(0),\n            Lib_PredeployAddresses.BVM_ETH,\n            _from,\n            _to,\n            msg.value,\n            _data\n        );\n\n        // Send calldata into L2\n        // slither-disable-next-line reentrancy-events\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        // slither-disable-next-line reentrancy-events\n        emit ETHDepositInitiated(_from, _to, msg.value, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual onlyEOA {\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _l2Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual {\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _l2Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by informing the L2 Deposited Token\n     * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n     *\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) internal {\n        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future\n        // withdrawals. The use of safeTransferFrom enables support of \"broken tokens\" which do not\n        // return a boolean value.\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        uint256 expectedTransferBalance = IERC20(_l1Token).balanceOf(address(this)) + _amount;\n        IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);\n        uint256 postTransferBalance = IERC20(_l1Token).balanceOf(address(this));\n        require(expectedTransferBalance == postTransferBalance,\"Fee on transfer tokens not supported\");\n\n        // Construct calldata for _l2Token.finalizeDeposit(_to, _amount)\n        bytes memory message;\n        if (_l1Token == l1MantleAddress) {\n            // Construct calldata for finalizeDeposit call\n            _l2Token = Lib_PredeployAddresses.BVM_MANTLE;\n            message = abi.encodeWithSelector(\n                IL2ERC20Bridge.finalizeDeposit.selector,\n                address(0x3c3a81e81dc49A522A592e7622A7E711c06bf354),\n                Lib_PredeployAddresses.BVM_MANTLE,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        } else {\n            // Construct calldata for finalizeDeposit call\n            message = abi.encodeWithSelector(\n                IL2ERC20Bridge.finalizeDeposit.selector,\n                _l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        }\n\n        // Send calldata into L2\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        // slither-disable-next-line reentrancy-benign\n        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount;\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n        // slither-disable-next-line reentrancy-events\n        (bool success, ) = _to.call{ value: _amount }(new bytes(0));\n        require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\n\n        // slither-disable-next-line reentrancy-events\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function finalizeMantleWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n        finalizeERC20Withdrawal(\n            l1MantleAddress,\n            Lib_PredeployAddresses.BVM_MANTLE,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public onlyFromCrossDomainAccount(l2TokenBridge) {\n        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;\n\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the funds to the withdrawer\n        // slither-disable-next-line reentrancy-events\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*****************************\n     * Temporary - Migrating ETH *\n     *****************************/\n\n    /**\n     * @dev Adds ETH balance to the account. This is meant to allow for ETH\n     * to be migrated from an old gateway to a new gateway.\n     * NOTE: This is left for one upgrade only so we are able to receive the migrated ETH from the\n     * old contract\n     */\n    function donateETH() external payable {}\n}\n"
    },
    "contracts/L1/messaging/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\nimport \"./IL1ERC20Bridge.sol\";\n\n/**\n * @title IL1StandardBridge\n */\ninterface IL1StandardBridge is IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n    event ETHDepositInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHWithdrawalFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev Deposit an amount of the ETH to the caller's balance on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;\n\n    /**\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called\n     * before the withdrawal is finalized.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "contracts/L1/messaging/IL1ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IL1ERC20Bridge\n */\ninterface IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L2 bridge contract.\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external returns (address);\n\n    /**\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _amount Amount of the ERC20 to deposit\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ERC20 token.\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\n     *\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Data provided by the sender on L2. This data is provided\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\n     *   length, these contracts provide no guarantees about its content.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev Complete a mantle withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ERC20 token.\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\n     *\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Data provided by the sender on L2. This data is provided\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\n     *   length, these contracts provide no guarantees about its content.\n     */\n    function finalizeMantleWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n\n}\n"
    },
    "contracts/L2/messaging/IL2ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title IL2ERC20Bridge\n */\ninterface IL2ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event WithdrawalInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFailed(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L1 bridge contract.\n     * @return Address of the corresponding L1 bridge contract.\n     */\n    function l1TokenBridge() external returns (address);\n\n    /**\n     * @dev initiate a withdraw of some tokens to the caller's account on L1\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _amount Amount of the token to withdraw.\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev initiate a withdraw of some token to a recipient's account on L1.\n     * @param _l2Token Address of L2 token where withdrawal is initiated.\n     * @param _to L1 adress to credit the withdrawal to.\n     * @param _amount Amount of the token to withdraw.\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this\n     * L2 token. This call will fail if it did not originate from a corresponding deposit in\n     * L1StandardTokenBridge.\n     * @param _l1Token Address for the l1 token this is called with\n     * @param _l2Token Address for the l2 token this is called with\n     * @param _from Account to pull the deposit from on L2.\n     * @param _to Address to receive the withdrawal at\n     * @param _amount Amount of the token to withdraw\n     * @param _data Data provider by the sender on L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/chugsplash/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/L1/messaging/L1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { IL1StandardBridge } from \"./IL1StandardBridge.sol\";\nimport { IL1ERC20Bridge } from \"./IL1ERC20Bridge.sol\";\nimport { IL2ERC20Bridge } from \"../../L2/messaging/IL2ERC20Bridge.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* Library Imports */\nimport { CrossDomainEnabled } from \"../../libraries/bridge/CrossDomainEnabled.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title L1StandardBridge\n * @dev The L1 ETH and ERC20 Bridge is a contract which stores deposited L1 funds and standard\n * tokens that are in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\n * and listening to it for newly finalized withdrawals.\n *\n */\ncontract L1StandardBridge is IL1StandardBridge, CrossDomainEnabled {\n    using SafeERC20 for IERC20;\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    address public l2TokenBridge;\n    address public l1MantleAddress;\n\n    // Maps L1 token to L2 token to balance of the L1 token deposited\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    // This contract lives behind a proxy, so the constructor parameters will go unused.\n    constructor() CrossDomainEnabled(address(0)) {}\n\n    /******************\n     * Initialization *\n     ******************/\n\n    /**\n     * @param _l1messenger L1 Messenger address being used for cross-chain communications.\n     * @param _l2TokenBridge L2 standard bridge address.\n     * @param _l1MantleAddress initialize L1 mantle address\n     */\n    // slither-disable-next-line external-function\n    function initialize(address _l1messenger, address _l2TokenBridge, address _l1MantleAddress) public {\n        require(messenger == address(0), \"Contract has already been initialized.\");\n        messenger = _l1messenger;\n        l2TokenBridge = _l2TokenBridge;\n        l1MantleAddress = _l1MantleAddress;\n    }\n\n    /**************\n     * Depositing *\n     **************/\n\n    /** @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious\n     *  contract via initcode, but it takes care of the user error we want to avoid.\n     */\n    modifier onlyEOA() {\n        // Used to stop deposits from contracts (avoid accidentally lost tokens)\n        require(!Address.isContract(msg.sender), \"Account not EOA\");\n        require(tx.origin==msg.sender, \"msg.sender is not ts origin\");\n        _;\n    }\n\n    /**\n     * @dev This function can be called with no data\n     * to deposit an amount of ETH to the caller's balance on L2.\n     * Since the receive function doesn't take data, a conservative\n     * default amount is forwarded to L2.\n     */\n    receive() external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, 200_000, bytes(\"\"));\n    }\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, _l2Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable {\n        _initiateETHDeposit(msg.sender, _to, _l2Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by storing the ETH and informing the L2 ETH Gateway of\n     * the deposit.\n     * @param _from Account to pull the deposit from on L1.\n     * @param _to Account to give the deposit to on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateETHDeposit(\n        address _from,\n        address _to,\n        uint32 _l2Gas,\n        bytes memory _data\n    ) internal {\n        // Construct calldata for finalizeDeposit call\n        bytes memory message = abi.encodeWithSelector(\n            IL2ERC20Bridge.finalizeDeposit.selector,\n            address(0),\n            Lib_PredeployAddresses.BVM_ETH,\n            _from,\n            _to,\n            msg.value,\n            _data\n        );\n\n        // Send calldata into L2\n        // slither-disable-next-line reentrancy-events\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        // slither-disable-next-line reentrancy-events\n        emit ETHDepositInitiated(_from, _to, msg.value, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual onlyEOA {\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _l2Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual {\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _l2Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by informing the L2 Deposited Token\n     * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n     *\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) internal {\n        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future\n        // withdrawals. The use of safeTransferFrom enables support of \"broken tokens\" which do not\n        // return a boolean value.\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);\n\n        // Construct calldata for _l2Token.finalizeDeposit(_to, _amount)\n        bytes memory message;\n        if (_l1Token == l1MantleAddress) {\n            // Construct calldata for finalizeDeposit call\n            require(_l2Token == Lib_PredeployAddresses.BVM_MANTLE, \"Unmatched token pair\");\n            message = abi.encodeWithSelector(\n                IL2ERC20Bridge.finalizeDeposit.selector,\n                address(0x3c3a81e81dc49A522A592e7622A7E711c06bf354),\n                Lib_PredeployAddresses.BVM_MANTLE,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n\n        } else {\n            // Construct calldata for finalizeDeposit call\n            message = abi.encodeWithSelector(\n                IL2ERC20Bridge.finalizeDeposit.selector,\n                _l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        }\n\n\n        // Send calldata into L2\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        // slither-disable-next-line reentrancy-benign\n        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount;\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n        // slither-disable-next-line reentrancy-events\n        (bool success, ) = _to.call{ value: _amount }(new bytes(0));\n        require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\n\n        // slither-disable-next-line reentrancy-events\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function finalizeMantleWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n        finalizeERC20Withdrawal(l1MantleAddress, Lib_PredeployAddresses.BVM_MANTLE, _from, _to, _amount, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public onlyFromCrossDomainAccount(l2TokenBridge) {\n        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;\n\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the funds to the withdrawer\n        // slither-disable-next-line reentrancy-events\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*****************************\n     * Temporary - Migrating ETH *\n     *****************************/\n\n    /**\n     * @dev Adds ETH balance to the account. This is meant to allow for ETH\n     * to be migrated from an old gateway to a new gateway.\n     * NOTE: This is left for one upgrade only so we are able to receive the migrated ETH from the\n     * old contract\n     */\n    function donateETH() external payable {}\n}\n"
    },
    "contracts/L2/predeploys/BVM_SequencerFeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport {Lib_PredeployAddresses} from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/* Contract Imports */\nimport {L2StandardBridge} from \"../messaging/L2StandardBridge.sol\";\nimport {IBVM_GasPriceOracle} from \"./iBVM_GasPriceOracle.sol\";\n\n\n/**\n * @title BVM_SequencerFeeVault\n * @dev Simple holding contract for fees paid to the Sequencer. Likely to be replaced in the future\n * but \"good enough for now\".\n */\ncontract BVM_SequencerFeeVault is Ownable {\n    /*************\n     * Constants *\n     *************/\n\n\n    /*************\n     * Variables *\n     *************/\n\n    // Address on L1 that will hold the fees once withdrawn. Dynamically initialized within l2geth.\n    address public l1FeeWallet;\n\n    address public bvmGasPriceOracleAddress;\n\n    uint256 public constant L1Gas = 200_000;\n\n    address public burner;\n    // Minimum Mantle token balance that can be withdrawn in a single withdrawal.\n    uint256 public minWithdrawalAmount;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _l1FeeWallet Initial address for the L1 wallet that will hold fees once withdrawn.\n     * Currently HAS NO EFFECT in production because l2geth will mutate this storage slot during\n     * the genesis block. This is ONLY for testing purposes.\n     */\n    constructor(address _owner,address _l1FeeWallet, address _bvmGasPriceOracleAddress,address _burner,uint256 _minWithdrawalAmount)\n    Ownable()\n    {\n        transferOwnership(_owner);\n        l1FeeWallet = _l1FeeWallet;\n        bvmGasPriceOracleAddress = _bvmGasPriceOracleAddress;\n        burner = _burner;\n        minWithdrawalAmount = _minWithdrawalAmount;\n    }\n\n    /************\n     * Fallback *\n     ************/\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {}\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    // slither-disable-next-line external-function\n    function withdraw() public {\n        address to = l1FeeWallet;\n        if (IBVM_GasPriceOracle(bvmGasPriceOracleAddress).IsBurning() == 1) {\n            to = burner;\n            if (address(this).balance < minWithdrawalAmount * 1 ether) {\n                return;\n            }\n        } else {\n            require(\n                address(this).balance >= minWithdrawalAmount * 1 ether,\n            // solhint-disable-next-line max-line-length\n                \"BVM_SequencerFeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n            );\n        }\n\n        L2StandardBridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo(\n            Lib_PredeployAddresses.BVM_MANTLE,\n            to,\n            address(this).balance,\n            0,\n            bytes(\"\")\n        );\n    }\n\n    function setBurner(address _burner) public onlyOwner{\n        burner = _burner;\n    }\n\n    function setMinWithdrawalAmount(uint256 _minWithdrawalAmount) public onlyOwner{\n        minWithdrawalAmount = _minWithdrawalAmount;\n    }\n\n    function setL1FeeWallet(address _l1FeeWallet) public onlyOwner{\n        l1FeeWallet = _l1FeeWallet;\n    }\n}\n"
    },
    "contracts/L2/messaging/L2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { IL1StandardBridge } from \"../../L1/messaging/IL1StandardBridge.sol\";\nimport { IL1ERC20Bridge } from \"../../L1/messaging/IL1ERC20Bridge.sol\";\nimport { IL2ERC20Bridge } from \"./IL2ERC20Bridge.sol\";\n\n/* Library Imports */\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { CrossDomainEnabled } from \"../../libraries/bridge/CrossDomainEnabled.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { IL2StandardERC20 } from \"../../standards/IL2StandardERC20.sol\";\n\n/**\n * @title L2StandardBridge\n * @dev The L2 Standard bridge is a contract which works together with the L1 Standard bridge to\n * enable ETH and ERC20 transitions between L1 and L2.\n * This contract acts as a minter for new tokens when it hears about deposits into the L1 Standard\n * bridge.\n * This contract also acts as a burner of the tokens intended for withdrawal, informing the L1\n * bridge to release L1 funds.\n */\ncontract L2StandardBridge is IL2ERC20Bridge, CrossDomainEnabled {\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    address public l1TokenBridge;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _l2CrossDomainMessenger Cross-domain messenger used by this contract.\n     * @param _l1TokenBridge Address of the L1 bridge deployed to the main chain.\n     */\n    constructor(address _l2CrossDomainMessenger, address _l1TokenBridge)\n        CrossDomainEnabled(_l2CrossDomainMessenger)\n    {\n        l1TokenBridge = _l1TokenBridge;\n    }\n\n    /***************\n     * Withdrawing *\n     ***************/\n\n    /**\n     * @inheritdoc IL2ERC20Bridge\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external virtual {\n        _initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _l1Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL2ERC20Bridge\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external virtual {\n        _initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _l1Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for withdrawals by burning the token and informing\n     *      the L1 token Gateway of the withdrawal.\n     * @param _l2Token Address of L2 token where withdrawal is initiated.\n     * @param _from Account to pull the withdrawal from on L2.\n     * @param _to Account to give the withdrawal to on L1.\n     * @param _amount Amount of the token to withdraw.\n     * @param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateWithdrawal(\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) internal {\n        // When a withdrawal is initiated, we burn the withdrawer's funds to prevent subsequent L2\n        // usage\n        // slither-disable-next-line reentrancy-events\n        IL2StandardERC20(_l2Token).burn(msg.sender, _amount);\n\n        // Construct calldata for l1TokenBridge.finalizeERC20Withdrawal(_to, _amount)\n        // slither-disable-next-line reentrancy-events\n        address l1Token = IL2StandardERC20(_l2Token).l1Token();\n        bytes memory message;\n\n        if (_l2Token == Lib_PredeployAddresses.BVM_ETH) {\n            message = abi.encodeWithSelector(\n                IL1StandardBridge.finalizeETHWithdrawal.selector,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        } else if (_l2Token == Lib_PredeployAddresses.BVM_MANTLE) {\n            message = abi.encodeWithSelector(\n                IL1ERC20Bridge.finalizeMantleWithdrawal.selector,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        } else {\n            message = abi.encodeWithSelector(\n                IL1ERC20Bridge.finalizeERC20Withdrawal.selector,\n                l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        }\n\n        // Send message up to L1 bridge\n        // slither-disable-next-line reentrancy-events\n        sendCrossDomainMessage(l1TokenBridge, _l1Gas, message);\n\n        // slither-disable-next-line reentrancy-events\n        emit WithdrawalInitiated(l1Token, _l2Token, msg.sender, _to, _amount, _data);\n    }\n\n    /************************************\n     * Cross-chain Function: Depositing *\n     ************************************/\n\n    /**\n     * @inheritdoc IL2ERC20Bridge\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external virtual onlyFromCrossDomainAccount(l1TokenBridge) {\n        // Check the target token is compliant and\n        // verify the deposited token on L1 matches the L2 deposited token representation here\n        if (\n            // slither-disable-next-line reentrancy-events\n            ERC165Checker.supportsInterface(_l2Token, 0x1d1d8b63) &&\n            _l1Token == IL2StandardERC20(_l2Token).l1Token()\n        ) {\n            // When a deposit is finalized, we credit the account on L2 with the same amount of\n            // tokens.\n            // slither-disable-next-line reentrancy-events\n            IL2StandardERC20(_l2Token).mint(_to, _amount);\n            // slither-disable-next-line reentrancy-events\n            emit DepositFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\n        } else {\n            // Either the L2 token which is being deposited-into disagrees about the correct address\n            // of its L1 token, or does not support the correct interface.\n            // This should only happen if there is a  malicious L2 token, or if a user somehow\n            // specified the wrong L2 token address to deposit into.\n            // In either case, we stop the process here and construct a withdrawal\n            // message so that users can get their funds out in some cases.\n            // There is no way to prevent malicious token contracts altogether, but this does limit\n            // user error and mitigate some forms of malicious contract behavior.\n            bytes memory message = abi.encodeWithSelector(\n                IL1ERC20Bridge.finalizeERC20Withdrawal.selector,\n                _l1Token,\n                _l2Token,\n                _to, // switched the _to and _from here to bounce back the deposit to the sender\n                _from,\n                _amount,\n                _data\n            );\n\n            // Send message up to L1 bridge\n            // slither-disable-next-line reentrancy-events\n            sendCrossDomainMessage(l1TokenBridge, 0, message);\n            // slither-disable-next-line reentrancy-events\n            emit DepositFailed(_l1Token, _l2Token, _from, _to, _amount, _data);\n        }\n    }\n}\n"
    },
    "contracts/standards/IL2StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IL2StandardERC20 is IERC20, IERC165 {\n    function l1Token() external returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "contracts/L2/predeploys/BVM_GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* External Imports */\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IBVM_GasPriceOracle } from \"./iBVM_GasPriceOracle.sol\";\n\n/**\n * @title BVM_GasPriceOracle\n * @dev This contract exposes the current l2 gas price, a measure of how congested the network\n * currently is. This measure is used by the Sequencer to determine what fee to charge for\n * transactions. When the system is more congested, the l2 gas price will increase and fees\n * will also increase as a result.\n *\n * All public variables are set while generating the initial L2 state. The\n * constructor doesn't run in practice as the L2 state generation script uses\n * the deployed bytecode instead of running the initcode.\n */\ncontract BVM_GasPriceOracle is Ownable,IBVM_GasPriceOracle {\n    /*************\n     * Variables *\n     *************/\n\n    // Current L2 gas price\n    uint256 public gasPrice;\n    // Current L1 base fee\n    uint256 public l1BaseFee;\n    // Amortized cost of batch submission per transaction\n    uint256 public overhead;\n    // Value to scale the fee up by\n    uint256 public scalar;\n    // Number of decimals of the scalar\n    uint256 public decimals;\n    // Switch controls whether GasFee is burn\n    uint256    isBurning;\n    // Switch controls whether charge L2 GasFee\n    uint256    public charge;\n    // sccAddress l1 sccAddress\n    address public sccAddress;\n    // daGasPrice da gas price\n    uint256  public daGasPrice;\n    // daSwitch Switch controls whether enable DA\n    uint256  public daSwitch;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _owner Address that will initially own this contract.\n     */\n    constructor(address _owner) Ownable() {\n        transferOwnership(_owner);\n    }\n\n    modifier checkValue(uint256 value) {\n        require(\n            value == 0 || value == 1,\n            \"invalid value,must be 0 or 1\"\n        );\n        _;\n    }\n\n    /**********\n     * Events *\n     **********/\n\n    event GasPriceUpdated(uint256);\n    event L1BaseFeeUpdated(uint256);\n    event DAGasPriceUpdated(uint256);\n    event OverheadUpdated(uint256);\n    event ScalarUpdated(uint256);\n    event DecimalsUpdated(uint256);\n    event IsBurningUpdated(uint256);\n    event ChargeUpdated(uint256);\n    event DASwitchUpdated(uint256);\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Allows the owner to modify the l2 gas price.\n     * @param _gasPrice New l2 gas price.\n     */\n    // slither-disable-next-line external-function\n    function setGasPrice(uint256 _gasPrice) public onlyOwner {\n        gasPrice = _gasPrice;\n        emit GasPriceUpdated(_gasPrice);\n    }\n\n    /**\n     * Allows the owner to modify the l1 base fee.\n     * @param _baseFee New l1 base fee\n     */\n    // slither-disable-next-line external-function\n    function setL1BaseFee(uint256 _baseFee) public onlyOwner {\n        l1BaseFee = _baseFee;\n        emit L1BaseFeeUpdated(_baseFee);\n    }\n\n    /**\n     * Allows the owner to modify the da gas price.\n     * @param _daGasPrice New da gas price\n     */\n    // slither-disable-next-line external-function\n    function setDAGasPrice(uint256 _daGasPrice) public onlyOwner {\n        daGasPrice = _daGasPrice;\n        emit DAGasPriceUpdated(_daGasPrice);\n    }\n\n    /**\n     * Allows the owner to modify the overhead.\n     * @param _overhead New overhead\n     */\n    // slither-disable-next-line external-function\n    function setOverhead(uint256 _overhead) public onlyOwner {\n        overhead = _overhead;\n        emit OverheadUpdated(_overhead);\n    }\n\n    /**\n     * Allows the owner to modify the scalar.\n     * @param _scalar New scalar\n     */\n    // slither-disable-next-line external-function\n    function setScalar(uint256 _scalar) public onlyOwner {\n        scalar = _scalar;\n        emit ScalarUpdated(_scalar);\n    }\n\n    /**\n     * Allows the owner to modify the decimals.\n     * @param _decimals New decimals\n     */\n    // slither-disable-next-line external-function\n    function setDecimals(uint256 _decimals) public onlyOwner {\n        decimals = _decimals;\n        emit DecimalsUpdated(_decimals);\n    }\n\n    /**\n * Allows the owner to modify the isBurning.\n * @param _isBurning New isBurning\n     */\n    // slither-disable-next-line external-function\n    function setIsBurning(uint256 _isBurning) public onlyOwner checkValue(_isBurning)  {\n        isBurning = _isBurning;\n        emit IsBurningUpdated(_isBurning);\n    }\n\n    function IsBurning() public view returns(uint256)  {\n        return isBurning;\n    }\n\n    function setCharge(uint256 _charge) public onlyOwner checkValue(_charge){\n        charge = _charge;\n        emit ChargeUpdated(_charge);\n    }\n\n    function setDaSwitch(uint256 _daSwitch) public onlyOwner checkValue(_daSwitch){\n        daSwitch = _daSwitch;\n        emit DASwitchUpdated(_daSwitch);\n    }\n\n    /**\n     * Computes the L1 portion of the fee\n     * based on the size of the RLP encoded tx\n     * and the current l1BaseFee\n     * @param _data Unsigned RLP encoded tx, 6 elements\n     * @return L1 fee that should be paid for the tx\n     */\n    // slither-disable-next-line external-function\n    function getL1Fee(bytes memory _data) public view returns (uint256) {\n        uint256 l1GasUsed = getL1GasUsed(_data);\n        uint256 l1Fee = l1GasUsed * l1BaseFee;\n        uint256 divisor = 10 ** decimals;\n        uint256 unscaled = l1Fee * scalar;\n        uint256 scaled = unscaled / divisor;\n        return scaled;\n    }\n\n    // solhint-disable max-line-length\n    /**\n     * Computes the amount of L1 gas used for a transaction\n     * The overhead represents the per batch gas overhead of\n     * posting both transaction and state roots to L1 given larger\n     * batch sizes.\n     * 4 gas for 0 byte\n     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L33\n     * 16 gas for non zero byte\n     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L87\n     * This will need to be updated if calldata gas prices change\n     * Account for the transaction being unsigned\n     * Padding is added to account for lack of signature on transaction\n     * 1 byte for RLP V prefix\n     * 1 byte for V\n     * 1 byte for RLP R prefix\n     * 32 bytes for R\n     * 1 byte for RLP S prefix\n     * 32 bytes for S\n     * Total: 68 bytes of padding\n     * @param _data Unsigned RLP encoded tx, 6 elements\n     * @return Amount of L1 gas used for a transaction\n     */\n    // solhint-enable max-line-length\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < _data.length; i++) {\n            if (_data[i] == 0) {\n                total += 4;\n            } else {\n                total += 16;\n            }\n        }\n        uint256 unsigned = total + overhead;\n        return unsigned + (68 * 16);\n    }\n}\n"
    },
    "contracts/L1/tss/delegation/TssDelegationSlasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../../delegation/DelegationSlasher.sol\";\n\n/**\n * @title The primary 'slashing' contract.\n * @notice This contract specifies details on slashing. The functionalities are:\n * - adding contracts who have permission to perform slashing,\n * - revoking permission for slashing from specified contracts,\n * - calling investManager to do actual slashing.\n */\ncontract TssDelegationSlasher is DelegationSlasher {\n    constructor(IDelegationManager _delegationManager, IDelegation _delegation)\n    DelegationSlasher(_delegationManager, _delegation)\n    {\n        _disableInitializers();\n    }\n}\n"
    },
    "contracts/standards/L2StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IL2StandardERC20.sol\";\n\ncontract L2StandardERC20 is IL2StandardERC20, ERC20 {\n    address public l1Token;\n    address public l2Bridge;\n    uint8 public decimal;\n\n    /**\n     * @param _l2Bridge Address of the L2 standard bridge.\n     * @param _l1Token Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    constructor(\n        address _l2Bridge,\n        address _l1Token,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) ERC20(_name, _symbol) {\n        l1Token = _l1Token;\n        l2Bridge = _l2Bridge;\n        decimal = _decimal;\n    }\n\n    modifier onlyL2Bridge() {\n        require(msg.sender == l2Bridge, \"Only L2 Bridge can mint and burn\");\n        _;\n    }\n\n    // slither-disable-next-line external-function\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\n        bytes4 firstSupportedInterface = bytes4(keccak256(\"supportsInterface(bytes4)\")); // ERC165\n        bytes4 secondSupportedInterface = IL2StandardERC20.l1Token.selector ^\n            IL2StandardERC20.mint.selector ^\n            IL2StandardERC20.burn.selector;\n        return _interfaceId == firstSupportedInterface || _interfaceId == secondSupportedInterface;\n    }\n\n    // slither-disable-next-line external-function\n    function mint(address _to, uint256 _amount) public virtual onlyL2Bridge {\n        _mint(_to, _amount);\n\n        emit Mint(_to, _amount);\n    }\n\n    // slither-disable-next-line external-function\n    function burn(address _from, uint256 _amount) public virtual onlyL2Bridge {\n        _burn(_from, _amount);\n\n        emit Burn(_from, _amount);\n    }\n\n    // slither-disable-next-line external-function\n    function decimals() public view virtual override returns (uint8) {\n        return decimal;\n    }\n\n}\n"
    },
    "contracts/L2/predeploys/BVM_MANTLE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { L2StandardERC20 } from \"../../standards/L2StandardERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n/**\n * @title BVM_MANTLE\n * @dev The ETH predeploy provides an ERC20 interface for ETH deposited to Layer 2. Note that\n * unlike on Layer 1, Layer 2 accounts do not have a balance field.\n */\ncontract BVM_MANTLE is L2StandardERC20 {\n    /***************\n     * Constructor *\n     ***************/\n    // hardcode to mantle token mainnet address\n    constructor()\n        L2StandardERC20(Lib_PredeployAddresses.L2_STANDARD_BRIDGE, address(0x3c3a81e81dc49A522A592e7622A7E711c06bf354), \"Mantle\", \"MNT\", 18)\n    {}\n\n\n    function transfer(address recipient, uint256 amount) public virtual override(IERC20) returns (bool) {\n        revert(\"BVM_MANTLE: transfer is disabled pending further community discussion.\");\n    }\n\n    function approve(address spender, uint256 amount) public virtual override(IERC20) returns (bool) {\n        revert(\"BVM_MANTLE: approve is disabled pending further community discussion.\");\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override(IERC20) returns (bool) {\n        revert(\"BVM_MANTLE: transferFrom is disabled pending further community discussion.\");\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        revert(\"BVM_MANTLE: increaseAllowance is disabled pending further community discussion.\");\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        revert(\"BVM_MANTLE: decreaseAllowance is disabled pending further community discussion.\");\n    }\n}\n"
    },
    "contracts/L2/predeploys/BVM_ETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { L2StandardERC20 } from \"../../standards/L2StandardERC20.sol\";\n\n/**\n * @title BVM_ETH\n * @dev The ETH predeploy provides an ERC20 interface for ETH deposited to Layer 2. Note that\n * unlike on Layer 1, Layer 2 accounts do not have a balance field.\n */\ncontract BVM_ETH is L2StandardERC20 {\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor()\n        L2StandardERC20(Lib_PredeployAddresses.L2_STANDARD_BRIDGE, address(0), \"Ether\", \"WETH\", 18)\n    {}\n}\n"
    },
    "contracts/L2/messaging/L2StandardTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Contract Imports */\nimport { L2StandardERC20 } from \"../../standards/L2StandardERC20.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/**\n * @title L2StandardTokenFactory\n * @dev Factory contract for creating standard L2 token representations of L1 ERC20s\n * compatible with and working on the standard bridge.\n */\ncontract L2StandardTokenFactory {\n    event StandardL2TokenCreated(address indexed _l1Token, address indexed _l2Token, uint8 decimal);\n\n    /**\n     * @dev Creates an instance of the standard ERC20 token on L2.\n     * @param _l1Token Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    function createStandardL2Token(\n        address _l1Token,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) external {\n        require(_l1Token != address(0), \"Must provide L1 token address\");\n\n        L2StandardERC20 l2Token = new L2StandardERC20(\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\n            _l1Token,\n            _name,\n            _symbol,\n            _decimal\n        );\n\n        emit StandardL2TokenCreated(_l1Token, address(l2Token), _decimal);\n    }\n}\n"
    },
    "contracts/L2/messaging/L2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport {AddressAliasHelper} from \"../../standards/AddressAliasHelper.sol\";\nimport {Lib_CrossDomainUtils} from \"../../libraries/bridge/Lib_CrossDomainUtils.sol\";\nimport {Lib_DefaultValues} from \"../../libraries/constants/Lib_DefaultValues.sol\";\nimport {Lib_PredeployAddresses} from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Interface Imports */\nimport {IL2CrossDomainMessenger} from \"./IL2CrossDomainMessenger.sol\";\nimport {iBVM_L2ToL1MessagePasser} from \"../predeploys/iBVM_L2ToL1MessagePasser.sol\";\n\n/**\n * @title L2CrossDomainMessenger\n * @dev The L2 Cross Domain Messenger contract sends messages from L2 to L1, and is the entry point\n * for L2 messages sent via the L1 Cross Domain Messenger.\n *\n */\ncontract L2CrossDomainMessenger is IL2CrossDomainMessenger {\n    /*************\n     * Variables *\n     *************/\n\n    mapping(bytes32 => bool) public relayedMessages;\n    mapping(bytes32 => bool) public successfulMessages;\n    mapping(bytes32 => bool) public sentMessages;\n    uint256 public messageNonce;\n    address internal xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n    address public l1CrossDomainMessenger;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _l1CrossDomainMessenger) {\n        l1CrossDomainMessenger = _l1CrossDomainMessenger;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    // slither-disable-next-line external-function\n    function xDomainMessageSender() public view returns (address) {\n        require(\n            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,\n            \"xDomainMessageSender is not set\"\n        );\n        return xDomainMsgSender;\n    }\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    // slither-disable-next-line external-function\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) public {\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            msg.sender,\n            _message,\n            messageNonce\n        );\n\n        sentMessages[keccak256(xDomainCalldata)] = true;\n\n        // Actually send the message.\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events\n        iBVM_L2ToL1MessagePasser(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER).passMessageToL1(\n            xDomainCalldata\n        );\n\n        // Emit an event before we bump the nonce or the nonce will be off by one.\n        // slither-disable-next-line reentrancy-events\n        emit SentMessage(_target, msg.sender, _message, messageNonce, _gasLimit);\n        // slither-disable-next-line reentrancy-no-eth\n        messageNonce += 1;\n    }\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @inheritdoc IL2CrossDomainMessenger\n     */\n    // slither-disable-next-line external-function\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) public {\n        // Since it is impossible to deploy a contract to an address on L2 which matches\n        // the alias of the L1CrossDomainMessenger, this check can only pass when it is called in\n        // the first call from of a deposit transaction. Thus reentrancy is prevented here.\n        require(\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1CrossDomainMessenger,\n            \"Provided message could not be verified.\"\n        );\n\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\n        require(\n            successfulMessages[xDomainCalldataHash] == false,\n            \"Provided message has already been received.\"\n        );\n\n        // Prevent calls to BVM_L2ToL1MessagePasser, which would enable\n        // an attacker to maliciously craft the _message to spoof\n        // a call from any L2 account.\n        if (_target == Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER) {\n            // Write to the successfulMessages mapping and return immediately.\n            successfulMessages[xDomainCalldataHash] = true;\n            return;\n        }\n\n        xDomainMsgSender = _sender;\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events, reentrancy-benign\n        (bool success, ) = _target.call(_message);\n        // slither-disable-next-line reentrancy-benign\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n        // Mark the message as received if the call was successful. Ensures that a message can be\n        // relayed multiple times in the case that the call reverted.\n        if (success == true) {\n            // slither-disable-next-line reentrancy-no-eth\n            successfulMessages[xDomainCalldataHash] = true;\n            // slither-disable-next-line reentrancy-events\n            emit RelayedMessage(xDomainCalldataHash);\n        } else {\n            // slither-disable-next-line reentrancy-events\n            emit FailedRelayedMessage(xDomainCalldataHash);\n        }\n\n        // Store an identifier that can be used to prove that the given message was relayed by some\n        // user. Gives us an easy way to pay relayers for their work.\n        bytes32 relayId = keccak256(abi.encodePacked(xDomainCalldata, msg.sender, block.number));\n\n        // slither-disable-next-line reentrancy-benign\n        relayedMessages[relayId] = true;\n    }\n}\n"
    },
    "contracts/L2/messaging/IL2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"../../libraries/bridge/ICrossDomainMessenger.sol\";\n\n/**\n * @title IL2CrossDomainMessenger\n */\ninterface IL2CrossDomainMessenger is ICrossDomainMessenger {\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     */\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) external;\n}\n"
    },
    "contracts/L2/predeploys/iBVM_L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title iBVM_L2ToL1MessagePasser\n */\ninterface iBVM_L2ToL1MessagePasser {\n    /**********\n     * Events *\n     **********/\n\n    event L2ToL1Message(uint256 _nonce, address _sender, bytes _data);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function passMessageToL1(bytes calldata _message) external;\n}\n"
    },
    "contracts/L2/predeploys/BVM_L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { iBVM_L2ToL1MessagePasser } from \"./iBVM_L2ToL1MessagePasser.sol\";\n\n/**\n * @title BVM_L2ToL1MessagePasser\n * @dev The L2 to L1 Message Passer is a utility contract which facilitate an L1 proof of the\n * of a message on L2. The L1 Cross Domain Messenger performs this proof in its\n * _verifyStorageProof function, which verifies the existence of the transaction hash in this\n * contract's `sentMessages` mapping.\n */\ncontract BVM_L2ToL1MessagePasser is iBVM_L2ToL1MessagePasser {\n    /**********************\n     * Contract Variables *\n     **********************/\n\n    mapping(bytes32 => bool) public sentMessages;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Passes a message to L1.\n     * @param _message Message to pass to L1.\n     */\n    // slither-disable-next-line external-function\n    function passMessageToL1(bytes memory _message) public {\n        // Note: although this function is public, only messages sent from the\n        // L2CrossDomainMessenger will be relayed by the L1CrossDomainMessenger.\n        // This is enforced by a check in L1CrossDomainMessenger._verifyStorageProof().\n        sentMessages[keccak256(abi.encodePacked(_message, msg.sender))] = true;\n    }\n}\n"
    },
    "contracts/test-libraries/bridge/TestLib_CrossDomainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_CrossDomainUtils } from \"../../libraries/bridge/Lib_CrossDomainUtils.sol\";\n\n/**\n * @title TestLib_CrossDomainUtils\n */\nlibrary TestLib_CrossDomainUtils {\n    function encodeXDomainCalldata(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) public pure returns (bytes memory) {\n        return\n            Lib_CrossDomainUtils.encodeXDomainCalldata(_target, _sender, _message, _messageNonce);\n    }\n}\n"
    },
    "contracts/test-libraries/standards/TestLib_AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n/* Library Imports */\nimport { AddressAliasHelper } from \"../../standards/AddressAliasHelper.sol\";\n\n/**\n * @title TestLib_AddressAliasHelper\n */\ncontract TestLib_AddressAliasHelper {\n    function applyL1ToL2Alias(address _address) public pure returns (address) {\n        return AddressAliasHelper.applyL1ToL2Alias(_address);\n    }\n\n    function undoL1ToL2Alias(address _address) public pure returns (address) {\n        return AddressAliasHelper.undoL1ToL2Alias(_address);\n    }\n}\n"
    },
    "contracts/L1/rollup/CanonicalTransactionChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { AddressAliasHelper } from \"../../standards/AddressAliasHelper.sol\";\nimport { Lib_BVMCodec } from \"../../libraries/codec/Lib_BVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\n\n/* Interface Imports */\nimport { ICanonicalTransactionChain } from \"./ICanonicalTransactionChain.sol\";\nimport { IChainStorageContainer } from \"./IChainStorageContainer.sol\";\n\n/**\n * @title CanonicalTransactionChain\n * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions\n * which must be applied to the rollup state. It defines the ordering of rollup transactions by\n * writing them to the 'CTC:batches' instance of the Chain Storage Container.\n * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the\n * Sequencer will eventually append it to the rollup state.\n *\n */\ncontract CanonicalTransactionChain is ICanonicalTransactionChain, Lib_AddressResolver {\n    /*************\n     * Constants *\n     *************/\n\n    // L2 tx gas-related\n    uint256 public constant MIN_ROLLUP_TX_GAS = 100000;\n    uint256 public constant MAX_ROLLUP_TX_SIZE = 50000;\n\n    // The approximate cost of calling the enqueue function\n    uint256 public enqueueGasCost;\n    // The ratio of the cost of L1 gas to the cost of L2 gas\n    uint256 public l2GasDiscountDivisor;\n    // The amount of L2 gas which can be forwarded to L2 without spam prevention via 'gas burn'.\n    // Calculated as the product of l2GasDiscountDivisor * enqueueGasCost.\n    // See comments in enqueue() for further detail.\n    uint256 public enqueueL2GasPrepaid;\n\n    // Encoding-related (all in bytes)\n    uint256 internal constant BATCH_CONTEXT_SIZE = 16;\n    // slither-disable-next-line unused-state\n    uint256 internal constant BATCH_CONTEXT_LENGTH_POS = 12;\n    uint256 internal constant BATCH_CONTEXT_START_POS = 15;\n    // slither-disable-next-line unused-state\n    uint256 internal constant TX_DATA_HEADER_SIZE = 3;\n    // slither-disable-next-line unused-state\n    uint256 internal constant BYTES_TILL_TX_DATA = 65;\n\n    /*************\n     * Variables *\n     *************/\n\n    uint256 public maxTransactionGasLimit;\n\n    /***************\n     * Queue State *\n     ***************/\n\n    uint40 private _nextQueueIndex; // index of the first queue element not yet included\n    Lib_BVMCodec.QueueElement[] queueElements;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _libAddressManager,\n        uint256 _maxTransactionGasLimit,\n        uint256 _l2GasDiscountDivisor,\n        uint256 _enqueueGasCost\n    ) Lib_AddressResolver(_libAddressManager) {\n        maxTransactionGasLimit = _maxTransactionGasLimit;\n        l2GasDiscountDivisor = _l2GasDiscountDivisor;\n        enqueueGasCost = _enqueueGasCost;\n        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Modifier to enforce that, if configured, only the Burn Admin may\n     * successfully call a method.\n     */\n    modifier onlyBurnAdmin() {\n        require(msg.sender == libAddressManager.owner(), \"Only callable by the Burn Admin.\");\n        _;\n    }\n\n    /*******************************\n     * Authorized Setter Functions *\n     *******************************/\n\n    /**\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\n     */\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost)\n        external\n        onlyBurnAdmin\n    {\n        enqueueGasCost = _enqueueGasCost;\n        l2GasDiscountDivisor = _l2GasDiscountDivisor;\n        // See the comment in enqueue() for the rationale behind this formula.\n        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;\n\n        emit L2GasParamsUpdated(l2GasDiscountDivisor, enqueueGasCost, enqueueL2GasPrepaid);\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches() public view returns (IChainStorageContainer) {\n        return IChainStorageContainer(resolve(\"ChainStorageContainer-CTC-batches\"));\n    }\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements() public view returns (uint256 _totalElements) {\n        (uint40 totalElements, , , ) = _getBatchExtraData();\n        return uint256(totalElements);\n    }\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    // slither-disable-next-line external-function\n    function getTotalBatches() public view returns (uint256 _totalBatches) {\n        return batches().length();\n    }\n\n    /**\n     * Returns the index of the next element to be enqueued.\n     * @return Index for the next queue element.\n     */\n    // slither-disable-next-line external-function\n    function getNextQueueIndex() public view returns (uint40) {\n        return _nextQueueIndex;\n    }\n\n    /**\n     * Returns the timestamp of the last transaction.\n     * @return Timestamp for the last transaction.\n     */\n    // slither-disable-next-line external-function\n    function getLastTimestamp() public view returns (uint40) {\n        (, , uint40 lastTimestamp, ) = _getBatchExtraData();\n        return lastTimestamp;\n    }\n\n    /**\n     * Returns the blocknumber of the last transaction.\n     * @return Blocknumber for the last transaction.\n     */\n    // slither-disable-next-line external-function\n    function getLastBlockNumber() public view returns (uint40) {\n        (, , , uint40 lastBlockNumber) = _getBatchExtraData();\n        return lastBlockNumber;\n    }\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    // slither-disable-next-line external-function\n    function getQueueElement(uint256 _index)\n        public\n        view\n        returns (Lib_BVMCodec.QueueElement memory _element)\n    {\n        return queueElements[_index];\n    }\n\n    /**\n     * Get the number of queue elements which have not yet been included.\n     * @return Number of pending queue elements.\n     */\n    // slither-disable-next-line external-function\n    function getNumPendingQueueElements() public view returns (uint40) {\n        return uint40(queueElements.length) - _nextQueueIndex;\n    }\n\n    /**\n     * Retrieves the length of the queue, including\n     * both pending and canonical transactions.\n     * @return Length of the queue.\n     */\n    // slither-disable-next-line external-function\n    function getQueueLength() public view returns (uint40) {\n        return uint40(queueElements.length);\n    }\n\n    /**\n     * Adds a transaction to the queue.\n     * @param _target Target L2 contract to send the transaction to.\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\n     * @param _data Transaction data.\n     */\n    function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(_gasLimit >= MIN_ROLLUP_TX_GAS, \"Transaction gas limit too low to enqueue.\");\n\n        // Transactions submitted to the queue lack a method for paying gas fees to the Sequencer.\n        // So we need to prevent spam attacks by ensuring that the cost of enqueueing a transaction\n        // from L1 to L2 is not underpriced. For transaction with a high L2 gas limit, we do this by\n        // burning some extra gas on L1. Of course there is also some intrinsic cost to enqueueing a\n        // transaction, so we want to make sure not to over-charge (by burning too much L1 gas).\n        // Therefore, we define 'enqueueL2GasPrepaid' as the L2 gas limit above which we must burn\n        // additional gas on L1. This threshold is the product of two inputs:\n        // 1. enqueueGasCost: the base cost of calling this function.\n        // 2. l2GasDiscountDivisor: the ratio between the cost of gas on L1 and L2. This is a\n        //    positive integer, meaning we assume L2 gas is always less costly.\n        // The calculation below for gasToConsume can be seen as converting the difference (between\n        // the specified L2 gas limit and the prepaid L2 gas limit) to an L1 gas amount.\n        if (_gasLimit > enqueueL2GasPrepaid) {\n            uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) / l2GasDiscountDivisor;\n            uint256 startingGas = gasleft();\n\n            // Although this check is not necessary (burn below will run out of gas if not true), it\n            // gives the user an explicit reason as to why the enqueue attempt failed.\n            require(startingGas > gasToConsume, \"Insufficient gas for L2 rate limiting burn.\");\n\n            uint256 i;\n            while (startingGas - gasleft() < gasToConsume) {\n                i++;\n            }\n        }\n\n        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a\n        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.\n        // We can safely ignore this for EOAs because they're guaranteed to have the same \"code\"\n        // (i.e. no code at all). This also makes it possible for users to interact with contracts\n        // on L2 even when the Sequencer is down.\n        address sender;\n        if (msg.sender == tx.origin) {\n            sender = msg.sender;\n        } else {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        bytes32 transactionHash = keccak256(abi.encode(sender, _target, _gasLimit, _data));\n\n        queueElements.push(\n            Lib_BVMCodec.QueueElement({\n                transactionHash: transactionHash,\n                timestamp: uint40(block.timestamp),\n                blockNumber: uint40(block.number)\n            })\n        );\n        uint256 queueIndex = queueElements.length - 1;\n        emit TransactionEnqueued(sender, _target, _gasLimit, _data, queueIndex, block.timestamp);\n    }\n\n    /**\n     * Allows the sequencer to append a batch of transactions.\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\n     * .param _contexts Array of batch contexts.\n     * .param _transactionDataFields Array of raw transaction data.\n     */\n    function appendSequencerBatch() external {\n        uint40 shouldStartAtElement;\n        uint24 totalElementsToAppend;\n        uint24 numContexts;\n        assembly {\n            shouldStartAtElement := shr(216, calldataload(4))\n            totalElementsToAppend := shr(232, calldataload(9))\n            numContexts := shr(232, calldataload(12))\n        }\n\n        require(\n            shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        require(\n            msg.sender == resolve(\"BVM_Sequencer\"),\n            \"Function can only be called by the Sequencer.\"\n        );\n\n        uint40 nextTransactionPtr = uint40(\n            BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts\n        );\n\n        require(msg.data.length >= nextTransactionPtr, \"Not enough BatchContexts provided.\");\n\n        // Counter for number of sequencer transactions appended so far.\n        uint32 numSequencerTransactions = 0;\n\n        // Cache the _nextQueueIndex storage variable to a temporary stack variable.\n        // This is safe as long as nothing reads or writes to the storage variable\n        // until it is updated by the temp variable.\n        uint40 nextQueueIndex = _nextQueueIndex;\n\n        BatchContext memory curContext;\n        for (uint32 i = 0; i < numContexts; i++) {\n            BatchContext memory nextContext = _getBatchContext(i);\n\n            // Now we can update our current context.\n            curContext = nextContext;\n\n            // Process sequencer transactions first.\n            numSequencerTransactions += uint32(curContext.numSequencedTransactions);\n\n            // Now process any subsequent queue transactions.\n            nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);\n        }\n\n        require(\n            nextQueueIndex <= queueElements.length,\n            \"Attempted to append more elements than are available in the queue.\"\n        );\n\n        // Generate the required metadata that we need to append this batch\n        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;\n        uint40 blockTimestamp;\n        uint40 blockNumber;\n        if (curContext.numSubsequentQueueTransactions == 0) {\n            // The last element is a sequencer tx, therefore pull timestamp and block number from\n            // the last context.\n            blockTimestamp = uint40(curContext.timestamp);\n            blockNumber = uint40(curContext.blockNumber);\n        } else {\n            // The last element is a queue tx, therefore pull timestamp and block number from the\n            // queue element.\n            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at\n            // least one queue element. We increment nextQueueIndex after processing each queue\n            // element, so the index of the last element we processed is nextQueueIndex - 1.\n            Lib_BVMCodec.QueueElement memory lastElement = queueElements[nextQueueIndex - 1];\n\n            blockTimestamp = lastElement.timestamp;\n            blockNumber = lastElement.blockNumber;\n        }\n\n        // Cache the previous blockhash to ensure all transaction data can be retrieved efficiently.\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events\n        _appendBatch(\n            blockhash(block.number - 1),\n            totalElementsToAppend,\n            numQueuedTransactions,\n            blockTimestamp,\n            blockNumber\n        );\n\n        // slither-disable-next-line reentrancy-events\n        emit SequencerBatchAppended(\n            nextQueueIndex - numQueuedTransactions,\n            numQueuedTransactions,\n            getTotalElements()\n        );\n\n        // Update the _nextQueueIndex storage variable.\n        // slither-disable-next-line reentrancy-no-eth\n        _nextQueueIndex = nextQueueIndex;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Returns the BatchContext located at a particular index.\n     * @param _index The index of the BatchContext\n     * @return The BatchContext at the specified index.\n     */\n    function _getBatchContext(uint256 _index) internal pure returns (BatchContext memory) {\n        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;\n        // slither-disable-next-line similar-names\n        uint256 numSequencedTransactions;\n        uint256 numSubsequentQueueTransactions;\n        uint256 ctxTimestamp;\n        uint256 ctxBlockNumber;\n\n        assembly {\n            numSequencedTransactions := shr(232, calldataload(contextPtr))\n            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))\n            ctxTimestamp := shr(216, calldataload(add(contextPtr, 6)))\n            ctxBlockNumber := shr(216, calldataload(add(contextPtr, 11)))\n        }\n\n        return\n            BatchContext({\n                numSequencedTransactions: numSequencedTransactions,\n                numSubsequentQueueTransactions: numSubsequentQueueTransactions,\n                timestamp: ctxTimestamp,\n                blockNumber: ctxBlockNumber\n            });\n    }\n\n    /**\n     * Parses the batch context from the extra data.\n     * @return Total number of elements submitted.\n     * @return Index of the next queue element.\n     */\n    function _getBatchExtraData()\n        internal\n        view\n        returns (\n            uint40,\n            uint40,\n            uint40,\n            uint40\n        )\n    {\n        bytes27 extraData = batches().getGlobalMetadata();\n\n        uint40 totalElements;\n        uint40 nextQueueIndex;\n        uint40 lastTimestamp;\n        uint40 lastBlockNumber;\n\n        // solhint-disable max-line-length\n        assembly {\n            extraData := shr(40, extraData)\n            totalElements := and(\n                extraData,\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\n            )\n            nextQueueIndex := shr(\n                40,\n                and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000)\n            )\n            lastTimestamp := shr(\n                80,\n                and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000)\n            )\n            lastBlockNumber := shr(\n                120,\n                and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000)\n            )\n        }\n        // solhint-enable max-line-length\n\n        return (totalElements, nextQueueIndex, lastTimestamp, lastBlockNumber);\n    }\n\n    /**\n     * Encodes the batch context for the extra data.\n     * @param _totalElements Total number of elements submitted.\n     * @param _nextQueueIdx Index of the next queue element.\n     * @param _timestamp Timestamp for the last batch.\n     * @param _blockNumber Block number of the last batch.\n     * @return Encoded batch context.\n     */\n    function _makeBatchExtraData(\n        uint40 _totalElements,\n        uint40 _nextQueueIdx,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    ) internal pure returns (bytes27) {\n        bytes27 extraData;\n        assembly {\n            extraData := _totalElements\n            extraData := or(extraData, shl(40, _nextQueueIdx))\n            extraData := or(extraData, shl(80, _timestamp))\n            extraData := or(extraData, shl(120, _blockNumber))\n            extraData := shl(40, extraData)\n        }\n\n        return extraData;\n    }\n\n    /**\n     * Inserts a batch into the chain of batches.\n     * @param _transactionRoot Root of the transaction tree for this batch.\n     * @param _batchSize Number of elements in the batch.\n     * @param _numQueuedTransactions Number of queue transactions in the batch.\n     * @param _timestamp The latest batch timestamp.\n     * @param _blockNumber The latest batch blockNumber.\n     */\n    function _appendBatch(\n        bytes32 _transactionRoot,\n        uint256 _batchSize,\n        uint256 _numQueuedTransactions,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    ) internal {\n        IChainStorageContainer batchesRef = batches();\n        (uint40 totalElements, uint40 nextQueueIndex, , ) = _getBatchExtraData();\n\n        Lib_BVMCodec.ChainBatchHeader memory header = Lib_BVMCodec.ChainBatchHeader({\n            batchIndex: batchesRef.length(),\n            batchRoot: _transactionRoot,\n            batchSize: _batchSize,\n            prevTotalElements: totalElements,\n            signature:  hex\"\",\n            extraData: hex\"\"\n        });\n\n        emit TransactionBatchAppended(\n            header.batchIndex,\n            header.batchRoot,\n            header.batchSize,\n            header.prevTotalElements,\n            header.signature,\n            header.extraData\n        );\n\n        bytes32 batchHeaderHash = Lib_BVMCodec.hashBatchHeader(header);\n        bytes27 latestBatchContext = _makeBatchExtraData(\n            totalElements + uint40(header.batchSize),\n            nextQueueIndex + uint40(_numQueuedTransactions),\n            _timestamp,\n            _blockNumber\n        );\n\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events\n        batchesRef.push(batchHeaderHash, latestBatchContext);\n    }\n\n    /**\n     * Reset the index when the ctc data is dirtyed\n     */\n    function resetIndex(uint256 _batchIndex, uint40 _totalElement, uint40 _batchSize,\n        uint40 _nextqIndex,uint40 _numQueuedTransactions ,\n        uint40 _timestamp, uint40 _blockNumber) external {\n        require(_batchIndex < batches().length(), \"Invalid batch index.\");\n\n        require(msg.sender == libAddressManager.owner(), \"Only callable by the address manager owner.\");\n\n        bytes27 latestBatchContext = _makeBatchExtraData(\n            _totalElement + _batchSize, _nextqIndex + _numQueuedTransactions,\n            _timestamp, _blockNumber\n        );\n\n        // slither-disable-next-line reentrancy-events\n        batches().deleteElementsAfterInclusive(_batchIndex,latestBatchContext);\n\n        _nextQueueIndex = _nextqIndex;\n\n        // slither-disable-next-line reentrancy-events\n        emit CTCBatchReset(_batchIndex,_nextqIndex,_totalElement,_batchSize,_numQueuedTransactions,_timestamp,_blockNumber);\n    }\n\n}\n"
    },
    "contracts/L1/rollup/ChainStorageContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_Buffer } from \"../../libraries/utils/Lib_Buffer.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\n\n/* Interface Imports */\nimport { IChainStorageContainer } from \"./IChainStorageContainer.sol\";\n\n/**\n * @title ChainStorageContainer\n * @dev The Chain Storage Container provides its owner contract with read, write and delete\n * functionality. This provides gas efficiency gains by enabling it to overwrite storage slots which\n * can no longer be used in a fraud proof due to the fraud window having passed, and the associated\n * chain state or transactions being finalized.\n * Three distinct Chain Storage Containers will be deployed on Layer 1:\n * 1. Stores transaction batches for the Canonical Transaction Chain\n * 2. Stores queued transactions for the Canonical Transaction Chain\n * 3. Stores chain state batches for the State Commitment Chain\n *\n */\ncontract ChainStorageContainer is IChainStorageContainer, Lib_AddressResolver {\n    /*************\n     * Libraries *\n     *************/\n\n    using Lib_Buffer for Lib_Buffer.Buffer;\n\n    /*************\n     * Variables *\n     *************/\n\n    string public owner;\n    Lib_Buffer.Buffer internal buffer;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     * @param _owner Name of the contract that owns this container (will be resolved later).\n     */\n    constructor(address _libAddressManager, string memory _owner)\n        Lib_AddressResolver(_libAddressManager)\n    {\n        owner = _owner;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == resolve(owner),\n            \"ChainStorageContainer: Function can only be called by the owner.\"\n        );\n        _;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function setGlobalMetadata(bytes27 _globalMetadata) public onlyOwner {\n        return buffer.setExtraData(_globalMetadata);\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function getGlobalMetadata() public view returns (bytes27) {\n        return buffer.getExtraData();\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function length() public view returns (uint256) {\n        return uint256(buffer.getLength());\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function push(bytes32 _object) public onlyOwner {\n        buffer.push(_object);\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function push(bytes32 _object, bytes27 _globalMetadata) public onlyOwner {\n        buffer.push(_object, _globalMetadata);\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function get(uint256 _index) public view returns (bytes32) {\n        return buffer.get(uint40(_index));\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function deleteElementsAfterInclusive(uint256 _index) public onlyOwner {\n        buffer.deleteElementsAfterInclusive(uint40(_index));\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata)\n        public\n        onlyOwner\n    {\n        buffer.deleteElementsAfterInclusive(uint40(_index), _globalMetadata);\n    }\n}\n"
    },
    "contracts/libraries/utils/Lib_Buffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_Buffer\n * @dev This library implements a bytes32 storage array with some additional gas-optimized\n * functionality. In particular, it encodes its length as a uint40, and tightly packs this with an\n * overwritable \"extra data\" field so we can store more information with a single SSTORE.\n */\nlibrary Lib_Buffer {\n    /*************\n     * Libraries *\n     *************/\n\n    using Lib_Buffer for Buffer;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct Buffer {\n        bytes32 context;\n        mapping(uint256 => bytes32) buf;\n    }\n\n    struct BufferContext {\n        // Stores the length of the array. Uint40 is way more elements than we'll ever reasonably\n        // need in an array and we get an extra 27 bytes of extra data to play with.\n        uint40 length;\n        // Arbitrary extra data that can be modified whenever the length is updated. Useful for\n        // squeezing out some gas optimizations.\n        bytes27 extraData;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Pushes a single element to the buffer.\n     * @param _self Buffer to access.\n     * @param _value Value to push to the buffer.\n     * @param _extraData Global extra data.\n     */\n    function push(\n        Buffer storage _self,\n        bytes32 _value,\n        bytes27 _extraData\n    ) internal {\n        BufferContext memory ctx = _self.getContext();\n\n        _self.buf[ctx.length] = _value;\n\n        // Bump the global index and insert our extra data, then save the context.\n        ctx.length++;\n        ctx.extraData = _extraData;\n        _self.setContext(ctx);\n    }\n\n    /**\n     * Pushes a single element to the buffer.\n     * @param _self Buffer to access.\n     * @param _value Value to push to the buffer.\n     */\n    function push(Buffer storage _self, bytes32 _value) internal {\n        BufferContext memory ctx = _self.getContext();\n\n        _self.push(_value, ctx.extraData);\n    }\n\n    /**\n     * Retrieves an element from the buffer.\n     * @param _self Buffer to access.\n     * @param _index Element index to retrieve.\n     * @return Value of the element at the given index.\n     */\n    function get(Buffer storage _self, uint256 _index) internal view returns (bytes32) {\n        BufferContext memory ctx = _self.getContext();\n\n        require(_index < ctx.length, \"Index out of bounds.\");\n\n        return _self.buf[_index];\n    }\n\n    /**\n     * Deletes all elements after (and including) a given index.\n     * @param _self Buffer to access.\n     * @param _index Index of the element to delete from (inclusive).\n     * @param _extraData Optional global extra data.\n     */\n    function deleteElementsAfterInclusive(\n        Buffer storage _self,\n        uint40 _index,\n        bytes27 _extraData\n    ) internal {\n        BufferContext memory ctx = _self.getContext();\n\n        require(_index < ctx.length, \"Index out of bounds.\");\n\n        // Set our length and extra data, save the context.\n        ctx.length = _index;\n        ctx.extraData = _extraData;\n        _self.setContext(ctx);\n    }\n\n    /**\n     * Deletes all elements after (and including) a given index.\n     * @param _self Buffer to access.\n     * @param _index Index of the element to delete from (inclusive).\n     */\n    function deleteElementsAfterInclusive(Buffer storage _self, uint40 _index) internal {\n        BufferContext memory ctx = _self.getContext();\n        _self.deleteElementsAfterInclusive(_index, ctx.extraData);\n    }\n\n    /**\n     * Retrieves the current global index.\n     * @param _self Buffer to access.\n     * @return Current global index.\n     */\n    function getLength(Buffer storage _self) internal view returns (uint40) {\n        BufferContext memory ctx = _self.getContext();\n        return ctx.length;\n    }\n\n    /**\n     * Changes current global extra data.\n     * @param _self Buffer to access.\n     * @param _extraData New global extra data.\n     */\n    function setExtraData(Buffer storage _self, bytes27 _extraData) internal {\n        BufferContext memory ctx = _self.getContext();\n        ctx.extraData = _extraData;\n        _self.setContext(ctx);\n    }\n\n    /**\n     * Retrieves the current global extra data.\n     * @param _self Buffer to access.\n     * @return Current global extra data.\n     */\n    function getExtraData(Buffer storage _self) internal view returns (bytes27) {\n        BufferContext memory ctx = _self.getContext();\n        return ctx.extraData;\n    }\n\n    /**\n     * Sets the current buffer context.\n     * @param _self Buffer to access.\n     * @param _ctx Current buffer context.\n     */\n    function setContext(Buffer storage _self, BufferContext memory _ctx) internal {\n        bytes32 context;\n        uint40 length = _ctx.length;\n        bytes27 extraData = _ctx.extraData;\n        assembly {\n            context := length\n            context := or(context, extraData)\n        }\n\n        if (_self.context != context) {\n            _self.context = context;\n        }\n    }\n\n    /**\n     * Retrieves the current buffer context.\n     * @param _self Buffer to access.\n     * @return Current buffer context.\n     */\n    function getContext(Buffer storage _self) internal view returns (BufferContext memory) {\n        bytes32 context = _self.context;\n        uint40 length;\n        bytes27 extraData;\n        assembly {\n            length := and(\n                context,\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\n            )\n            extraData := and(\n                context,\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000\n            )\n        }\n\n        return BufferContext({ length: length, extraData: extraData });\n    }\n}\n"
    },
    "contracts/test-libraries/utils/TestLib_Buffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_Buffer } from \"../../libraries/utils/Lib_Buffer.sol\";\n\n/**\n * @title TestLib_Buffer\n */\ncontract TestLib_Buffer {\n    using Lib_Buffer for Lib_Buffer.Buffer;\n    using Lib_Buffer for Lib_Buffer.BufferContext;\n\n    Lib_Buffer.Buffer internal buf;\n\n    function push(bytes32 _value, bytes27 _extraData) public {\n        buf.push(_value, _extraData);\n    }\n\n    function push(bytes32 _value) public {\n        buf.push(_value);\n    }\n\n    function get(uint256 _index) public view returns (bytes32) {\n        return buf.get(_index);\n    }\n\n    function deleteElementsAfterInclusive(uint40 _index) public {\n        return buf.deleteElementsAfterInclusive(_index);\n    }\n\n    function deleteElementsAfterInclusive(uint40 _index, bytes27 _extraData) public {\n        return buf.deleteElementsAfterInclusive(_index, _extraData);\n    }\n\n    function getLength() public view returns (uint40) {\n        return buf.getLength();\n    }\n\n    function setExtraData(bytes27 _extraData) public {\n        return buf.setExtraData(_extraData);\n    }\n\n    function getExtraData() public view returns (bytes27) {\n        return buf.getExtraData();\n    }\n\n    function getContext() public view returns (Lib_Buffer.BufferContext memory) {\n        return buf.getContext();\n    }\n\n    function setContext(uint40 _index, bytes27 _extraData) public {\n        Lib_Buffer.BufferContext memory _ctx = Lib_Buffer.BufferContext({\n            length: _index,\n            extraData: _extraData\n        });\n        return buf.setContext(_ctx);\n    }\n}\n"
    },
    "contracts/test-libraries/utils/TestLib_MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_MerkleTree } from \"../../libraries/utils/Lib_MerkleTree.sol\";\n\n/**\n * @title TestLib_MerkleTree\n */\ncontract TestLib_MerkleTree {\n    function getMerkleRoot(bytes32[] memory _elements) public pure returns (bytes32) {\n        return Lib_MerkleTree.getMerkleRoot(_elements);\n    }\n\n    function verify(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32[] memory _siblings,\n        uint256 _totalLeaves\n    ) public pure returns (bool) {\n        return Lib_MerkleTree.verify(_root, _leaf, _index, _siblings, _totalLeaves);\n    }\n}\n"
    },
    "contracts/L1/deployment/AddressDictator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Lib_AddressManager } from \"../../libraries/resolver/Lib_AddressManager.sol\";\n\n/**\n * @title AddressDictator\n * @dev The AddressDictator (glory to Arstotzka) is a contract that allows us to safely manipulate\n *      many different addresses in the AddressManager without transferring ownership of the\n *      AddressManager to a hot wallet or hardware wallet.\n */\ncontract AddressDictator {\n    /*********\n     * Types *\n     *********/\n\n    struct NamedAddress {\n        string name;\n        address addr;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    Lib_AddressManager public manager;\n    address public finalOwner;\n    NamedAddress[] namedAddresses;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _manager Address of the AddressManager contract.\n     * @param _finalOwner Address to transfer AddressManager ownership to afterwards.\n     * @param _names Array of names to associate an address with.\n     * @param _addresses Array of addresses to associate with the name.\n     */\n    constructor(\n        Lib_AddressManager _manager,\n        address _finalOwner,\n        string[] memory _names,\n        address[] memory _addresses\n    ) {\n        manager = _manager;\n        finalOwner = _finalOwner;\n        require(\n            _names.length == _addresses.length,\n            \"AddressDictator: Must provide an equal number of names and addresses.\"\n        );\n        for (uint256 i = 0; i < _names.length; i++) {\n            namedAddresses.push(NamedAddress({ name: _names[i], addr: _addresses[i] }));\n        }\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Called to finalize the transfer, this function is callable by anyone, but will only result in\n     * an upgrade if this contract is the owner Address Manager.\n     */\n    // slither-disable-next-line calls-loop\n    function setAddresses() external {\n        for (uint256 i = 0; i < namedAddresses.length; i++) {\n            manager.setAddress(namedAddresses[i].name, namedAddresses[i].addr);\n        }\n        // note that this will revert if _finalOwner == currentOwner\n        manager.transferOwnership(finalOwner);\n    }\n\n    /**\n     * Transfers ownership of this contract to the finalOwner.\n     * Only callable by the Final Owner, which is intended to be our multisig.\n     * This function shouldn't be necessary, but it gives a sense of reassurance that we can recover\n     * if something really surprising goes wrong.\n     */\n    function returnOwnership() external {\n        require(msg.sender == finalOwner, \"AddressDictator: only callable by finalOwner\");\n        manager.transferOwnership(finalOwner);\n    }\n\n    /******************\n     * View Functions *\n     ******************/\n\n    /**\n     * Returns the full namedAddresses array.\n     */\n    function getNamedAddresses() external view returns (NamedAddress[] memory) {\n        return namedAddresses;\n    }\n}\n"
    },
    "contracts/L2/tokens/wmantle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.9;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract WMANTLE is ERC20  {\n    constructor() ERC20(\"Wrapped Mantle\", \"WMNT\") {}\n    event  Deposit(address indexed dst, uint256 wad);\n    event  Withdrawal(address indexed src, uint256 wad);\n\n    fallback() external payable {\n        deposit();\n    }\n\n    receive() external payable {\n        deposit();\n    }\n\n    /// @dev mint tokens for sender based on amount of mantle sent.\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /// @dev withdraw mantle based on requested amount and user balance.\n    function withdraw(uint256 _amount) external {\n        require(balanceOf(msg.sender) >= _amount, \"insufficient balance.\");\n        _burn(msg.sender, _amount);\n        payable(msg.sender).transfer(_amount);\n        emit Withdrawal(msg.sender, _amount);\n    }\n}\n\ncontract WMANTLEDeployer {\n    function deploy() public returns(address addr) {\n        bytes32 salt = keccak256(abi.encodePacked(\"WMANTLE\"));\n\n        WMANTLE w = new WMANTLE{salt: salt}();\n        return address(w);\n    }\n\n    function calculateAddr() public view returns(address predictedAddress){\n        bytes32 salt = keccak256(abi.encodePacked(\"WMANTLE\"));\n        predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(type(WMANTLE).creationCode)\n            )))));\n    }\n}\n\n\n/*\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n*/\n\n\n"
    },
    "contracts/L1/deployment/ChugSplashDictator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { L1ChugSplashProxy } from \"../../chugsplash/L1ChugSplashProxy.sol\";\nimport { iL1ChugSplashDeployer } from \"../../chugsplash/interfaces/iL1ChugSplashDeployer.sol\";\n\n/**\n * @title ChugSplashDictator\n * @dev Like the AddressDictator, but specifically for the Proxy__BVM_L1StandardBridge. We're\n *      working on a generalized version of this but this is good enough for the moment.\n */\ncontract ChugSplashDictator is iL1ChugSplashDeployer {\n    /*************\n     * Variables *\n     *************/\n\n    // slither-disable-next-line constable-states\n    bool public isUpgrading = true;\n    L1ChugSplashProxy public target;\n    address public finalOwner;\n    bytes32 public codeHash;\n    bytes32 public messengerSlotKey;\n    bytes32 public messengerSlotVal;\n    bytes32 public bridgeSlotKey;\n    bytes32 public bridgeSlotVal;\n    bytes32 public mantleAddressSlotKey;\n    bytes32 public mantleAddressSlotVal;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        L1ChugSplashProxy _target,\n        address _finalOwner,\n        bytes32 _codeHash,\n        bytes32 _messengerSlotKey,\n        bytes32 _messengerSlotVal,\n        bytes32 _bridgeSlotKey,\n        bytes32 _bridgeSlotVal,\n        bytes32 _mantleAddressSlotKey,\n        bytes32 _mantleAddressSlotVal\n    ) {\n        target = _target;\n        finalOwner = _finalOwner;\n        codeHash = _codeHash;\n        messengerSlotKey = _messengerSlotKey;\n        messengerSlotVal = _messengerSlotVal;\n        bridgeSlotKey = _bridgeSlotKey;\n        bridgeSlotVal = _bridgeSlotVal;\n        mantleAddressSlotKey = _mantleAddressSlotKey;\n        mantleAddressSlotVal = _mantleAddressSlotVal;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function doActions(bytes memory _code) external {\n        require(keccak256(_code) == codeHash, \"ChugSplashDictator: Incorrect code hash.\");\n\n        target.setCode(_code);\n        target.setStorage(messengerSlotKey, messengerSlotVal);\n        target.setStorage(bridgeSlotKey, bridgeSlotVal);\n        target.setStorage(mantleAddressSlotKey, mantleAddressSlotVal);\n        target.setOwner(finalOwner);\n    }\n\n    /**\n     * Transfers ownership of this contract to the finalOwner.\n     * Only callable by the finalOwner, which is intended to be our multisig.\n     * This function shouldn't be necessary, but it gives a sense of reassurance that we can\n     * recover if something really surprising goes wrong.\n     */\n    function returnOwnership() external {\n        require(msg.sender == finalOwner, \"ChugSplashDictator: only callable by finalOwner\");\n\n        target.setOwner(finalOwner);\n    }\n}\n"
    },
    "contracts/chugsplash/L1ChugSplashProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { iL1ChugSplashDeployer } from \"./interfaces/iL1ChugSplashDeployer.sol\";\n\n/**\n * @title L1ChugSplashProxy\n * @dev Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\n * functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty!\n *\n * Note for future developers: do NOT make anything in this contract 'public' unless you know what\n * you're doing. Anything public can potentially have a function signature that conflicts with a\n * signature attached to the implementation contract. Public functions SHOULD always have the\n * 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that\n * modifier. And there almost certainly is not a good reason to not have that modifier. Beware!\n */\ncontract L1ChugSplashProxy {\n    /*************\n     * Constants *\n     *************/\n\n    // \"Magic\" prefix. When prepended to some arbitrary bytecode and used to create a contract, the\n    // appended bytecode will be deployed as given.\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\n\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _owner Address of the initial contract owner.\n     */\n    constructor(address _owner) {\n        _setOwner(_owner);\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Blocks a function from being called when the parent signals that the system should be paused\n     * via an isUpgrading function.\n     */\n    modifier onlyWhenNotPaused() {\n        address owner = _getOwner();\n\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\n        // it turns out that it isn't the right type of contract.\n        (bool success, bytes memory returndata) = owner.staticcall(\n            abi.encodeWithSelector(iL1ChugSplashDeployer.isUpgrading.selector)\n        );\n\n        // If the call was unsuccessful then we assume that there's no \"isUpgrading\" method and we\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\n        // long. If this isn't the case then we can safely ignore the result.\n        if (success && returndata.length == 32) {\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\n            // really care about the case where this value is 0 (= false).\n            uint256 ret = abi.decode(returndata, (uint256));\n            require(ret == 0, \"L1ChugSplashProxy: system is currently being upgraded\");\n        }\n\n        _;\n    }\n\n    /**\n     * Makes a proxy call instead of triggering the given function when the caller is either the\n     * owner or the zero address. Caller can only ever be the zero address if this function is\n     * being called off-chain via eth_call, which is totally fine and can be convenient for\n     * client-side tooling. Avoids situations where the proxy and implementation share a sighash\n     * and the proxy function ends up being called instead of the implementation one.\n     *\n     * Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If there's a\n     * way for someone to send a transaction with msg.sender == address(0) in any real context then\n     * we have much bigger problems. Primary reason to include this additional allowed sender is\n     * because the owner address can be changed dynamically and we do not want clients to have to\n     * keep track of the current owner in order to make an eth_call that doesn't trigger the\n     * proxied contract.\n     */\n    // slither-disable-next-line incorrect-modifier\n    modifier proxyCallIfNotOwner() {\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sets the code that should be running behind this proxy. Note that this scheme is a bit\n     * different from the standard proxy scheme where one would typically deploy the code\n     * separately and then set the implementation address. We're doing it this way because it gives\n     * us a lot more freedom on the client side. Can only be triggered by the contract owner.\n     * @param _code New contract code to run inside this contract.\n     */\n    // slither-disable-next-line external-function\n    function setCode(bytes memory _code) public proxyCallIfNotOwner {\n        // Get the code hash of the current implementation.\n        address implementation = _getImplementation();\n\n        // If the code hash matches the new implementation then we return early.\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\n            return;\n        }\n\n        // Create the deploycode by appending the magic prefix.\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\n\n        // Deploy the code and set the new implementation address.\n        address newImplementation;\n        assembly {\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\n        }\n\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\n        // actually fail this check. Should only happen if the contract creation from above runs\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\n        // should be doing this check anyway though.\n        require(\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\n            \"L1ChugSplashProxy: code was not correctly deployed.\"\n        );\n\n        _setImplementation(newImplementation);\n    }\n\n    /**\n     * Modifies some storage slot within the proxy contract. Gives us a lot of power to perform\n     * upgrades in a more transparent way. Only callable by the owner.\n     * @param _key Storage key to modify.\n     * @param _value New value for the storage key.\n     */\n    // slither-disable-next-line external-function\n    function setStorage(bytes32 _key, bytes32 _value) public proxyCallIfNotOwner {\n        assembly {\n            sstore(_key, _value)\n        }\n    }\n\n    /**\n     * Changes the owner of the proxy contract. Only callable by the owner.\n     * @param _owner New owner of the proxy contract.\n     */\n    // slither-disable-next-line external-function\n    function setOwner(address _owner) public proxyCallIfNotOwner {\n        _setOwner(_owner);\n    }\n\n    /**\n     * Queries the owner of the proxy contract. Can only be called by the owner OR by making an\n     * eth_call and setting the \"from\" address to address(0).\n     * @return Owner address.\n     */\n    // slither-disable-next-line external-function\n    function getOwner() public proxyCallIfNotOwner returns (address) {\n        return _getOwner();\n    }\n\n    /**\n     * Queries the implementation address. Can only be called by the owner OR by making an\n     * eth_call and setting the \"from\" address to address(0).\n     * @return Implementation address.\n     */\n    // slither-disable-next-line external-function\n    function getImplementation() public proxyCallIfNotOwner returns (address) {\n        return _getImplementation();\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Sets the implementation address.\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n    }\n\n    /**\n     * Queries the implementation address.\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address implementation;\n        assembly {\n            implementation := sload(IMPLEMENTATION_KEY)\n        }\n        return implementation;\n    }\n\n    /**\n     * Changes the owner of the proxy contract.\n     * @param _owner New owner of the proxy contract.\n     */\n    function _setOwner(address _owner) internal {\n        assembly {\n            sstore(OWNER_KEY, _owner)\n        }\n    }\n\n    /**\n     * Queries the owner of the proxy contract.\n     * @return Owner address.\n     */\n    function _getOwner() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n\n    /**\n     * Gets the code hash for a given account.\n     * @param _account Address of the account to get a code hash for.\n     * @return Code hash for the account.\n     */\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\n        bytes32 codeHash;\n        assembly {\n            codeHash := extcodehash(_account)\n        }\n        return codeHash;\n    }\n\n    /**\n     * Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal onlyWhenNotPaused {\n        address implementation = _getImplementation();\n\n        require(implementation != address(0), \"L1ChugSplashProxy: implementation is not set yet\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/chugsplash/interfaces/iL1ChugSplashDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title iL1ChugSplashDeployer\n */\ninterface iL1ChugSplashDeployer {\n    function isUpgrading() external view returns (bool);\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/subverifiers/MemoryOpVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\n//import \"../../libraries/BytesLib.sol\";\n//import \"../../libraries/MerkleLib.sol\";\n//import \"../libraries/VerificationContext.sol\";\n//import \"../libraries/OneStepProof.sol\";\n//import \"../libraries/Params.sol\";\n//import \"../libraries/GasTable.sol\";\n//import \"../libraries/VerifierHelper.sol\";\n//import \"../IVerifier.sol\";\n\ncontract MemoryOpVerifier {\n//contract MemoryOpVerifier is IVerifier {\n//    using BytesLib for bytes;\n//    using VerificationContext for VerificationContext.Context;\n//    using OneStepProof for OneStepProof.CodeProof;\n//    using OneStepProof for OneStepProof.LogProof;\n//\n//    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n//        external\n//        pure\n//        override\n//        returns (bytes32)\n//    {\n//        return OneStepProof.hashStateProof(executeOneStepProof(ctx, currStateHash, encoded));\n//    }\n//\n//    function executeOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n//        public\n//        pure\n//        returns (OneStepProof.StateProof memory)\n//    {\n//        uint64 offset = 0;\n//        // Decode state proof\n//        OneStepProof.StateProof memory stateProof;\n//        (offset, stateProof) = OneStepProof.decodeStateProof(ctx, encoded, offset);\n//        // Calculate the state hash from the submitted proof\n//        bytes32 stateHashFromProof;\n//        assembly {\n//            let ptr := mload(0x40)\n//            calldatacopy(ptr, encoded.offset, encoded.length)\n//            stateHashFromProof := keccak256(ptr, offset)\n//        }\n//        // Ensure the state proof is valid\n//        require(stateHashFromProof == currStateHash, \"Bad State Proof\");\n//\n//        // Decode the code proof\n//        OneStepProof.CodeProof memory codeProof;\n//        (offset, codeProof) = OneStepProof.decodeCodeProof(encoded, offset);\n//\n//        // Simulate EVM one-step execution based on the opcode\n//        uint8 opCode = stateProof.opCode;\n//        if (opCode == 0x20) {\n//            // KECCAK256\n//            verifyOpKECCAK256(offset, stateProof, encoded);\n//        } else if (opCode == 0x35) {\n//            // CALLDATALOAD\n//            verifyOpCALLDATALOAD(offset, stateProof, encoded);\n//        } else if (opCode == 0x37) {\n//            // CALLDATACOPY\n//            verifyOpCALLDATACOPY(offset, stateProof, encoded);\n//        } else if (opCode == 0x39) {\n//            // CODECOPY\n//            verifyOpCODECOPY(offset, stateProof, codeProof, encoded);\n//        } else if (opCode == 0x3e) {\n//            // RETURNDATACOPY\n//            verifyOpRETURNDATACOPY(offset, stateProof, encoded);\n//        } else if (opCode == 0x51) {\n//            // MLOAD\n//            verifyOpMLOAD(offset, stateProof, encoded);\n//        } else if (opCode == 0x52) {\n//            // MSTORE\n//            verifyOpMSTORE(offset, stateProof, encoded);\n//        } else if (opCode == 0x53) {\n//            // MSTORE8\n//            verifyOpMSTORE8(offset, stateProof, encoded);\n//        } else if (opCode >= 0xa0 && opCode <= 0xa4) {\n//            // LOG\n//            verifyLogOpCode(offset, stateProof, encoded);\n//        } else {\n//            revert(\"Unreachable\");\n//        }\n//\n//        // Obtain the opcode at new pc\n//        if (stateProof.depth > 0) {\n//            if (codeProof.size > uint256(stateProof.pc)) {\n//                stateProof.opCode = codeProof.getOpCodeAt(encoded, stateProof.pc);\n//            } else {\n//                stateProof.opCode = 0x00;\n//            }\n//        }\n//        // Return the state hash after one-step execution\n//        return stateProof;\n//    }\n//\n//    function verifyOpKECCAK256(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 2) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 2, offset, encoded);\n//\n//        uint64 memOffset = uint64(stackProof.pops[0]);\n//        uint64 length = uint64(stackProof.pops[1]);\n//        uint64 cost = GasTable.gasKeccak(stateProof.memSize, memOffset, length);\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        stateProof.gas -= cost;\n//\n//        bytes memory readContent;\n//        (offset, readContent) = MemoryLib.decodeAndVerifyMemoryReadProof(stateProof, encoded, offset, memOffset, length);\n//\n//        bytes32 result = keccak256(abi.encodePacked(readContent));\n//        stateProof.stackHash = keccak256(abi.encodePacked(stackProof.stackHashAfterPops, result));\n//        stateProof.pc += 1;\n//    }\n//\n//    function verifyOpCALLDATALOAD(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 1) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n//\n//        uint64 cost = Params.G_VERYLOW;\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        stateProof.gas -= cost;\n//\n//        uint64 memOffset = uint64(stackProof.pops[0]);\n//        bytes memory readContent;\n//        (offset, readContent) = MemoryLib.decodeAndVerifyMemoryLikeReadProofNoAppend(\n//            stateProof.inputDataRoot, stateProof.inputDataSize, encoded, offset, memOffset, 32\n//        );\n//\n//        bytes32 result = readContent.toBytes32(0);\n//        stateProof.stackHash = keccak256(abi.encodePacked(stackProof.stackHashAfterPops, result));\n//        stateProof.pc += 1;\n//    }\n//\n//    function verifyOpCALLDATACOPY(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 3) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 3, offset, encoded);\n//        uint64 memOffset = uint64(stackProof.pops[0]);\n//        uint64 inputOffset = uint64(stackProof.pops[1]);\n//        uint64 length = uint64(stackProof.pops[2]);\n//\n//        uint64 cost = GasTable.gasCopy(stateProof.memSize, memOffset, length);\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        stateProof.gas -= cost;\n//\n//        {\n//            bytes memory readContent;\n//            (offset, readContent) = MemoryLib.decodeAndVerifyMemoryLikeReadProofNoAppend(\n//                stateProof.inputDataRoot, stateProof.inputDataSize, encoded, offset, inputOffset, length\n//            );\n//\n//            bytes memory writeContent;\n//            (offset, writeContent) =\n//                MemoryLib.decodeAndVerifyMemoryWriteProof(stateProof, encoded, offset, memOffset, length);\n//\n//            require(readContent.equal(writeContent), \"Inconsistent Copy\");\n//        }\n//\n//        stateProof.pc += 1;\n//        stateProof.stackHash = stackProof.stackHashAfterPops;\n//    }\n//\n//    function verifyOpCODECOPY(\n//        uint64 offset,\n//        OneStepProof.StateProof memory stateProof,\n//        OneStepProof.CodeProof memory codeProof,\n//        bytes calldata encoded\n//    ) internal pure {\n//        if (stateProof.stackSize < 3) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 3, offset, encoded);\n//        uint64 memOffset = uint64(stackProof.pops[0]);\n//        uint64 codeOffset = uint64(stackProof.pops[1]);\n//        uint64 length = uint64(stackProof.pops[2]);\n//\n//        uint64 cost = GasTable.gasCopy(stateProof.memSize, memOffset, length);\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        stateProof.gas -= cost;\n//\n//        {\n//            bytes memory readContent = codeProof.getCodeSlice(encoded, codeOffset, length);\n//\n//            bytes memory writeContent;\n//            (offset, writeContent) =\n//                MemoryLib.decodeAndVerifyMemoryWriteProof(stateProof, encoded, offset, memOffset, length);\n//\n//            require(readContent.equal(writeContent), \"Inconsistent Copy\");\n//        }\n//\n//        stateProof.pc += 1;\n//        stateProof.stackHash = stackProof.stackHashAfterPops;\n//    }\n//\n//    function verifyOpRETURNDATACOPY(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 3) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 3, offset, encoded);\n//        uint64 memOffset = uint64(stackProof.pops[0]);\n//        uint64 returnOffset = uint64(stackProof.pops[1]);\n//        uint64 length = uint64(stackProof.pops[2]);\n//\n//        uint64 cost = GasTable.gasCopy(stateProof.memSize, memOffset, length);\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        stateProof.gas -= cost;\n//\n//        {\n//            bytes memory readContent;\n//            (offset, readContent) = MemoryLib.decodeAndVerifyMemoryLikeReadProofNoAppend(\n//                stateProof.returnDataRoot, stateProof.returnDataSize, encoded, offset, returnOffset, length\n//            );\n//\n//            bytes memory writeContent;\n//            (offset, writeContent) =\n//                MemoryLib.decodeAndVerifyMemoryWriteProof(stateProof, encoded, offset, memOffset, length);\n//\n//            require(readContent.equal(writeContent), \"Inconsistent Copy\");\n//        }\n//\n//        stateProof.pc += 1;\n//        stateProof.stackHash = stackProof.stackHashAfterPops;\n//    }\n//\n//    function verifyOpMLOAD(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 1) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n//\n//        uint64 cost = Params.G_VERYLOW;\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        stateProof.gas -= cost;\n//\n//        uint64 memOffset = uint64(stackProof.pops[0]);\n//        bytes memory readContent;\n//        (offset, readContent) = MemoryLib.decodeAndVerifyMemoryReadProof(stateProof, encoded, offset, memOffset, 32);\n//\n//        bytes32 result = readContent.toBytes32(0);\n//        stateProof.stackHash = keccak256(abi.encodePacked(stackProof.stackHashAfterPops, result));\n//        stateProof.pc += 1;\n//    }\n//\n//    function verifyOpMSTORE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 2) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 2, offset, encoded);\n//\n//        uint64 cost = Params.G_VERYLOW;\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        stateProof.gas -= cost;\n//\n//        uint64 memOffset = uint64(stackProof.pops[0]);\n//        bytes32 value = bytes32(stackProof.pops[1]);\n//        bytes memory writeContent;\n//        if (stateProof.memSize == 0) {\n//            stateProof.memSize = (memOffset + 32 + 31) / 32 * 32;\n//            writeContent = abi.encodePacked(new bytes(memOffset), value);\n//            stateProof.memRoot = MemoryLib.getMemoryRoot(writeContent);\n//        } else {\n//            (offset, writeContent) =\n//                MemoryLib.decodeAndVerifyMemoryWriteProof(stateProof, encoded, offset, memOffset, 32);\n//            require(writeContent.toBytes32(0) == value, \"Bad MemoryProof\");\n//        }\n//        stateProof.stackHash = stackProof.stackHashAfterPops;\n//        stateProof.pc += 1;\n//    }\n//\n//    function verifyOpMSTORE8(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 2) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 2, offset, encoded);\n//\n//        uint64 cost = Params.G_VERYLOW;\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        stateProof.gas -= cost;\n//\n//        uint64 memOffset = uint64(stackProof.pops[0]);\n//        uint8 value = uint8(stackProof.pops[1]);\n//        bytes memory writeContent;\n//        if (stateProof.memSize == 0) {\n//            stateProof.memSize = (memOffset + 1 + 31) / 32 * 32;\n//            writeContent = abi.encodePacked(new bytes(memOffset), value);\n//            stateProof.memRoot = MemoryLib.getMemoryRoot(writeContent);\n//        } else {\n//            (offset, writeContent) =\n//                MemoryLib.decodeAndVerifyMemoryWriteProof(stateProof, encoded, offset, memOffset, 1);\n//            require(writeContent.toUint8(0) == value, \"Bad MemoryProof\");\n//        }\n//        stateProof.stackHash = stackProof.stackHashAfterPops;\n//        stateProof.pc += 1;\n//    }\n//\n//    function verifyLogOpCode(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        uint8 topicNum = stateProof.opCode - 0xa0;\n//        if (stateProof.stackSize < 2 + topicNum) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 2 + topicNum, offset, encoded);\n//\n//        uint64 memOffset = uint64(stackProof.pops[0]);\n//        uint64 length = uint64(stackProof.pops[1]);\n//        uint64 cost = GasTable.gasLog(stateProof.memSize, memOffset, length, topicNum);\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        stateProof.gas -= cost;\n//\n//        bytes memory readContent;\n//        (offset, readContent) = MemoryLib.decodeAndVerifyMemoryReadProof(stateProof, encoded, offset, memOffset, length);\n//\n//        OneStepProof.LogProof memory logProof;\n//        (offset, logProof) = OneStepProof.decodeLogProof(encoded, offset);\n//        require(logProof.hashLogProof() == stateProof.logAcc, \"Bad LogProof\");\n//\n//        stateProof.logAcc =\n//            VerifierHelper.updateAndHashLogProof(logProof, stateProof.contractAddress, stackProof.pops, readContent);\n//        stateProof.pc += 1;\n//        stateProof.stackHash = stackProof.stackHashAfterPops;\n//    }\n}\n"
    },
    "contracts/L1/fraud-proof/verifier/subverifiers/StorageOpVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2022, Specular contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\n//import \"../../libraries/BytesLib.sol\";\n//import \"../../libraries/MPT.sol\";\n//import \"../IVerifier.sol\";\n//import \"../libraries/VerificationContext.sol\";\n//import \"../libraries/OneStepProof.sol\";\n//import \"../libraries/Params.sol\";\n//import \"../libraries/GasTable.sol\";\n//import \"../libraries/VerifierHelper.sol\";\n//import \"../libraries/EVMTypesLib.sol\";\n\ncontract StorageOpVerifier {\n//contract StorageOpVerifier is IVerifier {\n//    using BytesLib for bytes;\n//    using RLPReader for bytes;\n//    using RLPReader for RLPReader.RLPItem;\n//    using RLPReader for RLPReader.Iterator;\n//    using VerificationContext for VerificationContext.Context;\n//    using OneStepProof for OneStepProof.CodeProof;\n//    using OneStepProof for EVMTypesLib.Account;\n//\n//    function verifyOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n//        external\n//        pure\n//        override\n//        returns (bytes32)\n//    {\n//        return OneStepProof.hashStateProof(executeOneStepProof(ctx, currStateHash, encoded));\n//    }\n//\n//    function executeOneStepProof(VerificationContext.Context memory ctx, bytes32 currStateHash, bytes calldata encoded)\n//        public\n//        pure\n//        returns (OneStepProof.StateProof memory)\n//    {\n//        uint64 offset = 0;\n//        // Decode state proof\n//        OneStepProof.StateProof memory stateProof;\n//        (offset, stateProof) = OneStepProof.decodeStateProof(ctx, encoded, offset);\n//        // Calculate the state hash from the submitted proof\n//        bytes32 stateHashFromProof;\n//        assembly {\n//            let ptr := mload(0x40)\n//            calldatacopy(ptr, encoded.offset, offset)\n//            stateHashFromProof := keccak256(ptr, offset)\n//        }\n//        // Ensure the state proof is valid\n//        require(stateHashFromProof == currStateHash, \"Bad State Proof\");\n//\n//        // Decode the code proof\n//        OneStepProof.CodeProof memory codeProof;\n//        (offset, codeProof) = OneStepProof.decodeCodeProof(encoded, offset);\n//\n//        // Simulate EVM one-step execution based on the opcode\n//        uint8 opCode = stateProof.opCode;\n//        if (opCode == 0x31) {\n//            // BALANCE\n//            verifyOpBALANCE(offset, stateProof, encoded);\n//        } else if (opCode == 0x3b) {\n//            // EXTCODESIZE\n//            verifyOpEXTCODESIZE(offset, stateProof, encoded);\n//        } else if (opCode == 0x3c) {\n//            // EXTCODECOPY\n//            verifyOpEXTCODECOPY(offset, stateProof, encoded);\n//        } else if (opCode == 0x3f) {\n//            // EXTCODEHASH\n//            verifyOpEXTCODEHASH(offset, stateProof, encoded);\n//        } else if (opCode == 0x47) {\n//            // SELFBALANCE\n//            verifyOpSELFBALANCE(offset, stateProof, encoded);\n//        } else if (opCode == 0x54) {\n//            // SLOAD\n//            verifyOpSLOAD(offset, stateProof, encoded);\n//        } else if (opCode == 0x55) {\n//            // SSTORE\n//            verifyOpSSTORE(offset, stateProof, encoded);\n//        } else {\n//            revert(\"Unreachable\");\n//        }\n//\n//        // Obtain the opcode at new pc\n//        if (stateProof.depth > 0) {\n//            if (codeProof.size > uint256(stateProof.pc)) {\n//                stateProof.opCode = codeProof.getOpCodeAt(encoded, stateProof.pc);\n//            } else {\n//                stateProof.opCode = 0x00;\n//            }\n//        }\n//        // Return the state hash after one-step execution\n//        return stateProof;\n//    }\n//\n//    function verifyOpBALANCE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 1) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n//\n//        uint64 cost = Params.G_BALANCE;\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//        }\n//        stateProof.gas -= cost;\n//\n//        OneStepProof.RLPProof memory accountProof;\n//        (offset, accountProof) = OneStepProof.decodeRLPProof(encoded, offset);\n//        bytes32 addressHash = keccak256(abi.encodePacked(address(uint160(stackProof.pops[0]))));\n//        bytes memory encodedAccount = MPT.extractProofValue(\n//            stateProof.globalStateRoot, abi.encodePacked(addressHash), accountProof.proof.toList()\n//        );\n//        EVMTypesLib.Account memory account = EVMTypesLib.decodeAccount(encodedAccount.toRlpItem());\n//\n//        stateProof.pc += 1;\n//        stateProof.stackHash = keccak256(abi.encodePacked(stackProof.stackHashAfterPops, account.balance));\n//    }\n//\n//    function verifyOpEXTCODESIZE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 1) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n//\n//        uint64 cost = Params.G_EXTCODE;\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//        }\n//        stateProof.gas -= cost;\n//\n//        OneStepProof.RLPProof memory accountProof;\n//        (offset, accountProof) = OneStepProof.decodeRLPProof(encoded, offset);\n//        bytes32 addressHash = keccak256(abi.encodePacked(address(uint160(stackProof.pops[0]))));\n//        bytes memory encodedAccount = MPT.extractProofValue(\n//            stateProof.globalStateRoot, abi.encodePacked(addressHash), accountProof.proof.toList()\n//        );\n//        EVMTypesLib.Account memory account = EVMTypesLib.decodeAccount(encodedAccount.toRlpItem());\n//\n//        OneStepProof.CodeProof memory codeProof;\n//        (offset, codeProof) = OneStepProof.decodeCodeProof(encoded, offset);\n//\n//        require(codeProof.hashCodeProof(encoded) == account.codeHash, \"Bad Code Proof\");\n//\n//        stateProof.pc += 1;\n//        stateProof.stackHash = keccak256(abi.encodePacked(stackProof.stackHashAfterPops, codeProof.size));\n//    }\n//\n//    function verifyOpEXTCODECOPY(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 4) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 4, offset, encoded);\n//\n//        {\n//            uint64 cost =\n//                GasTable.gasExtCopy(stateProof.memSize, uint64(stackProof.pops[1]), uint64(stackProof.pops[3]));\n//            if (stateProof.gas < cost) {\n//                VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            }\n//            stateProof.gas -= cost;\n//        }\n//\n//        EVMTypesLib.Account memory account;\n//        {\n//            OneStepProof.RLPProof memory accountProof;\n//            (offset, accountProof) = OneStepProof.decodeRLPProof(encoded, offset);\n//            bytes32 addressHash = keccak256(abi.encodePacked(address(uint160(stackProof.pops[0]))));\n//            bytes memory encodedAccount = MPT.extractProofValue(\n//                stateProof.globalStateRoot, abi.encodePacked(addressHash), accountProof.proof.toList()\n//            );\n//            account = EVMTypesLib.decodeAccount(encodedAccount.toRlpItem());\n//        }\n//\n//        OneStepProof.CodeProof memory codeProof;\n//        (offset, codeProof) = OneStepProof.decodeCodeProof(encoded, offset);\n//\n//        require(codeProof.hashCodeProof(encoded) == account.codeHash, \"Bad Code Proof\");\n//        {\n//            bytes memory readContent =\n//                codeProof.getCodeSlice(encoded, uint64(stackProof.pops[2]), uint64(stackProof.pops[3]));\n//            bytes memory writeContent;\n//            (offset, writeContent) = MemoryLib.decodeAndVerifyMemoryWriteProof(\n//                stateProof, encoded, offset, uint64(stackProof.pops[1]), uint64(stackProof.pops[3])\n//            );\n//\n//            require(readContent.equal(writeContent), \"Inconsistent Copy\");\n//        }\n//\n//        stateProof.pc += 1;\n//        stateProof.stackSize -= 4;\n//        stateProof.stackHash = stackProof.stackHashAfterPops;\n//    }\n//\n//    function verifyOpEXTCODEHASH(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 1) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n//\n//        uint64 cost = Params.G_EXTCODE;\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//        }\n//        stateProof.gas -= cost;\n//\n//        OneStepProof.RLPProof memory accountProof;\n//        (offset, accountProof) = OneStepProof.decodeRLPProof(encoded, offset);\n//        bytes32 addressHash = keccak256(abi.encodePacked(address(uint160(stackProof.pops[0]))));\n//        bytes memory encodedAccount = MPT.extractProofValue(\n//            stateProof.globalStateRoot, abi.encodePacked(addressHash), accountProof.proof.toList()\n//        );\n//        EVMTypesLib.Account memory account = EVMTypesLib.decodeAccount(encodedAccount.toRlpItem());\n//\n//        stateProof.pc += 1;\n//        stateProof.stackHash = keccak256(abi.encodePacked(stackProof.stackHashAfterPops, account.codeHash));\n//    }\n//\n//    function verifyOpSELFBALANCE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize >= Params.STACK_LIMIT - 1) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//\n//        uint64 cost = Params.G_LOW;\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//        }\n//        stateProof.gas -= cost;\n//\n//        OneStepProof.RLPProof memory accountProof;\n//        (offset, accountProof) = OneStepProof.decodeRLPProof(encoded, offset);\n//        bytes32 addressHash = keccak256(abi.encodePacked(stateProof.contractAddress));\n//        bytes memory encodedAccount = MPT.extractProofValue(\n//            stateProof.globalStateRoot, abi.encodePacked(addressHash), accountProof.proof.toList()\n//        );\n//        EVMTypesLib.Account memory account = EVMTypesLib.decodeAccount(encodedAccount.toRlpItem());\n//\n//        stateProof.pc += 1;\n//        stateProof.stackSize += 1;\n//        stateProof.stackHash = keccak256(abi.encodePacked(stateProof.stackHash, account.codeHash));\n//    }\n//\n//    function verifyOpSLOAD(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {\n//        if (stateProof.stackSize < 1) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//            return;\n//        }\n//        OneStepProof.StackProof memory stackProof;\n//        (offset, stackProof) = VerifierHelper.decodeAndVerifyStackProof(stateProof, 1, offset, encoded);\n//\n//        uint64 cost = Params.G_LOW;\n//        if (stateProof.gas < cost) {\n//            VerifierHelper.verifyRevertByError(offset, stateProof, encoded);\n//        }\n//        stateProof.gas -= cost;\n//\n//        OneStepProof.RLPProof memory accountProof;\n//        (offset, accountProof) = OneStepProof.decodeRLPProof(encoded, offset);\n//        bytes32 addressHash = keccak256(abi.encodePacked(stateProof.contractAddress));\n//        bytes memory encodedAccount = MPT.extractProofValue(\n//            stateProof.globalStateRoot, abi.encodePacked(addressHash), accountProof.proof.toList()\n//        );\n//        EVMTypesLib.Account memory account = EVMTypesLib.decodeAccount(encodedAccount.toRlpItem());\n//\n//        OneStepProof.RLPProof memory storageProof;\n//        (offset, storageProof) = OneStepProof.decodeRLPProof(encoded, offset);\n//        bytes memory value = MPT.extractProofValue(\n//            account.storageRoot, abi.encodePacked(bytes32(stackProof.pops[0])), storageProof.proof.toList()\n//        );\n//\n//        stateProof.pc += 1;\n//        stateProof.stackHash = keccak256(abi.encodePacked(stateProof.stackHash, value.toBytes32Pad(0)));\n//    }\n//\n//    function verifyOpSSTORE(uint64 offset, OneStepProof.StateProof memory stateProof, bytes calldata encoded)\n//        internal\n//        pure\n//    {}\n}\n"
    },
    "contracts/L1/local/TestnetMantleToken.sol": {
      "content": "//// SPDX-License-Identifier: MIT\n//pragma solidity ^0.8.9;\n//\n//import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n//\n//contract L1MantleToken is ERC20 {\n//    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n//        // Mint 100 tokens to msg.sender\n//        // Similar to how\n//        // 1 dollar = 100 cents\n//        // 1 token = 1 * (10 ** decimals)\n//        _mint(msg.sender, 10000 * 10**uint(decimals()));\n//    }\n//\n//    // public mint for any user\n//    function mint(uint256 amount) external {\n//        require(msg.sender != address(0), \"ERC20: mint to the zero address\");\n//        _mint(msg.sender, amount);\n//    }\n//}\n"
    },
    "contracts/L2/predeploys/BVM_DeployerWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title BVM_DeployerWhitelist\n * @dev The Deployer Whitelist is a temporary predeploy used to provide additional safety during the\n * initial phases of our mainnet roll out. It is owned by the Mantle team, and defines accounts\n * which are allowed to deploy contracts on Layer2. The Execution Manager will only allow an\n * bvmCREATE or bvmCREATE2 operation to proceed if the deployer's address whitelisted.\n */\ncontract BVM_DeployerWhitelist {\n    /**********\n     * Events *\n     **********/\n\n    event OwnerChanged(address oldOwner, address newOwner);\n    event WhitelistStatusChanged(address deployer, bool whitelisted);\n    event WhitelistDisabled(address oldOwner);\n\n    /**********************\n     * Contract Constants *\n     **********************/\n\n    // WARNING: When owner is set to address(0), the whitelist is disabled.\n    address public owner;\n    mapping(address => bool) public whitelist;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Blocks functions to anyone except the contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Function can only be called by the owner of this contract.\");\n        _;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Adds or removes an address from the deployment whitelist.\n     * @param _deployer Address to update permissions for.\n     * @param _isWhitelisted Whether or not the address is whitelisted.\n     */\n    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external onlyOwner {\n        whitelist[_deployer] = _isWhitelisted;\n        emit WhitelistStatusChanged(_deployer, _isWhitelisted);\n    }\n\n    /**\n     * Updates the owner of this contract.\n     * @param _owner Address of the new owner.\n     */\n    // slither-disable-next-line external-function\n    function setOwner(address _owner) public onlyOwner {\n        // Prevent users from setting the whitelist owner to address(0) except via\n        // enableArbitraryContractDeployment. If you want to burn the whitelist owner, send it to\n        // any other address that doesn't have a corresponding knowable private key.\n        require(\n            _owner != address(0),\n            \"BVM_DeployerWhitelist: can only be disabled via enableArbitraryContractDeployment\"\n        );\n\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    /**\n     * Permanently enables arbitrary contract deployment and deletes the owner.\n     */\n    function enableArbitraryContractDeployment() external onlyOwner {\n        emit WhitelistDisabled(owner);\n        owner = address(0);\n    }\n\n    /**\n     * Checks whether an address is allowed to deploy contracts.\n     * @param _deployer Address to check.\n     * @return _allowed Whether or not the address can deploy contracts.\n     */\n    function isDeployerAllowed(address _deployer) external view returns (bool) {\n        return (owner == address(0) || whitelist[_deployer]);\n    }\n}\n"
    },
    "contracts/L2/predeploys/iBVM_L1BlockNumber.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title iBVM_L1BlockNumber\n */\ninterface iBVM_L1BlockNumber {\n    /********************\n     * Public Functions *\n     ********************/\n\n    function getL1BlockNumber() external view returns (uint256);\n}\n"
    },
    "contracts/test-helpers/EmptyContract.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\ncontract EmptyContract {\n    function foo() public pure returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/test-helpers/FailingReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9;\n\ncontract FailingReceiver {\n    receive() external payable {\n        revert(\"FailingReceiver\");\n    }\n}\n"
    },
    "contracts/test-helpers/MockStateCommitmentChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract MockStateCommitmentChain  {\n    function appendStateBatch(bytes32[] memory _batch, uint256 _shouldStartAtElement, bytes memory _signature) public {\n        return;\n    }\n\n    function FRAUD_PROOF_WINDOW()  external returns(uint256){\n        return 0;\n    }\n}\n"
    },
    "contracts/test-helpers/TestUpgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract Test {\n    int32 public versionNum;\n\n    function initialize() public {}\n\n    function setVersion() public virtual {\n        versionNum = 1;\n    }\n\n    function version() public view virtual returns (int32) {\n        return versionNum;\n    }\n}\n\ncontract TestUpgrade is Test {\n    int32 public checkNum;\n    function setCheckNum(int32 _num) public {\n        checkNum = _num;\n    }\n\n    function setVersion() public override {\n        versionNum = 2;\n    }\n\n    function version() public view override returns (int32) {\n        return versionNum;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}